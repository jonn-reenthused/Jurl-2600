------- FILE /Users/jblanchard/Documents/Code/Retro/Atari2600/Jurl/Jurl.bas.asm LEVEL 1 PASS 2
      1  5000 ????						; Provided under the CC0 license. See the included LICENSE.txt for details.
      2  5000 ????
      3  5000 ????				      processor	6502
------- FILE vcs.h LEVEL 2 PASS 2
      0  5000 ????				      include	"vcs.h"
      1  5000 ????						; Provided under the CC0 license. See the included LICENSE.txt for details.
      2  5000 ????
      3  5000 ????						; VCS.H
      4  5000 ????						; Version 1.05, 13/November/2003
      5  5000 ????
      6  5000 ????	       00 69	   VERSION_VCS =	105
      7  5000 ????
      8  5000 ????						; THIS IS A PRELIMINARY RELEASE OF *THE* "STANDARD" VCS.H
      9  5000 ????						; THIS FILE IS EXPLICITLY SUPPORTED AS A DASM-PREFERRED COMPANION FILE
     10  5000 ????						; PLEASE DO *NOT* REDISTRIBUTE THIS FILE!
     11  5000 ????						;
     12  5000 ????						; This file defines hardware registers and memory mapping for the
     13  5000 ????						; Atari 2600. It is distributed as a companion machine-specific support package
     14  5000 ????						; for the DASM compiler. Updates to this file, DASM, and associated tools are
     15  5000 ????						; available at at http://www.atari2600.org/dasm
     16  5000 ????						;
     17  5000 ????						; Many thanks to the original author(s) of this file, and to everyone who has
     18  5000 ????						; contributed to understanding the Atari 2600.  If you take issue with the
     19  5000 ????						; contents, or naming of registers, please write to me (atari2600@taswegian.com)
     20  5000 ????						; with your views.  Please contribute, if you think you can improve this
     21  5000 ????						; file!
     22  5000 ????						;
     23  5000 ????						; Latest Revisions...
     24  5000 ????						; 1.05  13/NOV/2003	  - Correction to 1.04 - now functions as requested by MR.
     25  5000 ????						;			  - Added VERSION_VCS equate (which will reflect 100x version #)
     26  5000 ????						;			    This will allow conditional code to verify VCS.H being
     27  5000 ????						;			    used for code assembly.
     28  5000 ????						; 1.04  12/NOV/2003	 Added TIA_BASE_WRITE_ADDRESS and TIA_BASE_READ_ADDRESS for
     29  5000 ????						;			 convenient disassembly/reassembly compatibility for hardware
     30  5000 ????						;			 mirrored reading/writing differences.	This is more a 
     31  5000 ????						;			 readability issue, and binary compatibility with disassembled
     32  5000 ????						;			 and reassembled sources.  Per Manuel Rotschkar's suggestion.
     33  5000 ????						; 1.03  12/MAY/2003	 Added SEG segment at end of file to fix old-code compatibility
     34  5000 ????						;			 which was broken by the use of segments in this file, as
     35  5000 ????						;			 reported by Manuel Polik on [stella] 11/MAY/2003
     36  5000 ????						; 1.02  22/MAR/2003	 Added TIMINT($285)
     37  5000 ????						; 1.01				Constant offset added to allow use for 3F-style bankswitching
     38  5000 ????						;						 - define TIA_BASE_ADDRESS as $40 for Tigervision carts, otherwise
     39  5000 ????						;						   it is safe to leave it undefined, and the base address will
     40  5000 ????						;						   be set to 0.  Thanks to Eckhard Stolberg for the suggestion.
     41  5000 ????						;			    Note, may use -DLABEL=EXPRESSION to define TIA_BASE_ADDRESS
     42  5000 ????						;			  - register definitions are now generated through assignment
     43  5000 ????						;			    in uninitialised segments.	This allows a changeable base
     44  5000 ????						;			    address architecture.
     45  5000 ????						; 1.0	22/MAR/2003		Initial release
     46  5000 ????
     47  5000 ????
     48  5000 ????						;-------------------------------------------------------------------------------
     49  5000 ????
     50  5000 ????						; TIA_BASE_ADDRESS
     51  5000 ????						; The TIA_BASE_ADDRESS defines the base address of access to TIA registers.
     52  5000 ????						; Normally 0, the base address should (externally, before including this file)
     53  5000 ????						; be set to $40 when creating 3F-bankswitched (and other?) cartridges.
     54  5000 ????						; The reason is that this bankswitching scheme treats any access to locations
     55  5000 ????						; < $40 as a bankswitch.
     56  5000 ????
     57  5000 ????			  -	      IFNCONST	TIA_BASE_ADDRESS
     58  5000 ????			  -TIA_BASE_ADDRESS =	0
     59  5000 ????				      ENDIF
     60  5000 ????
     61  5000 ????						; Note: The address may be defined on the command-line using the -D switch, eg:
     62  5000 ????						; dasm.exe code.asm -DTIA_BASE_ADDRESS=$40 -f3 -v5 -ocode.bin
     63  5000 ????						; *OR* by declaring the label before including this file, eg:
     64  5000 ????						; TIA_BASE_ADDRESS = $40
     65  5000 ????						;   include "vcs.h"
     66  5000 ????
     67  5000 ????						; Alternate read/write address capability - allows for some disassembly compatibility
     68  5000 ????						; usage ; to allow reassembly to binary perfect copies).  This is essentially catering
     69  5000 ????						; for the mirrored ROM hardware registers.
     70  5000 ????
     71  5000 ????						; Usage: As per above, define the TIA_BASE_READ_ADDRESS and/or TIA_BASE_WRITE_ADDRESS
     72  5000 ????						; using the -D command-line switch, as required.  If the addresses are not defined, 
     73  5000 ????						; they defaut to the TIA_BASE_ADDRESS.
     74  5000 ????
     75  5000 ????			  -	      IFNCONST	TIA_BASE_READ_ADDRESS
     76  5000 ????			  -TIA_BASE_READ_ADDRESS =	TIA_BASE_ADDRESS
     77  5000 ????				      ENDIF
     78  5000 ????
     79  5000 ????			  -	      IFNCONST	TIA_BASE_WRITE_ADDRESS
     80  5000 ????			  -TIA_BASE_WRITE_ADDRESS =	TIA_BASE_ADDRESS
     81  5000 ????				      ENDIF
     82  5000 ????
     83  5000 ????						;-------------------------------------------------------------------------------
     84  5000 ????
     85 U002d ????				      SEG.U	TIA_REGISTERS_WRITE
     86 U0000					      ORG	TIA_BASE_WRITE_ADDRESS
     87 U0000
     88 U0000							; DO NOT CHANGE THE RELATIVE ORDERING OF REGISTERS!
     89 U0000
     90 U0000		       00	   VSYNC      ds	1	; $00	 0000 00x0   Vertical Sync Set-Clear
     91 U0001		       00	   VBLANK     ds	1	; $01	 xx00 00x0   Vertical Blank Set-Clear
     92 U0002		       00	   WSYNC      ds	1	; $02	 ---- ----   Wait for Horizontal Blank
     93 U0003		       00	   RSYNC      ds	1	; $03	 ---- ----   Reset Horizontal Sync Counter
     94 U0004		       00	   NUSIZ0     ds	1	; $04	 00xx 0xxx   Number-Size player/missle 0
     95 U0005		       00	   NUSIZ1     ds	1	; $05	 00xx 0xxx   Number-Size player/missle 1
     96 U0006		       00	   COLUP0     ds	1	; $06	 xxxx xxx0   Color-Luminance Player 0
     97 U0007		       00	   COLUP1     ds	1	; $07	 xxxx xxx0   Color-Luminance Player 1
     98 U0008		       00	   COLUPF     ds	1	; $08	 xxxx xxx0   Color-Luminance Playfield
     99 U0009		       00	   COLUBK     ds	1	; $09	 xxxx xxx0   Color-Luminance Background
    100 U000a		       00	   CTRLPF     ds	1	; $0A	 00xx 0xxx   Control Playfield, Ball, Collisions
    101 U000b		       00	   REFP0      ds	1	; $0B	 0000 x000   Reflection Player 0
    102 U000c		       00	   REFP1      ds	1	; $0C	 0000 x000   Reflection Player 1
    103 U000d		       00	   PF0	      ds	1	; $0D	 xxxx 0000   Playfield Register Byte 0
    104 U000e		       00	   PF1	      ds	1	; $0E	 xxxx xxxx   Playfield Register Byte 1
    105 U000f		       00	   PF2	      ds	1	; $0F	 xxxx xxxx   Playfield Register Byte 2
    106 U0010		       00	   RESP0      ds	1	; $10	 ---- ----   Reset Player 0
    107 U0011		       00	   RESP1      ds	1	; $11	 ---- ----   Reset Player 1
    108 U0012		       00	   RESM0      ds	1	; $12	 ---- ----   Reset Missle 0
    109 U0013		       00	   RESM1      ds	1	; $13	 ---- ----   Reset Missle 1
    110 U0014		       00	   RESBL      ds	1	; $14	 ---- ----   Reset Ball
    111 U0015		       00	   AUDC0      ds	1	; $15	 0000 xxxx   Audio Control 0
    112 U0016		       00	   AUDC1      ds	1	; $16	 0000 xxxx   Audio Control 1
    113 U0017		       00	   AUDF0      ds	1	; $17	 000x xxxx   Audio Frequency 0
    114 U0018		       00	   AUDF1      ds	1	; $18	 000x xxxx   Audio Frequency 1
    115 U0019		       00	   AUDV0      ds	1	; $19	 0000 xxxx   Audio Volume 0
    116 U001a		       00	   AUDV1      ds	1	; $1A	 0000 xxxx   Audio Volume 1
    117 U001b		       00	   GRP0       ds	1	; $1B	 xxxx xxxx   Graphics Register Player 0
    118 U001c		       00	   GRP1       ds	1	; $1C	 xxxx xxxx   Graphics Register Player 1
    119 U001d		       00	   ENAM0      ds	1	; $1D	 0000 00x0   Graphics Enable Missle 0
    120 U001e		       00	   ENAM1      ds	1	; $1E	 0000 00x0   Graphics Enable Missle 1
    121 U001f		       00	   ENABL      ds	1	; $1F	 0000 00x0   Graphics Enable Ball
    122 U0020		       00	   HMP0       ds	1	; $20	 xxxx 0000   Horizontal Motion Player 0
    123 U0021		       00	   HMP1       ds	1	; $21	 xxxx 0000   Horizontal Motion Player 1
    124 U0022		       00	   HMM0       ds	1	; $22	 xxxx 0000   Horizontal Motion Missle 0
    125 U0023		       00	   HMM1       ds	1	; $23	 xxxx 0000   Horizontal Motion Missle 1
    126 U0024		       00	   HMBL       ds	1	; $24	 xxxx 0000   Horizontal Motion Ball
    127 U0025		       00	   VDELP0     ds	1	; $25	 0000 000x   Vertical Delay Player 0
    128 U0026		       00	   VDELP1     ds	1	; $26	 0000 000x   Vertical Delay Player 1
    129 U0027		       00	   VDELBL     ds	1	; $27	 0000 000x   Vertical Delay Ball
    130 U0028		       00	   RESMP0     ds	1	; $28	 0000 00x0   Reset Missle 0 to Player 0
    131 U0029		       00	   RESMP1     ds	1	; $29	 0000 00x0   Reset Missle 1 to Player 1
    132 U002a		       00	   HMOVE      ds	1	; $2A	 ---- ----   Apply Horizontal Motion
    133 U002b		       00	   HMCLR      ds	1	; $2B	 ---- ----   Clear Horizontal Move Registers
    134 U002c		       00	   CXCLR      ds	1	; $2C	 ---- ----   Clear Collision Latches
    135 U002d
    136 U002d							;-------------------------------------------------------------------------------
    137 U002d
    138 U000e ????				      SEG.U	TIA_REGISTERS_READ
    139 U0000					      ORG	TIA_BASE_READ_ADDRESS
    140 U0000
    141 U0000							;											bit 7	 bit 6
    142 U0000		       00	   CXM0P      ds	1	; $00	     xx00 0000	     Read Collision  M0-P1   M0-P0
    143 U0001		       00	   CXM1P      ds	1	; $01	     xx00 0000			     M1-P0   M1-P1
    144 U0002		       00	   CXP0FB     ds	1	; $02	     xx00 0000			     P0-PF   P0-BL
    145 U0003		       00	   CXP1FB     ds	1	; $03	     xx00 0000			     P1-PF   P1-BL
    146 U0004		       00	   CXM0FB     ds	1	; $04	     xx00 0000			     M0-PF   M0-BL
    147 U0005		       00	   CXM1FB     ds	1	; $05	     xx00 0000			     M1-PF   M1-BL
    148 U0006		       00	   CXBLPF     ds	1	; $06	     x000 0000			     BL-PF   -----
    149 U0007		       00	   CXPPMM     ds	1	; $07	     xx00 0000			     P0-P1   M0-M1
    150 U0008		       00	   INPT0      ds	1	; $08	     x000 0000	     Read Pot Port 0
    151 U0009		       00	   INPT1      ds	1	; $09	     x000 0000	     Read Pot Port 1
    152 U000a		       00	   INPT2      ds	1	; $0A	     x000 0000	     Read Pot Port 2
    153 U000b		       00	   INPT3      ds	1	; $0B	     x000 0000	     Read Pot Port 3
    154 U000c		       00	   INPT4      ds	1	; $0C		x000 0000	 Read Input (Trigger) 0
    155 U000d		       00	   INPT5      ds	1	; $0D		x000 0000	 Read Input (Trigger) 1
    156 U000e
    157 U000e							;-------------------------------------------------------------------------------
    158 U000e
    159 U0298 ????				      SEG.U	RIOT
    160 U0280					      ORG	$280
    161 U0280
    162 U0280							; RIOT MEMORY MAP
    163 U0280
    164 U0280		       00	   SWCHA      ds	1	; $280      Port A data register for joysticks:
    165 U0281							;			Bits 4-7 for player 1.  Bits 0-3 for player 2.
    166 U0281
    167 U0281		       00	   SWACNT     ds	1	; $281      Port A data direction register (DDR)
    168 U0282		       00	   SWCHB      ds	1	; $282		Port B data (console switches)
    169 U0283		       00	   SWBCNT     ds	1	; $283      Port B DDR
    170 U0284		       00	   INTIM      ds	1	; $284		Timer output
    171 U0285
    172 U0285		       00	   TIMINT     ds	1	; $285
    173 U0286
    174 U0286							; Unused/undefined registers ($285-$294)
    175 U0286
    176 U0286		       00		      ds	1	; $286
    177 U0287		       00		      ds	1	; $287
    178 U0288		       00		      ds	1	; $288
    179 U0289		       00		      ds	1	; $289
    180 U028a		       00		      ds	1	; $28A
    181 U028b		       00		      ds	1	; $28B
    182 U028c		       00		      ds	1	; $28C
    183 U028d		       00		      ds	1	; $28D
    184 U028e		       00		      ds	1	; $28E
    185 U028f		       00		      ds	1	; $28F
    186 U0290		       00		      ds	1	; $290
    187 U0291		       00		      ds	1	; $291
    188 U0292		       00		      ds	1	; $292
    189 U0293		       00		      ds	1	; $293
    190 U0294
    191 U0294		       00	   TIM1T      ds	1	; $294		set 1 clock interval
    192 U0295		       00	   TIM8T      ds	1	; $295      set 8 clock interval
    193 U0296		       00	   TIM64T     ds	1	; $296      set 64 clock interval
    194 U0297		       00	   T1024T     ds	1	; $297      set 1024 clock interval
    195 U0298
    196 U0298							;-------------------------------------------------------------------------------
    197 U0298							; The following required for back-compatibility with code which does not use
    198 U0298							; segments.
    199 U0298
    200  5000 ????				      SEG
    201  5000 ????
    202  5000 ????						; EOF
------- FILE /Users/jblanchard/Documents/Code/Retro/Atari2600/Jurl/Jurl.bas.asm
------- FILE macro.h LEVEL 2 PASS 2
      0  5000 ????				      include	"macro.h"
      1  5000 ????						; Provided under the CC0 license. See the included LICENSE.txt for details.
      2  5000 ????
      3  5000 ????						; MACRO.H
      4  5000 ????						; Version 1.05, 13/NOVEMBER/2003
      5  5000 ????
      6  5000 ????	       00 69	   VERSION_MACRO =	105
      7  5000 ????
      8  5000 ????						;
      9  5000 ????						; THIS FILE IS EXPLICITLY SUPPORTED AS A DASM-PREFERRED COMPANION FILE
     10  5000 ????						; PLEASE DO *NOT* REDISTRIBUTE MODIFIED VERSIONS OF THIS FILE!
     11  5000 ????						;
     12  5000 ????						; This file defines DASM macros useful for development for the Atari 2600.
     13  5000 ????						; It is distributed as a companion machine-specific support package
     14  5000 ????						; for the DASM compiler. Updates to this file, DASM, and associated tools are
     15  5000 ????						; available at at http://www.atari2600.org/dasm
     16  5000 ????						;
     17  5000 ????						; Many thanks to the people who have contributed.  If you take issue with the
     18  5000 ????						; contents, or would like to add something, please write to me
     19  5000 ????						; (atari2600@taswegian.com) with your contribution.
     20  5000 ????						;
     21  5000 ????						; Latest Revisions...
     22  5000 ????						;
     23  5000 ????						; 1.05  14/NOV/2003	  - Added VERSION_MACRO equate (which will reflect 100x version #)
     24  5000 ????						;			    This will allow conditional code to verify MACRO.H being
     25  5000 ????						;			    used for code assembly.
     26  5000 ????						; 1.04  13/NOV/2003	 - SET_POINTER macro added (16-bit address load)
     27  5000 ????						;
     28  5000 ????						; 1.03  23/JUN/2003	 - CLEAN_START macro added - clears TIA, RAM, registers
     29  5000 ????						;
     30  5000 ????						; 1.02  14/JUN/2003	 - VERTICAL_SYNC macro added
     31  5000 ????						;			   (standardised macro for vertical synch code)
     32  5000 ????						; 1.01  22/MAR/2003	 - SLEEP macro added. 
     33  5000 ????						;			 - NO_ILLEGAL_OPCODES switch implemented
     34  5000 ????						; 1.0	22/MAR/2003		Initial release
     35  5000 ????
     36  5000 ????						; Note: These macros use illegal opcodes.  To disable illegal opcode usage, 
     37  5000 ????						;   define the symbol NO_ILLEGAL_OPCODES (-DNO_ILLEGAL_OPCODES=1 on command-line).
     38  5000 ????						;   If you do not allow illegal opcode usage, you must include this file 
     39  5000 ????						;   *after* including VCS.H (as the non-illegal opcodes access hardware
     40  5000 ????						;   registers and require them to be defined first).
     41  5000 ????
     42  5000 ????						; Available macros...
     43  5000 ????						;   SLEEP n		 - sleep for n cycles
     44  5000 ????						;   VERTICAL_SYNC	 - correct 3 scanline vertical synch code
     45  5000 ????						;   CLEAN_START	 - set machine to known state on startup
     46  5000 ????						;   SET_POINTER	 - load a 16-bit absolute to a 16-bit variable
     47  5000 ????
     48  5000 ????						;-------------------------------------------------------------------------------
     49  5000 ????						; SLEEP duration
     50  5000 ????						; Original author: Thomas Jentzsch
     51  5000 ????						; Inserts code which takes the specified number of cycles to execute.	This is
     52  5000 ????						; useful for code where precise timing is required.
     53  5000 ????						; ILLEGAL-OPCODE VERSION DOES NOT AFFECT FLAGS OR REGISTERS.
     54  5000 ????						; LEGAL OPCODE VERSION MAY AFFECT FLAGS
     55  5000 ????						; Uses illegal opcode (DASM 2.20.01 onwards).
     56  5000 ????
     57  5000 ????				      MAC	sleep
     58  5000 ????			   .CYCLES    SET	{1}
     59  5000 ????
     60  5000 ????				      IF	.CYCLES < 2
     61  5000 ????				      ECHO	"MACRO ERROR: 'SLEEP': Duration must be > 1"
     62  5000 ????				      ERR
     63  5000 ????				      ENDIF
     64  5000 ????
     65  5000 ????				      IF	.CYCLES & 1
     66  5000 ????				      IFNCONST	NO_ILLEGAL_OPCODES
     67  5000 ????				      nop	0
     68  5000 ????				      ELSE
     69  5000 ????				      bit	VSYNC
     70  5000 ????				      ENDIF
     71  5000 ????			   .CYCLES    SET	.CYCLES - 3
     72  5000 ????				      ENDIF
     73  5000 ????
     74  5000 ????				      REPEAT	.CYCLES / 2
     75  5000 ????				      nop
     76  5000 ????				      REPEND
     77  5000 ????				      ENDM		;usage: SLEEP n (n>1)
     78  5000 ????
     79  5000 ????						;-------------------------------------------------------------------------------
     80  5000 ????						; VERTICAL_SYNC
     81  5000 ????						; Original author: Manuel Polik
     82  5000 ????						; Inserts the code required for a proper 3 scannline 
     83  5000 ????						; vertical sync sequence
     84  5000 ????						;
     85  5000 ????						; Note: Alters the accumulator
     86  5000 ????						;
     87  5000 ????						; IN:
     88  5000 ????						; OUT: A = 1
     89  5000 ????
     90  5000 ????				      MAC	vertical_sync
     91  5000 ????				      LDA	#$02	; A = VSYNC enable
     92  5000 ????				      STA	WSYNC	; Finish current line
     93  5000 ????				      STA	VSYNC	; Start vertical sync
     94  5000 ????				      STA	WSYNC	; 1st line vertical sync
     95  5000 ????				      STA	WSYNC	; 2nd line vertical sync
     96  5000 ????				      LSR		; A = VSYNC disable
     97  5000 ????				      STA	WSYNC	; 3rd line vertical sync
     98  5000 ????				      STA	VSYNC	; Stop vertical sync
     99  5000 ????				      ENDM
    100  5000 ????
    101  5000 ????						;-------------------------------------------------------------------------------
    102  5000 ????						; CLEAN_START
    103  5000 ????						; Original author: Andrew Davie
    104  5000 ????						; Standardised start-up code, clears stack, all TIA registers and RAM to 0
    105  5000 ????						; Sets stack pointer to $FF, and all registers to 0
    106  5000 ????						; Sets decimal mode off, sets interrupt flag (kind of un-necessary)
    107  5000 ????						; Use as very first section of code on boot (ie: at reset)
    108  5000 ????						; Code written to minimise total ROM usage - uses weird 6502 knowledge :)
    109  5000 ????
    110  5000 ????				      MAC	clean_start
    111  5000 ????				      sei
    112  5000 ????				      cld
    113  5000 ????
    114  5000 ????				      ldx	#0
    115  5000 ????				      txa
    116  5000 ????				      tay
    117  5000 ????			   .CLEAR_STACK dex
    118  5000 ????				      txs
    119  5000 ????				      pha
    120  5000 ????				      bne	.CLEAR_STACK	; SP=$FF, X = A = Y = 0
    121  5000 ????
    122  5000 ????				      ENDM
    123  5000 ????
    124  5000 ????						;-------------------------------------------------------
    125  5000 ????						; SET_POINTER
    126  5000 ????						; Original author: Manuel Rotschkar
    127  5000 ????						;
    128  5000 ????						; Sets a 2 byte RAM pointer to an absolute address.
    129  5000 ????						;
    130  5000 ????						; Usage: SET_POINTER pointer, address
    131  5000 ????						; Example: SET_POINTER SpritePTR, SpriteData
    132  5000 ????						;
    133  5000 ????						; Note: Alters the accumulator, NZ flags
    134  5000 ????						; IN 1: 2 byte RAM location reserved for pointer
    135  5000 ????						; IN 2: absolute address
    136  5000 ????
    137  5000 ????				      MAC	set_pointer
    138  5000 ????			   .POINTER   SET	{1}
    139  5000 ????			   .ADDRESS   SET	{2}
    140  5000 ????
    141  5000 ????				      LDA	#<.ADDRESS	; Get Lowbyte of Address
    142  5000 ????				      STA	.POINTER	; Store in pointer
    143  5000 ????				      LDA	#>.ADDRESS	; Get Hibyte of Address
    144  5000 ????				      STA	.POINTER+1	; Store in pointer+1
    145  5000 ????
    146  5000 ????				      ENDM
    147  5000 ????
    148  5000 ????						; EOF
------- FILE /Users/jblanchard/Documents/Code/Retro/Atari2600/Jurl/Jurl.bas.asm
------- FILE 2600basic.h LEVEL 2 PASS 2
      0  5000 ????				      include	"2600basic.h"
      1  5000 ????						; Provided under the CC0 license. See the included LICENSE.txt for details.
      2  5000 ????
      3  5000 ????				      processor	6502
------- FILE vcs.h LEVEL 3 PASS 2
      0  5000 ????				      include	"vcs.h"
      1  5000 ????						; Provided under the CC0 license. See the included LICENSE.txt for details.
      2  5000 ????
      3  5000 ????						; VCS.H
      4  5000 ????						; Version 1.05, 13/November/2003
      5  5000 ????
      6  5000 ????	       00 69	   VERSION_VCS =	105
      7  5000 ????
      8  5000 ????						; THIS IS A PRELIMINARY RELEASE OF *THE* "STANDARD" VCS.H
      9  5000 ????						; THIS FILE IS EXPLICITLY SUPPORTED AS A DASM-PREFERRED COMPANION FILE
     10  5000 ????						; PLEASE DO *NOT* REDISTRIBUTE THIS FILE!
     11  5000 ????						;
     12  5000 ????						; This file defines hardware registers and memory mapping for the
     13  5000 ????						; Atari 2600. It is distributed as a companion machine-specific support package
     14  5000 ????						; for the DASM compiler. Updates to this file, DASM, and associated tools are
     15  5000 ????						; available at at http://www.atari2600.org/dasm
     16  5000 ????						;
     17  5000 ????						; Many thanks to the original author(s) of this file, and to everyone who has
     18  5000 ????						; contributed to understanding the Atari 2600.  If you take issue with the
     19  5000 ????						; contents, or naming of registers, please write to me (atari2600@taswegian.com)
     20  5000 ????						; with your views.  Please contribute, if you think you can improve this
     21  5000 ????						; file!
     22  5000 ????						;
     23  5000 ????						; Latest Revisions...
     24  5000 ????						; 1.05  13/NOV/2003	  - Correction to 1.04 - now functions as requested by MR.
     25  5000 ????						;			  - Added VERSION_VCS equate (which will reflect 100x version #)
     26  5000 ????						;			    This will allow conditional code to verify VCS.H being
     27  5000 ????						;			    used for code assembly.
     28  5000 ????						; 1.04  12/NOV/2003	 Added TIA_BASE_WRITE_ADDRESS and TIA_BASE_READ_ADDRESS for
     29  5000 ????						;			 convenient disassembly/reassembly compatibility for hardware
     30  5000 ????						;			 mirrored reading/writing differences.	This is more a 
     31  5000 ????						;			 readability issue, and binary compatibility with disassembled
     32  5000 ????						;			 and reassembled sources.  Per Manuel Rotschkar's suggestion.
     33  5000 ????						; 1.03  12/MAY/2003	 Added SEG segment at end of file to fix old-code compatibility
     34  5000 ????						;			 which was broken by the use of segments in this file, as
     35  5000 ????						;			 reported by Manuel Polik on [stella] 11/MAY/2003
     36  5000 ????						; 1.02  22/MAR/2003	 Added TIMINT($285)
     37  5000 ????						; 1.01				Constant offset added to allow use for 3F-style bankswitching
     38  5000 ????						;						 - define TIA_BASE_ADDRESS as $40 for Tigervision carts, otherwise
     39  5000 ????						;						   it is safe to leave it undefined, and the base address will
     40  5000 ????						;						   be set to 0.  Thanks to Eckhard Stolberg for the suggestion.
     41  5000 ????						;			    Note, may use -DLABEL=EXPRESSION to define TIA_BASE_ADDRESS
     42  5000 ????						;			  - register definitions are now generated through assignment
     43  5000 ????						;			    in uninitialised segments.	This allows a changeable base
     44  5000 ????						;			    address architecture.
     45  5000 ????						; 1.0	22/MAR/2003		Initial release
     46  5000 ????
     47  5000 ????
     48  5000 ????						;-------------------------------------------------------------------------------
     49  5000 ????
     50  5000 ????						; TIA_BASE_ADDRESS
     51  5000 ????						; The TIA_BASE_ADDRESS defines the base address of access to TIA registers.
     52  5000 ????						; Normally 0, the base address should (externally, before including this file)
     53  5000 ????						; be set to $40 when creating 3F-bankswitched (and other?) cartridges.
     54  5000 ????						; The reason is that this bankswitching scheme treats any access to locations
     55  5000 ????						; < $40 as a bankswitch.
     56  5000 ????
     57  5000 ????			  -	      IFNCONST	TIA_BASE_ADDRESS
     58  5000 ????			  -TIA_BASE_ADDRESS =	0
     59  5000 ????				      ENDIF
     60  5000 ????
     61  5000 ????						; Note: The address may be defined on the command-line using the -D switch, eg:
     62  5000 ????						; dasm.exe code.asm -DTIA_BASE_ADDRESS=$40 -f3 -v5 -ocode.bin
     63  5000 ????						; *OR* by declaring the label before including this file, eg:
     64  5000 ????						; TIA_BASE_ADDRESS = $40
     65  5000 ????						;   include "vcs.h"
     66  5000 ????
     67  5000 ????						; Alternate read/write address capability - allows for some disassembly compatibility
     68  5000 ????						; usage ; to allow reassembly to binary perfect copies).  This is essentially catering
     69  5000 ????						; for the mirrored ROM hardware registers.
     70  5000 ????
     71  5000 ????						; Usage: As per above, define the TIA_BASE_READ_ADDRESS and/or TIA_BASE_WRITE_ADDRESS
     72  5000 ????						; using the -D command-line switch, as required.  If the addresses are not defined, 
     73  5000 ????						; they defaut to the TIA_BASE_ADDRESS.
     74  5000 ????
     75  5000 ????			  -	      IFNCONST	TIA_BASE_READ_ADDRESS
     76  5000 ????			  -TIA_BASE_READ_ADDRESS =	TIA_BASE_ADDRESS
     77  5000 ????				      ENDIF
     78  5000 ????
     79  5000 ????			  -	      IFNCONST	TIA_BASE_WRITE_ADDRESS
     80  5000 ????			  -TIA_BASE_WRITE_ADDRESS =	TIA_BASE_ADDRESS
     81  5000 ????				      ENDIF
     82  5000 ????
     83  5000 ????						;-------------------------------------------------------------------------------
     84  5000 ????
     85 U002d					      SEG.U	TIA_REGISTERS_WRITE
     86 U0000					      ORG	TIA_BASE_WRITE_ADDRESS
     87 U0000
     88 U0000							; DO NOT CHANGE THE RELATIVE ORDERING OF REGISTERS!
     89 U0000
     90 U0000		       00	   VSYNC      ds	1	; $00	 0000 00x0   Vertical Sync Set-Clear
     91 U0001		       00	   VBLANK     ds	1	; $01	 xx00 00x0   Vertical Blank Set-Clear
     92 U0002		       00	   WSYNC      ds	1	; $02	 ---- ----   Wait for Horizontal Blank
     93 U0003		       00	   RSYNC      ds	1	; $03	 ---- ----   Reset Horizontal Sync Counter
     94 U0004		       00	   NUSIZ0     ds	1	; $04	 00xx 0xxx   Number-Size player/missle 0
     95 U0005		       00	   NUSIZ1     ds	1	; $05	 00xx 0xxx   Number-Size player/missle 1
     96 U0006		       00	   COLUP0     ds	1	; $06	 xxxx xxx0   Color-Luminance Player 0
     97 U0007		       00	   COLUP1     ds	1	; $07	 xxxx xxx0   Color-Luminance Player 1
     98 U0008		       00	   COLUPF     ds	1	; $08	 xxxx xxx0   Color-Luminance Playfield
     99 U0009		       00	   COLUBK     ds	1	; $09	 xxxx xxx0   Color-Luminance Background
    100 U000a		       00	   CTRLPF     ds	1	; $0A	 00xx 0xxx   Control Playfield, Ball, Collisions
    101 U000b		       00	   REFP0      ds	1	; $0B	 0000 x000   Reflection Player 0
    102 U000c		       00	   REFP1      ds	1	; $0C	 0000 x000   Reflection Player 1
    103 U000d		       00	   PF0	      ds	1	; $0D	 xxxx 0000   Playfield Register Byte 0
    104 U000e		       00	   PF1	      ds	1	; $0E	 xxxx xxxx   Playfield Register Byte 1
    105 U000f		       00	   PF2	      ds	1	; $0F	 xxxx xxxx   Playfield Register Byte 2
    106 U0010		       00	   RESP0      ds	1	; $10	 ---- ----   Reset Player 0
    107 U0011		       00	   RESP1      ds	1	; $11	 ---- ----   Reset Player 1
    108 U0012		       00	   RESM0      ds	1	; $12	 ---- ----   Reset Missle 0
    109 U0013		       00	   RESM1      ds	1	; $13	 ---- ----   Reset Missle 1
    110 U0014		       00	   RESBL      ds	1	; $14	 ---- ----   Reset Ball
    111 U0015		       00	   AUDC0      ds	1	; $15	 0000 xxxx   Audio Control 0
    112 U0016		       00	   AUDC1      ds	1	; $16	 0000 xxxx   Audio Control 1
    113 U0017		       00	   AUDF0      ds	1	; $17	 000x xxxx   Audio Frequency 0
    114 U0018		       00	   AUDF1      ds	1	; $18	 000x xxxx   Audio Frequency 1
    115 U0019		       00	   AUDV0      ds	1	; $19	 0000 xxxx   Audio Volume 0
    116 U001a		       00	   AUDV1      ds	1	; $1A	 0000 xxxx   Audio Volume 1
    117 U001b		       00	   GRP0       ds	1	; $1B	 xxxx xxxx   Graphics Register Player 0
    118 U001c		       00	   GRP1       ds	1	; $1C	 xxxx xxxx   Graphics Register Player 1
    119 U001d		       00	   ENAM0      ds	1	; $1D	 0000 00x0   Graphics Enable Missle 0
    120 U001e		       00	   ENAM1      ds	1	; $1E	 0000 00x0   Graphics Enable Missle 1
    121 U001f		       00	   ENABL      ds	1	; $1F	 0000 00x0   Graphics Enable Ball
    122 U0020		       00	   HMP0       ds	1	; $20	 xxxx 0000   Horizontal Motion Player 0
    123 U0021		       00	   HMP1       ds	1	; $21	 xxxx 0000   Horizontal Motion Player 1
    124 U0022		       00	   HMM0       ds	1	; $22	 xxxx 0000   Horizontal Motion Missle 0
    125 U0023		       00	   HMM1       ds	1	; $23	 xxxx 0000   Horizontal Motion Missle 1
    126 U0024		       00	   HMBL       ds	1	; $24	 xxxx 0000   Horizontal Motion Ball
    127 U0025		       00	   VDELP0     ds	1	; $25	 0000 000x   Vertical Delay Player 0
    128 U0026		       00	   VDELP1     ds	1	; $26	 0000 000x   Vertical Delay Player 1
    129 U0027		       00	   VDELBL     ds	1	; $27	 0000 000x   Vertical Delay Ball
    130 U0028		       00	   RESMP0     ds	1	; $28	 0000 00x0   Reset Missle 0 to Player 0
    131 U0029		       00	   RESMP1     ds	1	; $29	 0000 00x0   Reset Missle 1 to Player 1
    132 U002a		       00	   HMOVE      ds	1	; $2A	 ---- ----   Apply Horizontal Motion
    133 U002b		       00	   HMCLR      ds	1	; $2B	 ---- ----   Clear Horizontal Move Registers
    134 U002c		       00	   CXCLR      ds	1	; $2C	 ---- ----   Clear Collision Latches
    135 U002d
    136 U002d							;-------------------------------------------------------------------------------
    137 U002d
    138 U000e					      SEG.U	TIA_REGISTERS_READ
    139 U0000					      ORG	TIA_BASE_READ_ADDRESS
    140 U0000
    141 U0000							;											bit 7	 bit 6
    142 U0000		       00	   CXM0P      ds	1	; $00	     xx00 0000	     Read Collision  M0-P1   M0-P0
    143 U0001		       00	   CXM1P      ds	1	; $01	     xx00 0000			     M1-P0   M1-P1
    144 U0002		       00	   CXP0FB     ds	1	; $02	     xx00 0000			     P0-PF   P0-BL
    145 U0003		       00	   CXP1FB     ds	1	; $03	     xx00 0000			     P1-PF   P1-BL
    146 U0004		       00	   CXM0FB     ds	1	; $04	     xx00 0000			     M0-PF   M0-BL
    147 U0005		       00	   CXM1FB     ds	1	; $05	     xx00 0000			     M1-PF   M1-BL
    148 U0006		       00	   CXBLPF     ds	1	; $06	     x000 0000			     BL-PF   -----
    149 U0007		       00	   CXPPMM     ds	1	; $07	     xx00 0000			     P0-P1   M0-M1
    150 U0008		       00	   INPT0      ds	1	; $08	     x000 0000	     Read Pot Port 0
    151 U0009		       00	   INPT1      ds	1	; $09	     x000 0000	     Read Pot Port 1
    152 U000a		       00	   INPT2      ds	1	; $0A	     x000 0000	     Read Pot Port 2
    153 U000b		       00	   INPT3      ds	1	; $0B	     x000 0000	     Read Pot Port 3
    154 U000c		       00	   INPT4      ds	1	; $0C		x000 0000	 Read Input (Trigger) 0
    155 U000d		       00	   INPT5      ds	1	; $0D		x000 0000	 Read Input (Trigger) 1
    156 U000e
    157 U000e							;-------------------------------------------------------------------------------
    158 U000e
    159 U0298					      SEG.U	RIOT
    160 U0280					      ORG	$280
    161 U0280
    162 U0280							; RIOT MEMORY MAP
    163 U0280
    164 U0280		       00	   SWCHA      ds	1	; $280      Port A data register for joysticks:
    165 U0281							;			Bits 4-7 for player 1.  Bits 0-3 for player 2.
    166 U0281
    167 U0281		       00	   SWACNT     ds	1	; $281      Port A data direction register (DDR)
    168 U0282		       00	   SWCHB      ds	1	; $282		Port B data (console switches)
    169 U0283		       00	   SWBCNT     ds	1	; $283      Port B DDR
    170 U0284		       00	   INTIM      ds	1	; $284		Timer output
    171 U0285
    172 U0285		       00	   TIMINT     ds	1	; $285
    173 U0286
    174 U0286							; Unused/undefined registers ($285-$294)
    175 U0286
    176 U0286		       00		      ds	1	; $286
    177 U0287		       00		      ds	1	; $287
    178 U0288		       00		      ds	1	; $288
    179 U0289		       00		      ds	1	; $289
    180 U028a		       00		      ds	1	; $28A
    181 U028b		       00		      ds	1	; $28B
    182 U028c		       00		      ds	1	; $28C
    183 U028d		       00		      ds	1	; $28D
    184 U028e		       00		      ds	1	; $28E
    185 U028f		       00		      ds	1	; $28F
    186 U0290		       00		      ds	1	; $290
    187 U0291		       00		      ds	1	; $291
    188 U0292		       00		      ds	1	; $292
    189 U0293		       00		      ds	1	; $293
    190 U0294
    191 U0294		       00	   TIM1T      ds	1	; $294		set 1 clock interval
    192 U0295		       00	   TIM8T      ds	1	; $295      set 8 clock interval
    193 U0296		       00	   TIM64T     ds	1	; $296      set 64 clock interval
    194 U0297		       00	   T1024T     ds	1	; $297      set 1024 clock interval
    195 U0298
    196 U0298							;-------------------------------------------------------------------------------
    197 U0298							; The following required for back-compatibility with code which does not use
    198 U0298							; segments.
    199 U0298
    200  5000 ????				      SEG
    201  5000 ????
    202  5000 ????						; EOF
------- FILE 2600basic.h
------- FILE macro.h LEVEL 3 PASS 2
      0  5000 ????				      include	"macro.h"
      1  5000 ????						; Provided under the CC0 license. See the included LICENSE.txt for details.
      2  5000 ????
      3  5000 ????						; MACRO.H
      4  5000 ????						; Version 1.05, 13/NOVEMBER/2003
      5  5000 ????
      6  5000 ????	       00 69	   VERSION_MACRO =	105
      7  5000 ????
      8  5000 ????						;
      9  5000 ????						; THIS FILE IS EXPLICITLY SUPPORTED AS A DASM-PREFERRED COMPANION FILE
     10  5000 ????						; PLEASE DO *NOT* REDISTRIBUTE MODIFIED VERSIONS OF THIS FILE!
     11  5000 ????						;
     12  5000 ????						; This file defines DASM macros useful for development for the Atari 2600.
     13  5000 ????						; It is distributed as a companion machine-specific support package
     14  5000 ????						; for the DASM compiler. Updates to this file, DASM, and associated tools are
     15  5000 ????						; available at at http://www.atari2600.org/dasm
     16  5000 ????						;
     17  5000 ????						; Many thanks to the people who have contributed.  If you take issue with the
     18  5000 ????						; contents, or would like to add something, please write to me
     19  5000 ????						; (atari2600@taswegian.com) with your contribution.
     20  5000 ????						;
     21  5000 ????						; Latest Revisions...
     22  5000 ????						;
     23  5000 ????						; 1.05  14/NOV/2003	  - Added VERSION_MACRO equate (which will reflect 100x version #)
     24  5000 ????						;			    This will allow conditional code to verify MACRO.H being
     25  5000 ????						;			    used for code assembly.
     26  5000 ????						; 1.04  13/NOV/2003	 - SET_POINTER macro added (16-bit address load)
     27  5000 ????						;
     28  5000 ????						; 1.03  23/JUN/2003	 - CLEAN_START macro added - clears TIA, RAM, registers
     29  5000 ????						;
     30  5000 ????						; 1.02  14/JUN/2003	 - VERTICAL_SYNC macro added
     31  5000 ????						;			   (standardised macro for vertical synch code)
     32  5000 ????						; 1.01  22/MAR/2003	 - SLEEP macro added. 
     33  5000 ????						;			 - NO_ILLEGAL_OPCODES switch implemented
     34  5000 ????						; 1.0	22/MAR/2003		Initial release
     35  5000 ????
     36  5000 ????						; Note: These macros use illegal opcodes.  To disable illegal opcode usage, 
     37  5000 ????						;   define the symbol NO_ILLEGAL_OPCODES (-DNO_ILLEGAL_OPCODES=1 on command-line).
     38  5000 ????						;   If you do not allow illegal opcode usage, you must include this file 
     39  5000 ????						;   *after* including VCS.H (as the non-illegal opcodes access hardware
     40  5000 ????						;   registers and require them to be defined first).
     41  5000 ????
     42  5000 ????						; Available macros...
     43  5000 ????						;   SLEEP n		 - sleep for n cycles
     44  5000 ????						;   VERTICAL_SYNC	 - correct 3 scanline vertical synch code
     45  5000 ????						;   CLEAN_START	 - set machine to known state on startup
     46  5000 ????						;   SET_POINTER	 - load a 16-bit absolute to a 16-bit variable
     47  5000 ????
     48  5000 ????						;-------------------------------------------------------------------------------
     49  5000 ????						; SLEEP duration
     50  5000 ????						; Original author: Thomas Jentzsch
     51  5000 ????						; Inserts code which takes the specified number of cycles to execute.	This is
     52  5000 ????						; useful for code where precise timing is required.
     53  5000 ????						; ILLEGAL-OPCODE VERSION DOES NOT AFFECT FLAGS OR REGISTERS.
     54  5000 ????						; LEGAL OPCODE VERSION MAY AFFECT FLAGS
     55  5000 ????						; Uses illegal opcode (DASM 2.20.01 onwards).
     56  5000 ????
     57  5000 ????				      MAC	sleep
     58  5000 ????			   .CYCLES    SET	{1}
     59  5000 ????
     60  5000 ????				      IF	.CYCLES < 2
     61  5000 ????				      ECHO	"MACRO ERROR: 'SLEEP': Duration must be > 1"
     62  5000 ????				      ERR
     63  5000 ????				      ENDIF
     64  5000 ????
     65  5000 ????				      IF	.CYCLES & 1
     66  5000 ????				      IFNCONST	NO_ILLEGAL_OPCODES
     67  5000 ????				      nop	0
     68  5000 ????				      ELSE
     69  5000 ????				      bit	VSYNC
     70  5000 ????				      ENDIF
     71  5000 ????			   .CYCLES    SET	.CYCLES - 3
     72  5000 ????				      ENDIF
     73  5000 ????
     74  5000 ????				      REPEAT	.CYCLES / 2
     75  5000 ????				      nop
     76  5000 ????				      REPEND
     77  5000 ????				      ENDM		;usage: SLEEP n (n>1)
     78  5000 ????
     79  5000 ????						;-------------------------------------------------------------------------------
     80  5000 ????						; VERTICAL_SYNC
     81  5000 ????						; Original author: Manuel Polik
     82  5000 ????						; Inserts the code required for a proper 3 scannline 
     83  5000 ????						; vertical sync sequence
     84  5000 ????						;
     85  5000 ????						; Note: Alters the accumulator
     86  5000 ????						;
     87  5000 ????						; IN:
     88  5000 ????						; OUT: A = 1
     89  5000 ????
     90  5000 ????				      MAC	vertical_sync
     91  5000 ????				      LDA	#$02	; A = VSYNC enable
     92  5000 ????				      STA	WSYNC	; Finish current line
     93  5000 ????				      STA	VSYNC	; Start vertical sync
     94  5000 ????				      STA	WSYNC	; 1st line vertical sync
     95  5000 ????				      STA	WSYNC	; 2nd line vertical sync
     96  5000 ????				      LSR		; A = VSYNC disable
     97  5000 ????				      STA	WSYNC	; 3rd line vertical sync
     98  5000 ????				      STA	VSYNC	; Stop vertical sync
     99  5000 ????				      ENDM
    100  5000 ????
    101  5000 ????						;-------------------------------------------------------------------------------
    102  5000 ????						; CLEAN_START
    103  5000 ????						; Original author: Andrew Davie
    104  5000 ????						; Standardised start-up code, clears stack, all TIA registers and RAM to 0
    105  5000 ????						; Sets stack pointer to $FF, and all registers to 0
    106  5000 ????						; Sets decimal mode off, sets interrupt flag (kind of un-necessary)
    107  5000 ????						; Use as very first section of code on boot (ie: at reset)
    108  5000 ????						; Code written to minimise total ROM usage - uses weird 6502 knowledge :)
    109  5000 ????
    110  5000 ????				      MAC	clean_start
    111  5000 ????				      sei
    112  5000 ????				      cld
    113  5000 ????
    114  5000 ????				      ldx	#0
    115  5000 ????				      txa
    116  5000 ????				      tay
    117  5000 ????			   .CLEAR_STACK dex
    118  5000 ????				      txs
    119  5000 ????				      pha
    120  5000 ????				      bne	.CLEAR_STACK	; SP=$FF, X = A = Y = 0
    121  5000 ????
    122  5000 ????				      ENDM
    123  5000 ????
    124  5000 ????						;-------------------------------------------------------
    125  5000 ????						; SET_POINTER
    126  5000 ????						; Original author: Manuel Rotschkar
    127  5000 ????						;
    128  5000 ????						; Sets a 2 byte RAM pointer to an absolute address.
    129  5000 ????						;
    130  5000 ????						; Usage: SET_POINTER pointer, address
    131  5000 ????						; Example: SET_POINTER SpritePTR, SpriteData
    132  5000 ????						;
    133  5000 ????						; Note: Alters the accumulator, NZ flags
    134  5000 ????						; IN 1: 2 byte RAM location reserved for pointer
    135  5000 ????						; IN 2: absolute address
    136  5000 ????
    137  5000 ????				      MAC	set_pointer
    138  5000 ????			   .POINTER   SET	{1}
    139  5000 ????			   .ADDRESS   SET	{2}
    140  5000 ????
    141  5000 ????				      LDA	#<.ADDRESS	; Get Lowbyte of Address
    142  5000 ????				      STA	.POINTER	; Store in pointer
    143  5000 ????				      LDA	#>.ADDRESS	; Get Hibyte of Address
    144  5000 ????				      STA	.POINTER+1	; Store in pointer+1
    145  5000 ????
    146  5000 ????				      ENDM
    147  5000 ????
    148  5000 ????						; EOF
------- FILE 2600basic.h
------- FILE 2600basic_variable_redefs.h LEVEL 3 PASS 2
      0  5000 ????				      include	"2600basic_variable_redefs.h"
      1  5000 ????						; This file contains variable mapping and other information for the current project.
      2  5000 ????
      3  5000 ????	       00 20	   bscode_length =	32
      4  5000 ????	       00 eb	   _Ch0_Duration =	x
      5  5000 ????
      6  5000 ????	       00 ea	   _Ch0_Sound =	w
      7  5000 ????
      8  5000 ????	       00 e1	   _CurrentLevel =	n
      9  5000 ????
     10  5000 ????	       00 d5	   _pf_y      =	b
     11  5000 ????
     12  5000 ????	       00 d4	   _pf_x      =	a
     13  5000 ????
     14  5000 ????	       00 85	   _P1_y      =	player0y
     15  5000 ????
     16  5000 ????	       00 80	   _P1_x      =	player0x
     17  5000 ????
     18  5000 ????	       00 2e	   _P_COLOUR  =	$2E
     19  5000 ????
     20  5000 ????	       00 78	   _End_Level_Pause =	120
     21  5000 ????
     22  5000 ????	       00 19	   _P_Alien_X =	25
     23  5000 ????
     24  5000 ????	       00 0f	   _P_Alien_Y =	15
     25  5000 ????
     26  5000 ????	       00 32	   _P_Start_Y =	50
     27  5000 ????
     28  5000 ????	       00 4c	   _P_Start_X =	76
     29  5000 ????
     30  5000 ????	       00 22	   _numberOfDiamonds =	34
     31  5000 ????
     32  5000 ????	       00 08	   _P1_Width  =	8
     33  5000 ????
     34  5000 ????	       00 06	   _P1_Height =	6
     35  5000 ????
     36  5000 ????	       00 01	   pfscore    =	1
     37  5000 ????
     38  5000 ????	       00 9f	   _B_Edge_Right =	159
     39  5000 ????
     40  5000 ????	       00 02	   _B_Edge_Left =	2
     41  5000 ????
     42  5000 ????	       00 58	   _B_Edge_Bottom =	88
     43  5000 ????
     44  5000 ????	       00 03	   _B_Edge_Top =	3
     45  5000 ????
     46  5000 ????	       00 85	   _P_Edge_Right =	133
     47  5000 ????
     48  5000 ????	       00 15	   _P_Edge_Left =	21
     49  5000 ????
     50  5000 ????	       00 4d	   _P_Edge_Bottom =	77
     51  5000 ????
     52  5000 ????	       00 0e	   _P_Edge_Top =	14
     53  5000 ????
     54  5000 ????	       00 01	   font       =	.21stcentury
     55  5000 ????
     56  5000 ????	       00 ed	   rand16     =	z
     57  5000 ????
     58  5000 ????	       00 01	   PFcolors   =	1
     59  5000 ????	       00 01	   no_blank_lines =	1
     60  5000 ????	       00 03	   bs_mask    =	3
     61  5000 ????	       00 10	   bankswitch =	16
     62  5000 ????	       1f f6	   bankswitch_hotspot =	$1FF6
     63  5000 ????	       00 3a	   vblank_time =	58
     64  5000 ????	       00 52	   overscan_time =	82
------- FILE 2600basic.h
      7  5000 ????
      8  5000 ????	       00 80	   player0x   =	$80
      9  5000 ????	       00 81	   player1x   =	$81
     10  5000 ????	       00 82	   missile0x  =	$82
     11  5000 ????	       00 83	   missile1x  =	$83
     12  5000 ????	       00 84	   ballx      =	$84
     13  5000 ????
     14  5000 ????	       00 85	   objecty    =	$85
     15  5000 ????	       00 85	   player0y   =	$85
     16  5000 ????	       00 86	   player1y   =	$86
     17  5000 ????	       00 87	   missile1height =	$87
     18  5000 ????	       00 88	   missile1y  =	$88
     19  5000 ????	       00 89	   bally      =	$89
     20  5000 ????
     21  5000 ????	       00 87	   player1color =	$87	; replaces missile 1
     22  5000 ????
     23  5000 ????	       00 8a	   player0pointer =	$8A	;uses $8A-$8B
     24  5000 ????	       00 8a	   player0pointerlo =	$8A
     25  5000 ????	       00 8b	   player0pointerhi =	$8B
     26  5000 ????	       00 8c	   player1pointer =	$8C	; $8C-$8D
     27  5000 ????	       00 8c	   player1pointerlo =	$8C
     28  5000 ????	       00 8d	   player1pointerhi =	$8D
     29  5000 ????
     30  5000 ????	       00 8e	   player0height =	$8E
     31  5000 ????	       00 8f	   player1height =	$8F
     32  5000 ????	       00 90	   missile0height =	$90
     33  5000 ????	       00 91	   missile0y  =	$91
     34  5000 ????	       00 92	   ballheight =	$92
     35  5000 ????
     36  5000 ????	       00 90	   currentpaddle =	$90	; replaces missile 0 (and can't be used with playercolor)
     37  5000 ????	       00 91	   paddle     =	$91	; replaces missile 0
     38  5000 ????	       00 82	   player0colorstore =	$82	; replaces missile 0
     39  5000 ????	       00 90	   player0color =	$90	; replaces missile 0
     40  5000 ????
     41  5000 ????	       00 93	   score      =	$93	; $93-$95
     42  5000 ????	       00 96	   scorepointers =	$96	; $96-$9B = 6 bytes
     43  5000 ????	       00 9c	   temp1      =	$9C	;used by kernel.  can be used in program too, but
     44  5000 ????	       00 9d	   temp2      =	$9D	;are obliterated when drawscreen is called.
     45  5000 ????	       00 9e	   temp3      =	$9E
     46  5000 ????	       00 9f	   temp4      =	$9F
     47  5000 ????	       00 a0	   temp5      =	$A0
     48  5000 ????	       00 a1	   temp6      =	$A1
     49  5000 ????
     50  5000 ????	       00 a2	   rand       =	$A2
     51  5000 ????	       00 a3	   scorecolor =	$A3
     52  5000 ????
     53  5000 ????	       00 a4	   var0       =	$A4
     54  5000 ????	       00 a5	   var1       =	$A5
     55  5000 ????	       00 a6	   var2       =	$A6
     56  5000 ????	       00 a7	   var3       =	$A7
     57  5000 ????	       00 a8	   var4       =	$A8
     58  5000 ????	       00 a9	   var5       =	$A9
     59  5000 ????	       00 aa	   var6       =	$AA
     60  5000 ????	       00 ab	   var7       =	$AB
     61  5000 ????	       00 ac	   var8       =	$AC
     62  5000 ????	       00 ad	   var9       =	$AD
     63  5000 ????	       00 ae	   var10      =	$AE
     64  5000 ????	       00 af	   var11      =	$AF
     65  5000 ????	       00 b0	   var12      =	$B0
     66  5000 ????	       00 b1	   var13      =	$B1
     67  5000 ????	       00 b2	   var14      =	$B2
     68  5000 ????	       00 b3	   var15      =	$B3
     69  5000 ????	       00 b4	   var16      =	$B4
     70  5000 ????	       00 b5	   var17      =	$B5
     71  5000 ????	       00 b6	   var18      =	$B6
     72  5000 ????	       00 b7	   var19      =	$B7
     73  5000 ????	       00 b8	   var20      =	$B8
     74  5000 ????	       00 b9	   var21      =	$B9
     75  5000 ????	       00 ba	   var22      =	$BA
     76  5000 ????	       00 bb	   var23      =	$BB
     77  5000 ????	       00 bc	   var24      =	$BC
     78  5000 ????	       00 bd	   var25      =	$BD
     79  5000 ????	       00 be	   var26      =	$BE
     80  5000 ????	       00 bf	   var27      =	$BF
     81  5000 ????	       00 c0	   var28      =	$C0
     82  5000 ????	       00 c1	   var29      =	$C1
     83  5000 ????	       00 c2	   var30      =	$C2
     84  5000 ????	       00 c3	   var31      =	$C3
     85  5000 ????	       00 c4	   var32      =	$C4
     86  5000 ????	       00 c5	   var33      =	$C5
     87  5000 ????	       00 c6	   var34      =	$C6
     88  5000 ????	       00 c7	   var35      =	$C7
     89  5000 ????	       00 c8	   var36      =	$C8
     90  5000 ????	       00 c9	   var37      =	$C9
     91  5000 ????	       00 ca	   var38      =	$CA
     92  5000 ????	       00 cb	   var39      =	$CB
     93  5000 ????	       00 cc	   var40      =	$CC
     94  5000 ????	       00 cd	   var41      =	$CD
     95  5000 ????	       00 ce	   var42      =	$CE
     96  5000 ????	       00 cf	   var43      =	$CF
     97  5000 ????	       00 d0	   var44      =	$D0
     98  5000 ????	       00 d1	   var45      =	$D1
     99  5000 ????	       00 d2	   var46      =	$D2
    100  5000 ????	       00 d3	   var47      =	$D3
    101  5000 ????
    102  5000 ????	       00 d4	   A	      =	$d4
    103  5000 ????	       00 d4	   a	      =	$d4
    104  5000 ????	       00 d5	   B	      =	$d5
    105  5000 ????	       00 d5	   b	      =	$d5
    106  5000 ????	       00 d6	   C	      =	$d6
    107  5000 ????	       00 d6	   c	      =	$d6
    108  5000 ????	       00 d7	   D	      =	$d7
    109  5000 ????	       00 d7	   d	      =	$d7
    110  5000 ????	       00 d8	   E	      =	$d8
    111  5000 ????	       00 d8	   e	      =	$d8
    112  5000 ????	       00 d9	   F	      =	$d9
    113  5000 ????	       00 d9	   f	      =	$d9
    114  5000 ????	       00 da	   G	      =	$da
    115  5000 ????	       00 da	   g	      =	$da
    116  5000 ????	       00 db	   H	      =	$db
    117  5000 ????	       00 db	   h	      =	$db
    118  5000 ????	       00 dc	   I	      =	$dc
    119  5000 ????	       00 dc	   i	      =	$dc
    120  5000 ????	       00 dd	   J	      =	$dd
    121  5000 ????	       00 dd	   j	      =	$dd
    122  5000 ????	       00 de	   K	      =	$de
    123  5000 ????	       00 de	   k	      =	$de
    124  5000 ????	       00 df	   L	      =	$df
    125  5000 ????	       00 df	   l	      =	$df
    126  5000 ????	       00 e0	   M	      =	$e0
    127  5000 ????	       00 e0	   m	      =	$e0
    128  5000 ????	       00 e1	   N	      =	$e1
    129  5000 ????	       00 e1	   n	      =	$e1
    130  5000 ????	       00 e2	   O	      =	$e2
    131  5000 ????	       00 e2	   o	      =	$e2
    132  5000 ????	       00 e3	   P	      =	$e3
    133  5000 ????	       00 e3	   p	      =	$e3
    134  5000 ????	       00 e4	   Q	      =	$e4
    135  5000 ????	       00 e4	   q	      =	$e4
    136  5000 ????	       00 e5	   R	      =	$e5
    137  5000 ????	       00 e5	   r	      =	$e5
    138  5000 ????	       00 e6	   S	      =	$e6
    139  5000 ????	       00 e6	   s	      =	$e6
    140  5000 ????	       00 e7	   T	      =	$e7
    141  5000 ????	       00 e7	   t	      =	$e7
    142  5000 ????	       00 e8	   U	      =	$e8
    143  5000 ????	       00 e8	   u	      =	$e8
    144  5000 ????	       00 e9	   V	      =	$e9
    145  5000 ????	       00 e9	   v	      =	$e9
    146  5000 ????	       00 ea	   W	      =	$ea
    147  5000 ????	       00 ea	   w	      =	$ea
    148  5000 ????	       00 eb	   X	      =	$eb
    149  5000 ????	       00 eb	   x	      =	$eb
    150  5000 ????	       00 ec	   Y	      =	$ec
    151  5000 ????	       00 ec	   y	      =	$ec
    152  5000 ????	       00 ed	   Z	      =	$ed
    153  5000 ????	       00 ed	   z	      =	$ed
    154  5000 ????
    155  5000 ????	       00 ee	   temp7      =	$ee	; This is used to aid in bankswitching
    156  5000 ????	       00 ef	   playfieldpos =	$ef
    157  5000 ????
    158  5000 ????						; available for other uses, or if unused, provide more stack space
    159  5000 ????
    160  5000 ????	       00 f0	   aux1       =	$f0
    161  5000 ????	       00 f1	   aux2       =	$f1
    162  5000 ????	       00 f2	   aux3       =	$f2
    163  5000 ????	       00 f3	   aux4       =	$f3
    164  5000 ????	       00 f4	   aux5       =	$f4
    165  5000 ????	       00 f5	   aux6       =	$f5
    166  5000 ????
    167  5000 ????						; playfield color/height pointers
    168  5000 ????	       00 f0	   pfcolortable =	$f0	; and $d5
    169  5000 ????	       00 f0	   pfheighttable =	$f0	; and $d5
    170  5000 ????						; the above pointers are the same because if color and height are both used together,
    171  5000 ????						; they must used absolute indexed and cannot use pointers
    172  5000 ????
    173  5000 ????	       00 f2	   lifepointer =	$f2	; pointer to "lives" shape
    174  5000 ????						; upper 3 bits of $f2 contain the number of lives
    175  5000 ????	       00 f4	   lifecolor  =	$f4
    176  5000 ????	       00 f3	   lives      =	$f3	; # lives >> 5
    177  5000 ????	       00 f5	   statusbarlength =	$f5	; only uses upper 5 bits; other bits free
    178  5000 ????
    179  5000 ????	       00 f2	   pfscore1   =	$f2	; optional playfield bytes in score
    180  5000 ????	       00 f3	   pfscore2   =	$f3
    181  5000 ????	       00 f4	   pfscorecolor =	$f4
    182  5000 ????
    183  5000 ????	       00 f6	   stack1     =	$f6
    184  5000 ????	       00 f7	   stack2     =	$f7
    185  5000 ????	       00 f8	   stack3     =	$f8
    186  5000 ????	       00 f9	   stack4     =	$f9
    187  5000 ????						; the stack bytes above may be used in the kernel
    188  5000 ????						; stack = F6-F7, F8-F9, FA-FB, FC-FD, FE-FF
    189  5000 ????
    190  5000 ????				      MAC	return
    191  5000 ????				      ifnconst	bankswitch
    192  5000 ????				      rts
    193  5000 ????				      else
    194  5000 ????				      jmp	BS_return
    195  5000 ????				      endif
    196  5000 ????				      ENDM		; auto-return from either a regular or bankswitched module
    197  5000 ????
    198  5000 ????			  -	      ifconst	superchip
    199  5000 ????			  -playfieldbase =	$10D0
    200  5000 ????			  -	      include	superchip.h
    201  5000 ????				      else
    202  5000 ????	       00 a4	   playfieldbase =	$A4
    203  5000 ????				      endif
    204  5000 ????
    205  5000 ????				      ifnconst	pfhalfwidth
    206  5000 ????	       00 04	   pfwidth    =	4
    207  5000 ????	       00 0e	   PF1L       =	PF1
    208  5000 ????	       00 0f	   PF2L       =	PF2
    209  5000 ????	       00 0e	   PF1R       =	PF1
    210  5000 ????	       00 0f	   PF2R       =	PF2
    211  5000 ????	       00 00	   pfadjust   =	0
    212  5000 ????			  -	      else
    213  5000 ????			  -pfwidth    =	2
    214  5000 ????			  -	      ifconst	pfcenter
    215  5000 ????			  -PF1L       =	$3F	; no effect
    216  5000 ????			  -PF2L       =	PF2
    217  5000 ????			  -PF1R       =	$3F
    218  5000 ????			  -PF2R       =	PF2	; no effect
    219  5000 ????			  -pfadjust   =	1
    220  5000 ????			  -	      else
    221  5000 ????			  -PF1L       =	PF1
    222  5000 ????			  -PF2L       =	PF2
    223  5000 ????			  -PF1R       =	$3F	; no effect
    224  5000 ????			  -PF2R       =	$3F	; no effect
    225  5000 ????			  -pfadjust   =	0
    226  5000 ????			  -	      endif
    227  5000 ????				      endif
    228  5000 ????
    229  5000 ????						; define playfield start based on height
    230  5000 ????				      ifnconst	pfres
    231  5000 ????	       00 a4	   playfield  =	playfieldbase
    232  5000 ????			  -	      else
    233  5000 ????			  -playfield  =	playfieldbase-(pfres-12*(4/pfwidth))*pfwidth
    234  5000 ????				      endif
------- FILE /Users/jblanchard/Documents/Code/Retro/Atari2600/Jurl/Jurl.bas.asm
------- FILE 2600basic_variable_redefs.h LEVEL 2 PASS 2
      0  5000 ????				      include	"2600basic_variable_redefs.h"
      1  5000 ????						; This file contains variable mapping and other information for the current project.
      2  5000 ????
      3  5000 ????	       00 20	   bscode_length =	32
      4  5000 ????	       00 eb	   _Ch0_Duration =	x
      5  5000 ????
      6  5000 ????	       00 ea	   _Ch0_Sound =	w
      7  5000 ????
      8  5000 ????	       00 e1	   _CurrentLevel =	n
      9  5000 ????
     10  5000 ????	       00 d5	   _pf_y      =	b
     11  5000 ????
     12  5000 ????	       00 d4	   _pf_x      =	a
     13  5000 ????
     14  5000 ????	       00 85	   _P1_y      =	player0y
     15  5000 ????
     16  5000 ????	       00 80	   _P1_x      =	player0x
     17  5000 ????
     18  5000 ????	       00 2e	   _P_COLOUR  =	$2E
     19  5000 ????
     20  5000 ????	       00 78	   _End_Level_Pause =	120
     21  5000 ????
     22  5000 ????	       00 19	   _P_Alien_X =	25
     23  5000 ????
     24  5000 ????	       00 0f	   _P_Alien_Y =	15
     25  5000 ????
     26  5000 ????	       00 32	   _P_Start_Y =	50
     27  5000 ????
     28  5000 ????	       00 4c	   _P_Start_X =	76
     29  5000 ????
     30  5000 ????	       00 22	   _numberOfDiamonds =	34
     31  5000 ????
     32  5000 ????	       00 08	   _P1_Width  =	8
     33  5000 ????
     34  5000 ????	       00 06	   _P1_Height =	6
     35  5000 ????
     36  5000 ????	       00 01	   pfscore    =	1
     37  5000 ????
     38  5000 ????	       00 9f	   _B_Edge_Right =	159
     39  5000 ????
     40  5000 ????	       00 02	   _B_Edge_Left =	2
     41  5000 ????
     42  5000 ????	       00 58	   _B_Edge_Bottom =	88
     43  5000 ????
     44  5000 ????	       00 03	   _B_Edge_Top =	3
     45  5000 ????
     46  5000 ????	       00 85	   _P_Edge_Right =	133
     47  5000 ????
     48  5000 ????	       00 15	   _P_Edge_Left =	21
     49  5000 ????
     50  5000 ????	       00 4d	   _P_Edge_Bottom =	77
     51  5000 ????
     52  5000 ????	       00 0e	   _P_Edge_Top =	14
     53  5000 ????
     54  5000 ????	       00 01	   font       =	.21stcentury
     55  5000 ????
     56  5000 ????	       00 ed	   rand16     =	z
     57  5000 ????
     58  5000 ????	       00 01	   PFcolors   =	1
     59  5000 ????	       00 01	   no_blank_lines =	1
     60  5000 ????	       00 03	   bs_mask    =	3
     61  5000 ????	       00 10	   bankswitch =	16
     62  5000 ????	       1f f6	   bankswitch_hotspot =	$1FF6
     63  5000 ????	       00 3a	   vblank_time =	58
     64  5000 ????	       00 52	   overscan_time =	82
------- FILE /Users/jblanchard/Documents/Code/Retro/Atari2600/Jurl/Jurl.bas.asm
      8  5000 ????				      ifconst	bankswitch
      9  5000 ????			  -	      if	bankswitch == 8
     10  5000 ????			  -	      ORG	$1000
     11  5000 ????			  -	      RORG	$D000
     12  5000 ????				      endif
     13  5000 ????				      if	bankswitch == 16
     14  1000					      ORG	$1000
     15  1000					      RORG	$9000
     16  1000					      endif
     17  1000				  -	      if	bankswitch == 32
     18  1000				  -	      ORG	$1000
     19  1000				  -	      RORG	$1000
     20  1000					      endif
     21  1000				  -	      if	bankswitch == 64
     22  1000				  -	      ORG	$1000
     23  1000				  -	      RORG	$1000
     24  1000					      endif
     25  1000				  -	      else
     26  1000				  -	      ORG	$F000
     27  1000					      endif
     28  1000
     29  1000					      ifconst	bankswitch_hotspot
     30  1000				  -	      if	bankswitch_hotspot = $083F	; 0840 bankswitching hotspot
     31  1000				  -	      .byte	0	; stop unexpected bankswitches
     32  1000					      endif
     33  1000					      endif
     34  1000							; Provided under the CC0 license. See the included LICENSE.txt for details.
     35  1000
     36  1000							; y and a contain multiplicands, result in a
     37  1000
     38  1000				   mul8
     39  1000		       84 9c		      sty	temp1
     40  1002		       85 9d		      sta	temp2
     41  1004		       a9 00		      lda	#0
     42  1006				   reptmul8
     43  1006		       46 9d		      lsr	temp2
     44  1008		       90 03		      bcc	skipmul8
     45  100a		       18		      clc
     46  100b		       65 9c		      adc	temp1
     47  100d							;bcs donemul8 might save cycles?
     48  100d				   skipmul8
     49  100d							;beq donemul8 might save cycles?
     50  100d		       06 9c		      asl	temp1
     51  100f		       d0 f5		      bne	reptmul8
     52  1011				   donemul8
      0  1011					      RETURN
      1  1011				  -	      ifnconst	bankswitch
      2  1011				  -	      rts
      3  1011					      else
      4  1011		       4c dd ff 	      jmp	BS_return
      5  1014					      endif
     54  1014
     55  1014				   div8
     56  1014							; a=numerator y=denominator, result in a
     57  1014		       c0 02		      cpy	#2
     58  1016		       90 0a		      bcc	div8end+1	;div by 0 = bad, div by 1=no calc needed, so bail out
     59  1018		       84 9c		      sty	temp1
     60  101a		       a0 ff		      ldy	#$ff
     61  101c				   div8loop
     62  101c		       e5 9c		      sbc	temp1
     63  101e		       c8		      iny
     64  101f		       b0 fb		      bcs	div8loop
     65  1021				   div8end
     66  1021		       98		      tya
     67  1022							; result in a
      0  1022					      RETURN
      1  1022				  -	      ifnconst	bankswitch
      2  1022				  -	      rts
      3  1022					      else
      4  1022		       4c dd ff 	      jmp	BS_return
      5  1025					      endif
     69  1025
     70  1025							; Provided under the CC0 license. See the included LICENSE.txt for details.
     71  1025
     72  1025							; Compute mul1*mul2+acc -> acc:mul1 [mul2 is unchanged]
     73  1025							; Routine courtesy of John Payson (AtariAge member supercat)
     74  1025
     75  1025							; x and a contain multiplicands, result in a, temp1 contains any overflow
     76  1025
     77  1025				   mul16
     78  1025		       84 9c		      sty	temp1
     79  1027		       85 9d		      sta	temp2
     80  1029		       a2 08		      ldx	#8
     81  102b		       c6 9d		      dec	temp2
     82  102d				   loopmul
     83  102d		       4a		      lsr
     84  102e		       66 9c		      ror	temp1
     85  1030		       90 02		      bcc	noaddmul
     86  1032		       65 9d		      adc	temp2
     87  1034				   noaddmul
     88  1034		       ca		      dex
     89  1035		       d0 f6		      bne	loopmul
      0  1037					      RETURN
      1  1037				  -	      ifnconst	bankswitch
      2  1037				  -	      rts
      3  1037					      else
      4  1037		       4c dd ff 	      jmp	BS_return
      5  103a					      endif
     91  103a
     92  103a							; div int/int
     93  103a							; numerator in A, denom in temp1
     94  103a							; returns with quotient in A, remainder in temp1
     95  103a
     96  103a				   div16
     97  103a		       85 9d		      sta	temp2
     98  103c		       84 9c		      sty	temp1
     99  103e		       a9 00		      lda	#0
    100  1040		       a2 08		      ldx	#8
    101  1042		       06 9d		      asl	temp2
    102  1044				   div16_1
    103  1044		       2a		      rol
    104  1045		       c5 9c		      cmp	temp1
    105  1047		       90 02		      bcc	div16_2
    106  1049		       e5 9c		      sbc	temp1
    107  104b				   div16_2
    108  104b		       26 9d		      rol	temp2
    109  104d		       ca		      dex
    110  104e		       d0 f4		      bne	div16_1
    111  1050		       85 9c		      sta	temp1
    112  1052		       a5 9d		      lda	temp2
      0  1054					      RETURN
      1  1054				  -	      ifnconst	bankswitch
      2  1054				  -	      rts
      3  1054					      else
      4  1054		       4c dd ff 	      jmp	BS_return
      5  1057					      endif
    114  1057
    115  1057				   game
    116  1057				   .L00 		;  rem ----------------------------------------------------------------------------
    117  1057
    118  1057				   .L01 		;  rem - JURL (2600)								   -
    119  1057
    120  1057				   .L02 		;  rem - 2020 Tonsomo Entertainment						   -
    121  1057
    122  1057				   .L03 		;  rem ----------------------------------------------------------------------------
    123  1057
    124  1057				   .L04 		;  rem - Development History							   -
    125  1057
    126  1057				   .L05 		;  rem - V0.1	   Johnny Blanchard	 Initial Development	 2020-04-10	   -	  
    127  1057
    128  1057				   .L06 		;  rem ----------------------------------------------------------------------------
    129  1057
    130  1057				   .
    131  1057							;
    132  1057
    133  1057				   .L07 		;  include div_mul.asm
    134  1057
    135  1057				   .L08 		;  include div_mul16.asm
    136  1057
    137  1057				   .
    138  1057							;
    139  1057
    140  1057				   .L09 		;  set tv pal
    141  1057
    142  1057				   .L010		;  set romsize 16k
    143  1057
    144  1057				   .
    145  1057							;
    146  1057
    147  1057				   .L011		;  set kernel_options no_blank_lines pfcolors collision(player0,playfield)
    148  1057
    149  1057				   .L012		;  set optimization speed
    150  1057
    151  1057				   .L013		;  set optimization inlinerand
    152  1057
    153  1057				   .L014		;  set smartbranching on
    154  1057
    155  1057				   .
    156  1057							;
    157  1057
    158  1057				   .L015		;  dim rand16	=  z
    159  1057
    160  1057				   .
    161  1057							;
    162  1057
    163  1057				   .L016		;  a  =  0  :	b  =  0  :  c  =  0  :	d  =  0  :  e  =  0  :	f  =  0  :  g  =  0  :	h  =  0  :  i  =  0
    164  1057
    165  1057		       a9 00		      LDA	#0
    166  1059		       85 d4		      STA	a
    167  105b		       85 d5		      STA	b
    168  105d		       85 d6		      STA	c
    169  105f		       85 d7		      STA	d
    170  1061		       85 d8		      STA	e
    171  1063		       85 d9		      STA	f
    172  1065		       85 da		      STA	g
    173  1067		       85 db		      STA	h
    174  1069		       85 dc		      STA	i
    175  106b				   .L017		;  j  =  0  :	k  =  0  :  l  =  0  :	m  =  0  :  n  =  0  :	o  =  0  :  p  =  0  :	q  =  0  :  r  =  0
    176  106b
    177  106b		       a9 00		      LDA	#0
    178  106d		       85 dd		      STA	j
    179  106f		       85 de		      STA	k
    180  1071		       85 df		      STA	l
    181  1073		       85 e0		      STA	m
    182  1075		       85 e1		      STA	n
    183  1077		       85 e2		      STA	o
    184  1079		       85 e3		      STA	p
    185  107b		       85 e4		      STA	q
    186  107d		       85 e5		      STA	r
    187  107f				   .L018		;  s  =  0  :	t  =  0  :  u  =  0  :	v  =  0  :  w  =  0  :	x  =  0  :  y  =  0
    188  107f
    189  107f		       a9 00		      LDA	#0
    190  1081		       85 e6		      STA	s
    191  1083		       85 e7		      STA	t
    192  1085		       85 e8		      STA	u
    193  1087		       85 e9		      STA	v
    194  1089		       85 ea		      STA	w
    195  108b		       85 eb		      STA	x
    196  108d		       85 ec		      STA	y
    197  108f				   .
    198  108f							;
    199  108f
    200  108f				   .L019		;  const font	=  .21stcentury
    201  108f
    202  108f				   .
    203  108f							;
    204  108f
    205  108f				   .L020		;  const _P_Edge_Top  =  14
    206  108f
    207  108f				   .L021		;  const _P_Edge_Bottom  =  77
    208  108f
    209  108f				   .L022		;  const _P_Edge_Left	=  21
    210  108f
    211  108f				   .L023		;  const _P_Edge_Right  =  133
    212  108f
    213  108f				   .
    214  108f							;
    215  108f
    216  108f				   .L024		;  const _B_Edge_Top  =  3
    217  108f
    218  108f				   .L025		;  const _B_Edge_Bottom  =  88
    219  108f
    220  108f				   .L026		;  const _B_Edge_Left	=  2
    221  108f
    222  108f				   .L027		;  const _B_Edge_Right  =  159
    223  108f
    224  108f				   .
    225  108f							;
    226  108f
    227  108f				   .L028		;  const pfscore  =  1
    228  108f
    229  108f				   .L029		;  const _P1_Height  =  6
    230  108f
    231  108f				   .L030		;  const _P1_Width  =	8
    232  108f
    233  108f				   .L031		;  const _numberOfDiamonds  =	34
    234  108f
    235  108f				   .L032		;  const _P_Start_X  =  76
    236  108f
    237  108f				   .L033		;  const _P_Start_Y  =  50
    238  108f
    239  108f				   .L034		;  const _P_Alien_Y  =  15
    240  108f
    241  108f				   .L035		;  const _P_Alien_X  =  25
    242  108f
    243  108f				   .L036		;  const _End_Level_Pause  =  120
    244  108f
    245  108f				   .L037		;  const _P_COLOUR  =	$2E
    246  108f
    247  108f				   .
    248  108f							;
    249  108f
    250  108f				   .L038		;  dim _P1_x  =  player0x
    251  108f
    252  108f				   .L039		;  dim _P1_y  =  player0y
    253  108f
    254  108f				   .L040		;  dim _pf_x  =  a
    255  108f
    256  108f				   .L041		;  dim _pf_y  =  b
    257  108f
    258  108f							;.rot.d.
    259  108f				   .L042		;  def rot = d
    260  108f
    261  108f							;.dx.f.
    262  108f				   .L043		;  def dx = f
    263  108f
    264  108f							;.dy.g.
    265  108f				   .L044		;  def dy = g
    266  108f
    267  108f							;.frameCounter.h.
    268  108f				   .L045		;  def frameCounter = h
    269  108f
    270  108f							;.lastMoveFrame.i.
    271  108f				   .L046		;  def lastMoveFrame = i
    272  108f
    273  108f							;.deBounce.j.
    274  108f				   .L047		;  def deBounce = j
    275  108f
    276  108f							;.diamondsLeft.k.
    277  108f				   .L048		;  def diamondsLeft = k
    278  108f
    279  108f							;.endLevelPause.  l.
    280  108f				   .L049		;  def endLevelPause  =  l
    281  108f
    282  108f				   .L050		;  dim _CurrentLevel  =  n
    283  108f
    284  108f							;.isDying.  o.
    285  108f				   .L051		;  def isDying  =  o
    286  108f
    287  108f							;.aX.	p.
    288  108f				   .L052		;  def aX  =  p
    289  108f
    290  108f							;.aY.	q.
    291  108f				   .L053		;  def aY  =  q
    292  108f
    293  108f							;.playerLives.  r.
    294  108f				   .L054		;  def playerLives  =	r
    295  108f
    296  108f							;.bX.	s.
    297  108f				   .L055		;  def bX  =  s
    298  108f
    299  108f							;.bY.	t.
    300  108f				   .L056		;  def bY  =  t
    301  108f
    302  108f							;.ballActive.	u.
    303  108f				   .L057		;  def ballActive  =  u
    304  108f
    305  108f							;.hasFired.  v.
    306  108f				   .L058		;  def hasFired  =  v
    307  108f
    308  108f				   .L059		;  dim _Ch0_Sound  =  w
    309  108f
    310  108f				   .L060		;  dim _Ch0_Duration  =  x
    311  108f
    312  108f				   .
    313  108f							;
    314  108f
    315  108f				   .L061		;  ballheight	=  2  :  rem * Ball 4 pixels high.
    316  108f
    317  108f		       a9 02		      LDA	#2
    318  1091		       85 92		      STA	ballheight
    319  1093				   .L062		;  CTRLPF  =  $21  :  rem * Ball 4 pixels wide.
    320  1093
    321  1093		       a9 21		      LDA	#$21
    322  1095		       85 0a		      STA	CTRLPF
    323  1097				   .
    324  1097							;
    325  1097
    326  1097				   .L063		;  AUDV0  =  0  :  AUDV1  =  0
    327  1097
    328  1097		       a9 00		      LDA	#0
    329  1099		       85 19		      STA	AUDV0
    330  109b		       85 1a		      STA	AUDV1
    331  109d				   .
    332  109d							;
    333  109d
    334  109d				   .titlescreen
    335  109d							; titlescreen
    336  109d
    337  109d				   .L064		;  _Ch0_Sound{0}  =  0
    338  109d
    339  109d		       a5 ea		      LDA	_Ch0_Sound
    340  109f		       29 fe		      AND	#254
    341  10a1		       85 ea		      STA	_Ch0_Sound
    342  10a3				   .L065		;  _Ch0_Sound{1}  =  0
    343  10a3
    344  10a3		       a5 ea		      LDA	_Ch0_Sound
    345  10a5		       29 fd		      AND	#253
    346  10a7		       85 ea		      STA	_Ch0_Sound
    347  10a9				   .
    348  10a9							;
    349  10a9
    350  10a9				   .L066		;  deBounce  =  0
    351  10a9
    352  10a9		       a9 00		      LDA	#0
    353  10ab		       85 dd		      STA	j
    354  10ad				   .L067		;  _CurrentLevel  =  1
    355  10ad
    356  10ad		       a9 01		      LDA	#1
    357  10af		       85 e1		      STA	_CurrentLevel
    358  10b1				   .L068		;  playerLives = 4
    359  10b1
    360  10b1		       a9 04		      LDA	#4
    361  10b3		       85 e5		      STA	r
    362  10b5				   .L069		;  pfscore1  =  %10101010
    363  10b5
    364  10b5		       a9 aa		      LDA	#%10101010
    365  10b7		       85 f2		      STA	pfscore1
    366  10b9				   .L070		;  isDying  =	0
    367  10b9
    368  10b9		       a9 00		      LDA	#0
    369  10bb		       85 e2		      STA	o
    370  10bd				   .L071		;  ballActive	=  0
    371  10bd
    372  10bd		       a9 00		      LDA	#0
    373  10bf		       85 e8		      STA	u
    374  10c1				   .
    375  10c1							;
    376  10c1
    377  10c1				   .displayTitlescreen
    378  10c1							; displayTitlescreen
    379  10c1
    380  10c1				   .
    381  10c1							;
    382  10c1
    383  10c1				   .L072		;  gosub titledrawscreen bank2
    384  10c1
    385  10c1		       85 ee		      sta	temp7
    386  10c3		       a9 90		      lda	#>(ret_point1-1)
    387  10c5		       48		      pha
    388  10c6		       a9 d8		      lda	#<(ret_point1-1)
    389  10c8		       48		      pha
    390  10c9		       a9 af		      lda	#>(.titledrawscreen-1)
    391  10cb		       48		      pha
    392  10cc		       a9 ff		      lda	#<(.titledrawscreen-1)
    393  10ce		       48		      pha
    394  10cf		       a5 ee		      lda	temp7
    395  10d1		       48		      pha
    396  10d2		       8a		      txa
    397  10d3		       48		      pha
    398  10d4		       a2 02		      ldx	#2
    399  10d6		       4c eb ff 	      jmp	BS_jsr
    400  10d9				   ret_point1
    401  10d9				   .
    402  10d9							;
    403  10d9
    404  10d9				   .L073		;  if joy0fire  &&  deBounce  >  5 then goto main
    405  10d9
    406  10d9		       24 0c		      bit	INPT4
    407  10db		       30 09		      BMI	.skipL073
    408  10dd				   .condpart0
    409  10dd		       a9 05		      LDA	#5
    410  10df		       c5 dd		      CMP	j
    411  10e1		       b0 03		      BCS	.skip0then
    412  10e3				   .condpart1
    413  10e3		       4c eb 90 	      jmp	.main
    414  10e6
    415  10e6				   .skip0then
    416  10e6				   .skipL073
    417  10e6				   .L074		;  deBounce  =  deBounce  +  1
    418  10e6
    419  10e6		       e6 dd		      INC	j
    420  10e8				   .
    421  10e8							;
    422  10e8
    423  10e8				   .L075		;  goto displayTitlescreen
    424  10e8
    425  10e8		       4c c1 90 	      jmp	.displayTitlescreen
    426  10eb
    427  10eb				   .
    428  10eb							;
    429  10eb
    430  10eb				   .main
    431  10eb							; main
    432  10eb
    433  10eb				   .
    434  10eb							;
    435  10eb
    436  10eb				   .L076		;  rem ----------------------------------------------------------------------------
    437  10eb
    438  10eb				   .L077		;  c{1} = 0  : rem Turned on if the last location of the joystick was UP
    439  10eb
    440  10eb		       a5 d6		      LDA	c
    441  10ed		       29 fd		      AND	#253
    442  10ef		       85 d6		      STA	c
    443  10f1				   .L078		;  c{2} = 0  : rem Turned on if the last location of the joystick was DOWN
    444  10f1
    445  10f1		       a5 d6		      LDA	c
    446  10f3		       29 fb		      AND	#251
    447  10f5		       85 d6		      STA	c
    448  10f7				   .L079		;  c{3} = 0  : rem Turned on if the last location of the joystick was LEFT
    449  10f7
    450  10f7		       a5 d6		      LDA	c
    451  10f9		       29 f7		      AND	#247
    452  10fb		       85 d6		      STA	c
    453  10fd				   .L080		;  c{4} = 0  : rem Turned on if the last location of the joystick was RIGHT
    454  10fd
    455  10fd		       a5 d6		      LDA	c
    456  10ff		       29 ef		      AND	#239
    457  1101		       85 d6		      STA	c
    458  1103				   .L081		;  c{5} = 0  : rem Turned on if the last location of the joystick was UP+LEFT
    459  1103
    460  1103		       a5 d6		      LDA	c
    461  1105		       29 df		      AND	#223
    462  1107		       85 d6		      STA	c
    463  1109				   .L082		;  c{6} = 0  : rem Turned on if the last location of the joystick was UP+RIGHT
    464  1109
    465  1109		       a5 d6		      LDA	c
    466  110b		       29 bf		      AND	#191
    467  110d		       85 d6		      STA	c
    468  110f				   .L083		;  c{7} = 0  : rem Turned on if the last location of the joystick was DOWN+LEFT
    469  110f
    470  110f		       a5 d6		      LDA	c
    471  1111		       29 7f		      AND	#127
    472  1113		       85 d6		      STA	c
    473  1115				   .L084		;  c{0} = 0  : rem Turned on if the last location of the joystick was DOWN+RIGHT
    474  1115
    475  1115		       a5 d6		      LDA	c
    476  1117		       29 fe		      AND	#254
    477  1119		       85 d6		      STA	c
    478  111b				   .L085		;  rem ----------------------------------------------------------------------------
    479  111b
    480  111b				   .
    481  111b							;
    482  111b
    483  111b				   .L086		;  rem ----------------------------------------------------------------------------
    484  111b
    485  111b				   .newlevel
    486  111b							; newlevel
    487  111b
    488  111b				   .
    489  111b							;
    490  111b
    491  111b				   .L087		;  if playerLives  =  0 then goto gameover
    492  111b
    493  111b		       a5 e5		      LDA	r
    494  111d		       c9 00		      CMP	#0
    495  111f		       d0 03		      BNE	.skipL087
    496  1121				   .condpart2
    497  1121		       4c f4 9b 	      jmp	.gameover
    498  1124
    499  1124				   .skipL087
    500  1124				   .
    501  1124							;
    502  1124
    503  1124				   .L088		;  pfscore2  =  %00000000
    504  1124
    505  1124		       a9 00		      LDA	#%00000000
    506  1126		       85 f3		      STA	pfscore2
    507  1128				   .
    508  1128							;
    509  1128
    510  1128				   .L089		;  COLUP0  =  _P_COLOUR
    511  1128
    512  1128		       a9 2e		      LDA	#_P_COLOUR
    513  112a		       85 06		      STA	COLUP0
    514  112c				   .
    515  112c							;
    516  112c
    517  112c				   .L090		;  if _CurrentLevel  >  5 then ballActive  =  1
    518  112c
    519  112c		       a9 05		      LDA	#5
    520  112e		       c5 e1		      CMP	_CurrentLevel
    521  1130		       b0 04		      BCS	.skipL090
    522  1132				   .condpart3
    523  1132		       a9 01		      LDA	#1
    524  1134		       85 e8		      STA	u
    525  1136				   .skipL090
    526  1136				   .
    527  1136							;
    528  1136
    529  1136				   .L091		;  player0x  =  _P_Start_X
    530  1136
    531  1136		       a9 4c		      LDA	#_P_Start_X
    532  1138		       85 80		      STA	player0x
    533  113a				   .L092		;  player0y  =  _P_Start_Y
    534  113a
    535  113a		       a9 32		      LDA	#_P_Start_Y
    536  113c		       85 85		      STA	player0y
    537  113e				   .L093		;  player1y  =  _P_Alien_Y
    538  113e
    539  113e		       a9 0f		      LDA	#_P_Alien_Y
    540  1140		       85 86		      STA	player1y
    541  1142				   .L094		;  player1x  =  _P_Alien_X
    542  1142
    543  1142		       a9 19		      LDA	#_P_Alien_X
    544  1144		       85 81		      STA	player1x
    545  1146				   .L095		;  if ballActive  =  1 then ballx  =  30  :  bally  =	10
    546  1146
    547  1146		       a5 e8		      LDA	u
    548  1148		       c9 01		      CMP	#1
    549  114a		       d0 08		      BNE	.skipL095
    550  114c				   .condpart4
    551  114c		       a9 1e		      LDA	#30
    552  114e		       85 84		      STA	ballx
    553  1150		       a9 0a		      LDA	#10
    554  1152		       85 89		      STA	bally
    555  1154				   .skipL095
    556  1154				   .L096		;  rot  =  0
    557  1154
    558  1154		       a9 00		      LDA	#0
    559  1156		       85 d7		      STA	d
    560  1158				   .L097		;  dx	=  3
    561  1158
    562  1158		       a9 03		      LDA	#3
    563  115a		       85 d9		      STA	f
    564  115c				   .L098		;  dy	=  3
    565  115c
    566  115c		       a9 03		      LDA	#3
    567  115e		       85 da		      STA	g
    568  1160				   .L099		;  aX	=  3
    569  1160
    570  1160		       a9 03		      LDA	#3
    571  1162		       85 e3		      STA	p
    572  1164				   .L0100		;  aY	=  3
    573  1164
    574  1164		       a9 03		      LDA	#3
    575  1166		       85 e4		      STA	q
    576  1168				   .L0101		;  frameCounter  =  0
    577  1168
    578  1168		       a9 00		      LDA	#0
    579  116a		       85 db		      STA	h
    580  116c				   .L0102		;  lastMoveFrame  =  0
    581  116c
    582  116c		       a9 00		      LDA	#0
    583  116e		       85 dc		      STA	i
    584  1170				   .
    585  1170							;
    586  1170
    587  1170				   .L0103		;  if isDying then goto setupgame
    588  1170
    589  1170		       a5 e2		      LDA	o
    590  1172		       f0 03		      BEQ	.skipL0103
    591  1174				   .condpart5
    592  1174		       4c e6 91 	      jmp	.setupgame
    593  1177
    594  1177				   .skipL0103
    595  1177				   .
    596  1177							;
    597  1177
    598  1177				   .L0104		;  playfield:
    599  1177
    600  1177				  -	      ifconst	pfres
    601  1177				  -	      ldx	#(11>pfres)*(pfres*pfwidth-1)+(11<=pfres)*43
    602  1177					      else
    603  1177		       a2 2b		      ldx	#((11*pfwidth-1)*((11*pfwidth-1)<47))+(47*((11*pfwidth-1)>=47))
    604  1179					      endif
    605  1179		       4c a8 91 	      jmp	pflabel0
    606  117c				   PF_data0
    607  117c		       00 00		      .byte.b	%00000000, %00000000
    608  117e					      if	(pfwidth>2)
    609  117e		       00 00		      .byte.b	%00000000, %00000000
    610  1180					      endif
    611  1180		       00 00		      .byte.b	%00000000, %00000000
    612  1182					      if	(pfwidth>2)
    613  1182		       00 00		      .byte.b	%00000000, %00000000
    614  1184					      endif
    615  1184		       00 00		      .byte.b	%00000000, %00000000
    616  1186					      if	(pfwidth>2)
    617  1186		       00 00		      .byte.b	%00000000, %00000000
    618  1188					      endif
    619  1188		       03 dd		      .byte.b	%00000011, %11011101
    620  118a					      if	(pfwidth>2)
    621  118a		       bb 01		      .byte.b	%10111011, %00000001
    622  118c					      endif
    623  118c		       02 48		      .byte.b	%00000010, %01001000
    624  118e					      if	(pfwidth>2)
    625  118e		       a9 00		      .byte.b	%10101001, %00000000
    626  1190					      endif
    627  1190		       03 c9		      .byte.b	%00000011, %11001001
    628  1192					      if	(pfwidth>2)
    629  1192		       b9 00		      .byte.b	%10111001, %00000000
    630  1194					      endif
    631  1194		       00 49		      .byte.b	%00000000, %01001001
    632  1196					      if	(pfwidth>2)
    633  1196		       b1 00		      .byte.b	%10110001, %00000000
    634  1198					      endif
    635  1198		       03 49		      .byte.b	%00000011, %01001001
    636  119a					      if	(pfwidth>2)
    637  119a		       a9 00		      .byte.b	%10101001, %00000000
    638  119c					      endif
    639  119c		       00 00		      .byte.b	%00000000, %00000000
    640  119e					      if	(pfwidth>2)
    641  119e		       00 00		      .byte.b	%00000000, %00000000
    642  11a0					      endif
    643  11a0		       00 00		      .byte.b	%00000000, %00000000
    644  11a2					      if	(pfwidth>2)
    645  11a2		       00 00		      .byte.b	%00000000, %00000000
    646  11a4					      endif
    647  11a4		       00 00		      .byte.b	%00000000, %00000000
    648  11a6					      if	(pfwidth>2)
    649  11a6		       00 00		      .byte.b	%00000000, %00000000
    650  11a8					      endif
    651  11a8				   pflabel0
    652  11a8		       bd 7c 91 	      lda	PF_data0,x
    653  11ab		       95 a4		      sta	playfield,x
    654  11ad		       ca		      dex
    655  11ae		       10 f8		      bpl	pflabel0
    656  11b0				   .
    657  11b0							;
    658  11b0
    659  11b0				   .L0105		;  pfcolors:
    660  11b0
    661  11b0		       a9 00		      lda	# $0
    662  11b2		       85 08		      sta	COLUPF
    663  11b4				  -	      ifconst	pfres
    664  11b4				  -	      lda	#>(pfcolorlabel13-132+pfres*pfwidth)
    665  11b4					      else
    666  11b4		       a9 f5		      lda	#>(pfcolorlabel13-84)
    667  11b6					      endif
    668  11b6		       85 f1		      sta	pfcolortable+1
    669  11b8				  -	      ifconst	pfres
    670  11b8				  -	      lda	#<(pfcolorlabel13-132+pfres*pfwidth)
    671  11b8					      else
    672  11b8		       a9 04		      lda	#<(pfcolorlabel13-84)
    673  11ba					      endif
    674  11ba		       85 f0		      sta	pfcolortable
    675  11bc				   .
    676  11bc							;
    677  11bc
    678  11bc				   .L0106		;  drawscreen
    679  11bc
    680  11bc		       85 ee		      sta	temp7
    681  11be		       a9 91		      lda	#>(ret_point2-1)
    682  11c0		       48		      pha
    683  11c1		       a9 d3		      lda	#<(ret_point2-1)
    684  11c3		       48		      pha
    685  11c4		       a9 f4		      lda	#>(drawscreen-1)
    686  11c6		       48		      pha
    687  11c7		       a9 3b		      lda	#<(drawscreen-1)
    688  11c9		       48		      pha
    689  11ca		       a5 ee		      lda	temp7
    690  11cc		       48		      pha
    691  11cd		       8a		      txa
    692  11ce		       48		      pha
    693  11cf		       a2 04		      ldx	#4
    694  11d1		       4c eb ff 	      jmp	BS_jsr
    695  11d4				   ret_point2
    696  11d4				   .L0107		;  j  =  j  +	1
    697  11d4
    698  11d4		       e6 dd		      INC	j
    699  11d6				   .L0108		;  if joy0fire  &&  j	>  5 then goto setupgame
    700  11d6
    701  11d6		       24 0c		      bit	INPT4
    702  11d8		       30 09		      BMI	.skipL0108
    703  11da				   .condpart6
    704  11da		       a9 05		      LDA	#5
    705  11dc		       c5 dd		      CMP	j
    706  11de		       b0 03		      BCS	.skip6then
    707  11e0				   .condpart7
    708  11e0		       4c e6 91 	      jmp	.setupgame
    709  11e3
    710  11e3				   .skip6then
    711  11e3				   .skipL0108
    712  11e3				   .L0109		;  goto newlevel
    713  11e3
    714  11e3		       4c 1b 91 	      jmp	.newlevel
    715  11e6
    716  11e6				   .
    717  11e6							;
    718  11e6
    719  11e6				   .setupgame
    720  11e6							; setupgame
    721  11e6
    722  11e6				   .L0110		;  dx = 3
    723  11e6
    724  11e6		       a9 03		      LDA	#3
    725  11e8		       85 d9		      STA	f
    726  11ea				   .L0111		;  dy = 3
    727  11ea
    728  11ea		       a9 03		      LDA	#3
    729  11ec		       85 da		      STA	g
    730  11ee				   .L0112		;  rot = 1
    731  11ee
    732  11ee		       a9 01		      LDA	#1
    733  11f0		       85 d7		      STA	d
    734  11f2				   .L0113		;  if isDying then isDying  =	0  :  goto start
    735  11f2
    736  11f2		       a5 e2		      LDA	o
    737  11f4		       f0 07		      BEQ	.skipL0113
    738  11f6				   .condpart8
    739  11f6		       a9 00		      LDA	#0
    740  11f8		       85 e2		      STA	o
    741  11fa		       4c 3a 92 	      jmp	.start
    742  11fd
    743  11fd				   .skipL0113
    744  11fd				   .L0114		;  diamondsLeft  =  _numberOfDiamonds
    745  11fd
    746  11fd		       a9 22		      LDA	#_numberOfDiamonds
    747  11ff		       85 de		      STA	k
    748  1201				   .
    749  1201							;
    750  1201
    751  1201				   .L0115		;  playfield:
    752  1201
    753  1201				  -	      ifconst	pfres
    754  1201				  -	      ldx	#(11>pfres)*(pfres*pfwidth-1)+(11<=pfres)*43
    755  1201					      else
    756  1201		       a2 2b		      ldx	#((11*pfwidth-1)*((11*pfwidth-1)<47))+(47*((11*pfwidth-1)>=47))
    757  1203					      endif
    758  1203		       4c 32 92 	      jmp	pflabel1
    759  1206				   PF_data1
    760  1206		       ff ff		      .byte.b	%11111111, %11111111
    761  1208					      if	(pfwidth>2)
    762  1208		       ff ff		      .byte.b	%11111111, %11111111
    763  120a					      endif
    764  120a		       80 00		      .byte.b	%10000000, %00000000
    765  120c					      if	(pfwidth>2)
    766  120c		       00 80		      .byte.b	%00000000, %10000000
    767  120e					      endif
    768  120e		       92 92		      .byte.b	%10010010, %10010010
    769  1210					      if	(pfwidth>2)
    770  1210		       24 89		      .byte.b	%00100100, %10001001
    771  1212					      endif
    772  1212		       80 00		      .byte.b	%10000000, %00000000
    773  1214					      if	(pfwidth>2)
    774  1214		       00 80		      .byte.b	%00000000, %10000000
    775  1216					      endif
    776  1216		       92 12		      .byte.b	%10010010, %00010010
    777  1218					      if	(pfwidth>2)
    778  1218		       24 89		      .byte.b	%00100100, %10001001
    779  121a					      endif
    780  121a		       80 00		      .byte.b	%10000000, %00000000
    781  121c					      if	(pfwidth>2)
    782  121c		       00 80		      .byte.b	%00000000, %10000000
    783  121e					      endif
    784  121e		       92 12		      .byte.b	%10010010, %00010010
    785  1220					      if	(pfwidth>2)
    786  1220		       24 89		      .byte.b	%00100100, %10001001
    787  1222					      endif
    788  1222		       80 00		      .byte.b	%10000000, %00000000
    789  1224					      if	(pfwidth>2)
    790  1224		       00 80		      .byte.b	%00000000, %10000000
    791  1226					      endif
    792  1226		       92 92		      .byte.b	%10010010, %10010010
    793  1228					      if	(pfwidth>2)
    794  1228		       24 89		      .byte.b	%00100100, %10001001
    795  122a					      endif
    796  122a		       80 00		      .byte.b	%10000000, %00000000
    797  122c					      if	(pfwidth>2)
    798  122c		       00 80		      .byte.b	%00000000, %10000000
    799  122e					      endif
    800  122e		       ff ff		      .byte.b	%11111111, %11111111
    801  1230					      if	(pfwidth>2)
    802  1230		       ff ff		      .byte.b	%11111111, %11111111
    803  1232					      endif
    804  1232				   pflabel1
    805  1232		       bd 06 92 	      lda	PF_data1,x
    806  1235		       95 a4		      sta	playfield,x
    807  1237		       ca		      dex
    808  1238		       10 f8		      bpl	pflabel1
    809  123a				   .
    810  123a							;
    811  123a
    812  123a				   .start
    813  123a							; start
    814  123a
    815  123a				   .
    816  123a							;
    817  123a
    818  123a				   .L0116		;  pfcolors:
    819  123a
    820  123a		       a9 fc		      lda	# $FC
    821  123c		       85 08		      sta	COLUPF
    822  123e				  -	      ifconst	pfres
    823  123e				  -	      lda	#>(pfcolorlabel13-131+pfres*pfwidth)
    824  123e					      else
    825  123e		       a9 f5		      lda	#>(pfcolorlabel13-83)
    826  1240					      endif
    827  1240		       85 f1		      sta	pfcolortable+1
    828  1242				  -	      ifconst	pfres
    829  1242				  -	      lda	#<(pfcolorlabel13-131+pfres*pfwidth)
    830  1242					      else
    831  1242		       a9 05		      lda	#<(pfcolorlabel13-83)
    832  1244					      endif
    833  1244		       85 f0		      sta	pfcolortable
    834  1246				   .
    835  1246							;
    836  1246
    837  1246				   .L0117		;  rem if joy0fire then AUDV0=8 : AUDV1=8 : AUDC0=4 : AUDC1=4
    838  1246
    839  1246				   .
    840  1246							;
    841  1246
    842  1246				   .L0118		;  scorecolor = _P_COLOUR
    843  1246
    844  1246		       a9 2e		      LDA	#_P_COLOUR
    845  1248		       85 a3		      STA	scorecolor
    846  124a				   .L0119		;  pfscorecolor  =  _P_COLOUR
    847  124a
    848  124a		       a9 2e		      LDA	#_P_COLOUR
    849  124c		       85 f4		      STA	pfscorecolor
    850  124e				   .
    851  124e							;
    852  124e
    853  124e				   .L0120		;  drawscreen
    854  124e
    855  124e		       85 ee		      sta	temp7
    856  1250		       a9 92		      lda	#>(ret_point3-1)
    857  1252		       48		      pha
    858  1253		       a9 65		      lda	#<(ret_point3-1)
    859  1255		       48		      pha
    860  1256		       a9 f4		      lda	#>(drawscreen-1)
    861  1258		       48		      pha
    862  1259		       a9 3b		      lda	#<(drawscreen-1)
    863  125b		       48		      pha
    864  125c		       a5 ee		      lda	temp7
    865  125e		       48		      pha
    866  125f		       8a		      txa
    867  1260		       48		      pha
    868  1261		       a2 04		      ldx	#4
    869  1263		       4c eb ff 	      jmp	BS_jsr
    870  1266				   ret_point3
    871  1266				   .L0121		;  frameCounter = frameCounter + 1
    872  1266
    873  1266		       e6 db		      INC	h
    874  1268				   .L0122		;  if frameCounter  >	60 then frameCounter  =  0
    875  1268
    876  1268		       a9 3c		      LDA	#60
    877  126a		       c5 db		      CMP	h
    878  126c		       b0 04		      BCS	.skipL0122
    879  126e				   .condpart9
    880  126e		       a9 00		      LDA	#0
    881  1270		       85 db		      STA	h
    882  1272				   .skipL0122
    883  1272				   .L0123		;  rem ---------------------------------------------------------------------------------
    884  1272
    885  1272				   .L0124		;  rem This section sets a value for the last direction the joystick was pushed
    886  1272
    887  1272				   .L0125		;  rem
    888  1272
    889  1272				   .L0126		;  rem  This determines the direction the bullet will be fired later, and also
    890  1272
    891  1272				   .L0127		;  rem  allows you to keep firing the bullet in the same direction after you
    892  1272
    893  1272				   .L0128		;  rem  have stopped moving.
    894  1272
    895  1272				   .L0129		;  rem
    896  1272
    897  1272				   .L0130		;  rem  Each time you move, each of the eight possible directions of the joystick is
    898  1272
    899  1272				   .L0131		;  rem  marked as on or off with a bit variable.
    900  1272
    901  1272				   .L0132		;  rem ---------------------------------------------------------------------------------
    902  1272
    903  1272				   .
    904  1272							;
    905  1272
    906  1272				   .L0133		;  if diamondsLeft  <=  0  ||	isDying  =  1 then goto waitforlevelend
    907  1272
    908  1272		       a9 00		      LDA	#0
    909  1274		       c5 de		      CMP	k
    910  1276		       90 03		      BCC	.skipL0133
    911  1278				   .condpart10
    912  1278		       4c 81 92 	      jmp	.condpart11
    913  127b				   .skipL0133
    914  127b		       a5 e2		      LDA	o
    915  127d		       c9 01		      CMP	#1
    916  127f		       d0 03		      BNE	.skip2OR
    917  1281				   .condpart11
    918  1281		       4c 7a 96 	      jmp	.waitforlevelend
    919  1284
    920  1284				   .skip2OR
    921  1284				   .
    922  1284							;
    923  1284
    924  1284				   .L0134		;  if joy0up then c{1} = 1 : c{2} = 0 : c{3} = 0 : c{4} = 0 : c{5} = 0 : c{6} = 0 : c{7} = 0 : c{0} = 0
    925  1284
    926  1284		       a9 10		      lda	#$10
    927  1286		       2c 80 02 	      bit	SWCHA
    928  1289		       d0 30		      BNE	.skipL0134
    929  128b				   .condpart12
    930  128b		       a5 d6		      LDA	c
    931  128d		       09 02		      ORA	#2
    932  128f		       85 d6		      STA	c
    933  1291		       a5 d6		      LDA	c
    934  1293		       29 fb		      AND	#251
    935  1295		       85 d6		      STA	c
    936  1297		       a5 d6		      LDA	c
    937  1299		       29 f7		      AND	#247
    938  129b		       85 d6		      STA	c
    939  129d		       a5 d6		      LDA	c
    940  129f		       29 ef		      AND	#239
    941  12a1		       85 d6		      STA	c
    942  12a3		       a5 d6		      LDA	c
    943  12a5		       29 df		      AND	#223
    944  12a7		       85 d6		      STA	c
    945  12a9		       a5 d6		      LDA	c
    946  12ab		       29 bf		      AND	#191
    947  12ad		       85 d6		      STA	c
    948  12af		       a5 d6		      LDA	c
    949  12b1		       29 7f		      AND	#127
    950  12b3		       85 d6		      STA	c
    951  12b5		       a5 d6		      LDA	c
    952  12b7		       29 fe		      AND	#254
    953  12b9		       85 d6		      STA	c
    954  12bb				   .skipL0134
    955  12bb				   .L0135		;  if joy0down then c{1} = 0 : c{2} = 1 : c{3} = 0 : c{4} = 0 : c{5} = 0 : c{6} = 0 : c{7} = 0 : c{0} = 0
    956  12bb
    957  12bb		       a9 20		      lda	#$20
    958  12bd		       2c 80 02 	      bit	SWCHA
    959  12c0		       d0 30		      BNE	.skipL0135
    960  12c2				   .condpart13
    961  12c2		       a5 d6		      LDA	c
    962  12c4		       29 fd		      AND	#253
    963  12c6		       85 d6		      STA	c
    964  12c8		       a5 d6		      LDA	c
    965  12ca		       09 04		      ORA	#4
    966  12cc		       85 d6		      STA	c
    967  12ce		       a5 d6		      LDA	c
    968  12d0		       29 f7		      AND	#247
    969  12d2		       85 d6		      STA	c
    970  12d4		       a5 d6		      LDA	c
    971  12d6		       29 ef		      AND	#239
    972  12d8		       85 d6		      STA	c
    973  12da		       a5 d6		      LDA	c
    974  12dc		       29 df		      AND	#223
    975  12de		       85 d6		      STA	c
    976  12e0		       a5 d6		      LDA	c
    977  12e2		       29 bf		      AND	#191
    978  12e4		       85 d6		      STA	c
    979  12e6		       a5 d6		      LDA	c
    980  12e8		       29 7f		      AND	#127
    981  12ea		       85 d6		      STA	c
    982  12ec		       a5 d6		      LDA	c
    983  12ee		       29 fe		      AND	#254
    984  12f0		       85 d6		      STA	c
    985  12f2				   .skipL0135
    986  12f2				   .L0136		;  if joy0left then c{1} = 0 : c{2} = 0 : c{3} = 1 : c{4} = 0 : c{5} = 0 : c{6} = 0 : c{7} = 0 : c{0} = 0
    987  12f2
    988  12f2		       2c 80 02 	      bit	SWCHA
    989  12f5		       70 30		      BVS	.skipL0136
    990  12f7				   .condpart14
    991  12f7		       a5 d6		      LDA	c
    992  12f9		       29 fd		      AND	#253
    993  12fb		       85 d6		      STA	c
    994  12fd		       a5 d6		      LDA	c
    995  12ff		       29 fb		      AND	#251
    996  1301		       85 d6		      STA	c
    997  1303		       a5 d6		      LDA	c
    998  1305		       09 08		      ORA	#8
    999  1307		       85 d6		      STA	c
   1000  1309		       a5 d6		      LDA	c
   1001  130b		       29 ef		      AND	#239
   1002  130d		       85 d6		      STA	c
   1003  130f		       a5 d6		      LDA	c
   1004  1311		       29 df		      AND	#223
   1005  1313		       85 d6		      STA	c
   1006  1315		       a5 d6		      LDA	c
   1007  1317		       29 bf		      AND	#191
   1008  1319		       85 d6		      STA	c
   1009  131b		       a5 d6		      LDA	c
   1010  131d		       29 7f		      AND	#127
   1011  131f		       85 d6		      STA	c
   1012  1321		       a5 d6		      LDA	c
   1013  1323		       29 fe		      AND	#254
   1014  1325		       85 d6		      STA	c
   1015  1327				   .skipL0136
   1016  1327				   .L0137		;  if joy0right then c{1} = 0 : c{2} = 0 : c{3} = 0 : c{4} = 1 : c{5} = 0 : c{6} = 0 : c{7} = 0 : c{0} = 0
   1017  1327
   1018  1327		       2c 80 02 	      bit	SWCHA
   1019  132a		       30 30		      BMI	.skipL0137
   1020  132c				   .condpart15
   1021  132c		       a5 d6		      LDA	c
   1022  132e		       29 fd		      AND	#253
   1023  1330		       85 d6		      STA	c
   1024  1332		       a5 d6		      LDA	c
   1025  1334		       29 fb		      AND	#251
   1026  1336		       85 d6		      STA	c
   1027  1338		       a5 d6		      LDA	c
   1028  133a		       29 f7		      AND	#247
   1029  133c		       85 d6		      STA	c
   1030  133e		       a5 d6		      LDA	c
   1031  1340		       09 10		      ORA	#16
   1032  1342		       85 d6		      STA	c
   1033  1344		       a5 d6		      LDA	c
   1034  1346		       29 df		      AND	#223
   1035  1348		       85 d6		      STA	c
   1036  134a		       a5 d6		      LDA	c
   1037  134c		       29 bf		      AND	#191
   1038  134e		       85 d6		      STA	c
   1039  1350		       a5 d6		      LDA	c
   1040  1352		       29 7f		      AND	#127
   1041  1354		       85 d6		      STA	c
   1042  1356		       a5 d6		      LDA	c
   1043  1358		       29 fe		      AND	#254
   1044  135a		       85 d6		      STA	c
   1045  135c				   .skipL0137
   1046  135c				   .L0138		;  if joy0up  &&  joy0left then c{1} = 0 : c{2} = 0 : c{3} = 0 : c{4} = 0 : c{5} = 1 : c{6} = 0 : c{7} = 0 : c{0} = 0
   1047  135c
   1048  135c		       a9 10		      lda	#$10
   1049  135e		       2c 80 02 	      bit	SWCHA
   1050  1361		       d0 35		      BNE	.skipL0138
   1051  1363				   .condpart16
   1052  1363		       2c 80 02 	      bit	SWCHA
   1053  1366		       70 30		      BVS	.skip16then
   1054  1368				   .condpart17
   1055  1368		       a5 d6		      LDA	c
   1056  136a		       29 fd		      AND	#253
   1057  136c		       85 d6		      STA	c
   1058  136e		       a5 d6		      LDA	c
   1059  1370		       29 fb		      AND	#251
   1060  1372		       85 d6		      STA	c
   1061  1374		       a5 d6		      LDA	c
   1062  1376		       29 f7		      AND	#247
   1063  1378		       85 d6		      STA	c
   1064  137a		       a5 d6		      LDA	c
   1065  137c		       29 ef		      AND	#239
   1066  137e		       85 d6		      STA	c
   1067  1380		       a5 d6		      LDA	c
   1068  1382		       09 20		      ORA	#32
   1069  1384		       85 d6		      STA	c
   1070  1386		       a5 d6		      LDA	c
   1071  1388		       29 bf		      AND	#191
   1072  138a		       85 d6		      STA	c
   1073  138c		       a5 d6		      LDA	c
   1074  138e		       29 7f		      AND	#127
   1075  1390		       85 d6		      STA	c
   1076  1392		       a5 d6		      LDA	c
   1077  1394		       29 fe		      AND	#254
   1078  1396		       85 d6		      STA	c
   1079  1398				   .skip16then
   1080  1398				   .skipL0138
   1081  1398				   .L0139		;  if joy0up  &&  joy0right then c{1} = 0 : c{2} = 0 : c{3} = 0 : c{4} = 0 : c{5} = 0 : c{6} = 1 : c{7} = 0 : c{0} = 0
   1082  1398
   1083  1398		       a9 10		      lda	#$10
   1084  139a		       2c 80 02 	      bit	SWCHA
   1085  139d		       d0 35		      BNE	.skipL0139
   1086  139f				   .condpart18
   1087  139f		       2c 80 02 	      bit	SWCHA
   1088  13a2		       30 30		      BMI	.skip18then
   1089  13a4				   .condpart19
   1090  13a4		       a5 d6		      LDA	c
   1091  13a6		       29 fd		      AND	#253
   1092  13a8		       85 d6		      STA	c
   1093  13aa		       a5 d6		      LDA	c
   1094  13ac		       29 fb		      AND	#251
   1095  13ae		       85 d6		      STA	c
   1096  13b0		       a5 d6		      LDA	c
   1097  13b2		       29 f7		      AND	#247
   1098  13b4		       85 d6		      STA	c
   1099  13b6		       a5 d6		      LDA	c
   1100  13b8		       29 ef		      AND	#239
   1101  13ba		       85 d6		      STA	c
   1102  13bc		       a5 d6		      LDA	c
   1103  13be		       29 df		      AND	#223
   1104  13c0		       85 d6		      STA	c
   1105  13c2		       a5 d6		      LDA	c
   1106  13c4		       09 40		      ORA	#64
   1107  13c6		       85 d6		      STA	c
   1108  13c8		       a5 d6		      LDA	c
   1109  13ca		       29 7f		      AND	#127
   1110  13cc		       85 d6		      STA	c
   1111  13ce		       a5 d6		      LDA	c
   1112  13d0		       29 fe		      AND	#254
   1113  13d2		       85 d6		      STA	c
   1114  13d4				   .skip18then
   1115  13d4				   .skipL0139
   1116  13d4				   .L0140		;  if joy0down  &&  joy0left then c{1} = 0 : c{2} = 0 : c{3} = 0 : c{4} = 0 : c{5} = 0 : c{6} = 0 : c{7} = 1 : c{0} = 0
   1117  13d4
   1118  13d4		       a9 20		      lda	#$20
   1119  13d6		       2c 80 02 	      bit	SWCHA
   1120  13d9		       d0 35		      BNE	.skipL0140
   1121  13db				   .condpart20
   1122  13db		       2c 80 02 	      bit	SWCHA
   1123  13de		       70 30		      BVS	.skip20then
   1124  13e0				   .condpart21
   1125  13e0		       a5 d6		      LDA	c
   1126  13e2		       29 fd		      AND	#253
   1127  13e4		       85 d6		      STA	c
   1128  13e6		       a5 d6		      LDA	c
   1129  13e8		       29 fb		      AND	#251
   1130  13ea		       85 d6		      STA	c
   1131  13ec		       a5 d6		      LDA	c
   1132  13ee		       29 f7		      AND	#247
   1133  13f0		       85 d6		      STA	c
   1134  13f2		       a5 d6		      LDA	c
   1135  13f4		       29 ef		      AND	#239
   1136  13f6		       85 d6		      STA	c
   1137  13f8		       a5 d6		      LDA	c
   1138  13fa		       29 df		      AND	#223
   1139  13fc		       85 d6		      STA	c
   1140  13fe		       a5 d6		      LDA	c
   1141  1400		       29 bf		      AND	#191
   1142  1402		       85 d6		      STA	c
   1143  1404		       a5 d6		      LDA	c
   1144  1406		       09 80		      ORA	#128
   1145  1408		       85 d6		      STA	c
   1146  140a		       a5 d6		      LDA	c
   1147  140c		       29 fe		      AND	#254
   1148  140e		       85 d6		      STA	c
   1149  1410				   .skip20then
   1150  1410				   .skipL0140
   1151  1410				   .L0141		;  if joy0down  &&  joy0right then c{1} = 0 : c{2} = 0 : c{3} = 0 : c{4} = 0 : c{5} = 0 : c{6} = 0 : c{7} = 0 : c{0} = 1
   1152  1410
   1153  1410		       a9 20		      lda	#$20
   1154  1412		       2c 80 02 	      bit	SWCHA
   1155  1415		       d0 35		      BNE	.skipL0141
   1156  1417				   .condpart22
   1157  1417		       2c 80 02 	      bit	SWCHA
   1158  141a		       30 30		      BMI	.skip22then
   1159  141c				   .condpart23
   1160  141c		       a5 d6		      LDA	c
   1161  141e		       29 fd		      AND	#253
   1162  1420		       85 d6		      STA	c
   1163  1422		       a5 d6		      LDA	c
   1164  1424		       29 fb		      AND	#251
   1165  1426		       85 d6		      STA	c
   1166  1428		       a5 d6		      LDA	c
   1167  142a		       29 f7		      AND	#247
   1168  142c		       85 d6		      STA	c
   1169  142e		       a5 d6		      LDA	c
   1170  1430		       29 ef		      AND	#239
   1171  1432		       85 d6		      STA	c
   1172  1434		       a5 d6		      LDA	c
   1173  1436		       29 df		      AND	#223
   1174  1438		       85 d6		      STA	c
   1175  143a		       a5 d6		      LDA	c
   1176  143c		       29 bf		      AND	#191
   1177  143e		       85 d6		      STA	c
   1178  1440		       a5 d6		      LDA	c
   1179  1442		       29 7f		      AND	#127
   1180  1444		       85 d6		      STA	c
   1181  1446		       a5 d6		      LDA	c
   1182  1448		       09 01		      ORA	#1
   1183  144a		       85 d6		      STA	c
   1184  144c				   .skip22then
   1185  144c				   .skipL0141
   1186  144c				   .
   1187  144c							;
   1188  144c
   1189  144c				   .L0142		;  if frameCounter  -	lastMoveFrame  <  10  &&  frameCounter	-  lastMoveFrame  >  0 then goto skipRotate
   1190  144c
   1191  144c							; complex condition detected
   1192  144c		       a5 db		      LDA	h
   1193  144e		       38		      SEC
   1194  144f		       e5 dc		      SBC	i
   1195  1451							; todo: this LDA is spurious and should be prevented ->	LDA  1,x
   1196  1451		       c9 0a		      CMP	#10
   1197  1453		       b0 11		      BCS	.skipL0142
   1198  1455				   .condpart24
   1199  1455							; complex condition detected
   1200  1455		       a5 db		      LDA	h
   1201  1457		       38		      SEC
   1202  1458		       e5 dc		      SBC	i
   1203  145a		       48		      PHA
   1204  145b		       ba		      TSX
   1205  145c		       68		      PLA
   1206  145d		       a9 00		      LDA	#0
   1207  145f		       d5 01		      CMP	1,x
   1208  1461		       b0 03		      BCS	.skip24then
   1209  1463				   .condpart25
   1210  1463		       4c 1e 95 	      jmp	.skipRotate
   1211  1466
   1212  1466				   .skip24then
   1213  1466				   .skipL0142
   1214  1466				   .
   1215  1466							;
   1216  1466
   1217  1466				   .L0143		;  if joy0left then rot = rot - 1  :  lastMoveFrame = frameCounter
   1218  1466
   1219  1466		       2c 80 02 	      bit	SWCHA
   1220  1469		       70 06		      BVS	.skipL0143
   1221  146b				   .condpart26
   1222  146b		       c6 d7		      DEC	d
   1223  146d		       a5 db		      LDA	h
   1224  146f		       85 dc		      STA	i
   1225  1471				   .skipL0143
   1226  1471				   .L0144		;  if joy0right then rot = rot + 1  :	lastMoveFrame = frameCounter
   1227  1471
   1228  1471		       2c 80 02 	      bit	SWCHA
   1229  1474		       30 06		      BMI	.skipL0144
   1230  1476				   .condpart27
   1231  1476		       e6 d7		      INC	d
   1232  1478		       a5 db		      LDA	h
   1233  147a		       85 dc		      STA	i
   1234  147c				   .skipL0144
   1235  147c				   .
   1236  147c							;
   1237  147c
   1238  147c				   .L0145		;  if joy0fire  &&  rot = 1 then dy  =  dy  -	1
   1239  147c
   1240  147c		       24 0c		      bit	INPT4
   1241  147e		       30 08		      BMI	.skipL0145
   1242  1480				   .condpart28
   1243  1480		       a5 d7		      LDA	d
   1244  1482		       c9 01		      CMP	#1
   1245  1484		       d0 02		      BNE	.skip28then
   1246  1486				   .condpart29
   1247  1486		       c6 da		      DEC	g
   1248  1488				   .skip28then
   1249  1488				   .skipL0145
   1250  1488				   .L0146		;  if joy0fire  &&  rot = 2 then dy = dy  -  1  :  dx = dx  +	1
   1251  1488
   1252  1488		       24 0c		      bit	INPT4
   1253  148a		       30 0a		      BMI	.skipL0146
   1254  148c				   .condpart30
   1255  148c		       a5 d7		      LDA	d
   1256  148e		       c9 02		      CMP	#2
   1257  1490		       d0 04		      BNE	.skip30then
   1258  1492				   .condpart31
   1259  1492		       c6 da		      DEC	g
   1260  1494		       e6 d9		      INC	f
   1261  1496				   .skip30then
   1262  1496				   .skipL0146
   1263  1496				   .L0147		;  if joy0fire  &&  rot = 3 then dx = dx  +  1
   1264  1496
   1265  1496		       24 0c		      bit	INPT4
   1266  1498		       30 08		      BMI	.skipL0147
   1267  149a				   .condpart32
   1268  149a		       a5 d7		      LDA	d
   1269  149c		       c9 03		      CMP	#3
   1270  149e		       d0 02		      BNE	.skip32then
   1271  14a0				   .condpart33
   1272  14a0		       e6 d9		      INC	f
   1273  14a2				   .skip32then
   1274  14a2				   .skipL0147
   1275  14a2				   .L0148		;  if joy0fire  &&  rot = 4 then dy = dy  +  1  :  dx = dx  +	1
   1276  14a2
   1277  14a2		       24 0c		      bit	INPT4
   1278  14a4		       30 0a		      BMI	.skipL0148
   1279  14a6				   .condpart34
   1280  14a6		       a5 d7		      LDA	d
   1281  14a8		       c9 04		      CMP	#4
   1282  14aa		       d0 04		      BNE	.skip34then
   1283  14ac				   .condpart35
   1284  14ac		       e6 da		      INC	g
   1285  14ae		       e6 d9		      INC	f
   1286  14b0				   .skip34then
   1287  14b0				   .skipL0148
   1288  14b0				   .L0149		;  if joy0fire  &&  rot = 5 then dy = dy  +  1
   1289  14b0
   1290  14b0		       24 0c		      bit	INPT4
   1291  14b2		       30 08		      BMI	.skipL0149
   1292  14b4				   .condpart36
   1293  14b4		       a5 d7		      LDA	d
   1294  14b6		       c9 05		      CMP	#5
   1295  14b8		       d0 02		      BNE	.skip36then
   1296  14ba				   .condpart37
   1297  14ba		       e6 da		      INC	g
   1298  14bc				   .skip36then
   1299  14bc				   .skipL0149
   1300  14bc				   .L0150		;  if joy0fire  &&  rot = 6 then dy = dy  +  1  :  dx = dx  -	1
   1301  14bc
   1302  14bc		       24 0c		      bit	INPT4
   1303  14be		       30 0a		      BMI	.skipL0150
   1304  14c0				   .condpart38
   1305  14c0		       a5 d7		      LDA	d
   1306  14c2		       c9 06		      CMP	#6
   1307  14c4		       d0 04		      BNE	.skip38then
   1308  14c6				   .condpart39
   1309  14c6		       e6 da		      INC	g
   1310  14c8		       c6 d9		      DEC	f
   1311  14ca				   .skip38then
   1312  14ca				   .skipL0150
   1313  14ca				   .L0151		;  if joy0fire  &&  rot = 7 then dx = dx  -  1
   1314  14ca
   1315  14ca		       24 0c		      bit	INPT4
   1316  14cc		       30 08		      BMI	.skipL0151
   1317  14ce				   .condpart40
   1318  14ce		       a5 d7		      LDA	d
   1319  14d0		       c9 07		      CMP	#7
   1320  14d2		       d0 02		      BNE	.skip40then
   1321  14d4				   .condpart41
   1322  14d4		       c6 d9		      DEC	f
   1323  14d6				   .skip40then
   1324  14d6				   .skipL0151
   1325  14d6				   .L0152		;  if joy0fire  &&  rot = 8 then dy = dy  -  1  :  dx = dx  -	1
   1326  14d6
   1327  14d6		       24 0c		      bit	INPT4
   1328  14d8		       30 0a		      BMI	.skipL0152
   1329  14da				   .condpart42
   1330  14da		       a5 d7		      LDA	d
   1331  14dc		       c9 08		      CMP	#8
   1332  14de		       d0 04		      BNE	.skip42then
   1333  14e0				   .condpart43
   1334  14e0		       c6 da		      DEC	g
   1335  14e2		       c6 d9		      DEC	f
   1336  14e4				   .skip42then
   1337  14e4				   .skipL0152
   1338  14e4				   .
   1339  14e4							;
   1340  14e4
   1341  14e4				   .L0153		;  if joy0fire then _Ch0_Sound{0}  =  1  :  _Ch0_Duration  =  2
   1342  14e4
   1343  14e4		       24 0c		      bit	INPT4
   1344  14e6		       30 0a		      BMI	.skipL0153
   1345  14e8				   .condpart44
   1346  14e8		       a5 ea		      LDA	_Ch0_Sound
   1347  14ea		       09 01		      ORA	#1
   1348  14ec		       85 ea		      STA	_Ch0_Sound
   1349  14ee		       a9 02		      LDA	#2
   1350  14f0		       85 eb		      STA	_Ch0_Duration
   1351  14f2				   .skipL0153
   1352  14f2				   .
   1353  14f2							;
   1354  14f2
   1355  14f2				   .L0154		;  if !_Ch0_Sound{0} then goto __Skip_Ch_0
   1356  14f2
   1357  14f2		       a5 ea		      LDA	_Ch0_Sound
   1358  14f4		       4a		      LSR
   1359  14f5		       b0 03		      BCS	.skipL0154
   1360  14f7				   .condpart45
   1361  14f7		       4c 1e 95 	      jmp	.__Skip_Ch_0
   1362  14fa
   1363  14fa				   .skipL0154
   1364  14fa				   .
   1365  14fa							;
   1366  14fa
   1367  14fa				   .L0155		;  _Ch0_Duration  =  _Ch0_Duration  -	1
   1368  14fa
   1369  14fa		       c6 eb		      DEC	_Ch0_Duration
   1370  14fc				   .L0156		;  if _Ch0_Duration  =  0 then goto __Clear_Ch_0
   1371  14fc
   1372  14fc		       a5 eb		      LDA	_Ch0_Duration
   1373  14fe		       c9 00		      CMP	#0
   1374  1500		       d0 03		      BNE	.skipL0156
   1375  1502				   .condpart46
   1376  1502		       4c 14 95 	      jmp	.__Clear_Ch_0
   1377  1505
   1378  1505				   .skipL0156
   1379  1505				   .
   1380  1505							;
   1381  1505
   1382  1505				   .L0157		;  AUDC0  =  2  :  AUDV0  =  8  :  AUDF0  =  25
   1383  1505
   1384  1505		       a9 02		      LDA	#2
   1385  1507		       85 15		      STA	AUDC0
   1386  1509		       a9 08		      LDA	#8
   1387  150b		       85 19		      STA	AUDV0
   1388  150d		       a9 19		      LDA	#25
   1389  150f		       85 17		      STA	AUDF0
   1390  1511				   .
   1391  1511							;
   1392  1511
   1393  1511				   .L0158		;  goto __Skip_Ch_0
   1394  1511
   1395  1511		       4c 1e 95 	      jmp	.__Skip_Ch_0
   1396  1514
   1397  1514				   .
   1398  1514							;
   1399  1514
   1400  1514				   .__Clear_Ch_0
   1401  1514							; __Clear_Ch_0
   1402  1514
   1403  1514				   .L0159		;  _Ch0_Sound{0}  =  0  :  AUDV0  =  0
   1404  1514
   1405  1514		       a5 ea		      LDA	_Ch0_Sound
   1406  1516		       29 fe		      AND	#254
   1407  1518		       85 ea		      STA	_Ch0_Sound
   1408  151a		       a9 00		      LDA	#0
   1409  151c		       85 19		      STA	AUDV0
   1410  151e				   .
   1411  151e							;
   1412  151e
   1413  151e				   .__Skip_Ch_0
   1414  151e							; __Skip_Ch_0
   1415  151e
   1416  151e				   .
   1417  151e							;
   1418  151e
   1419  151e				   .skipRotate
   1420  151e							; skipRotate
   1421  151e
   1422  151e				   .
   1423  151e							;
   1424  151e
   1425  151e				   .L0160		;  if dx  <  2 then temp3  =  temp3  +  1
   1426  151e
   1427  151e		       a5 d9		      LDA	f
   1428  1520		       c9 02		      CMP	#2
   1429  1522		       b0 02		      BCS	.skipL0160
   1430  1524				   .condpart47
   1431  1524		       e6 9e		      INC	temp3
   1432  1526				   .skipL0160
   1433  1526				   .L0161		;  if dx  >  4 then temp3  =  temp3  -  1
   1434  1526
   1435  1526		       a9 04		      LDA	#4
   1436  1528		       c5 d9		      CMP	f
   1437  152a		       b0 02		      BCS	.skipL0161
   1438  152c				   .condpart48
   1439  152c		       c6 9e		      DEC	temp3
   1440  152e				   .skipL0161
   1441  152e				   .L0162		;  if dy  <  2 then temp4  =  temp4  +  1
   1442  152e
   1443  152e		       a5 da		      LDA	g
   1444  1530		       c9 02		      CMP	#2
   1445  1532		       b0 02		      BCS	.skipL0162
   1446  1534				   .condpart49
   1447  1534		       e6 9f		      INC	temp4
   1448  1536				   .skipL0162
   1449  1536				   .L0163		;  if dy  >  4 then temp4  =  temp4  -  1
   1450  1536
   1451  1536		       a9 04		      LDA	#4
   1452  1538		       c5 da		      CMP	g
   1453  153a		       b0 02		      BCS	.skipL0163
   1454  153c				   .condpart50
   1455  153c		       c6 9f		      DEC	temp4
   1456  153e				   .skipL0163
   1457  153e				   .
   1458  153e							;
   1459  153e
   1460  153e				   .L0164		;  _pf_x  =   ( _P1_x	-  14 )   /  4
   1461  153e
   1462  153e							; complex statement detected
   1463  153e		       a5 80		      LDA	_P1_x
   1464  1540		       38		      SEC
   1465  1541		       e9 0e		      SBC	#14
   1466  1543		       4a		      lsr
   1467  1544		       4a		      lsr
   1468  1545		       85 d4		      STA	_pf_x
   1469  1547				   .L0165		;  _pf_y  =   ( _P1_y	-   ( _P1_Height  -  6 )  )   /  8
   1470  1547
   1471  1547							; complex statement detected
   1472  1547		       a5 85		      LDA	_P1_y
   1473  1549		       48		      PHA
   1474  154a		       a9 06		      LDA	#_P1_Height
   1475  154c		       38		      SEC
   1476  154d		       e9 06		      SBC	#6
   1477  154f		       a8		      TAY
   1478  1550		       68		      PLA
   1479  1551		       ba		      TSX
   1480  1552		       94 00		      STY	$00,x
   1481  1554		       38		      SEC
   1482  1555		       f5 00		      SBC	$00,x
   1483  1557		       4a		      lsr
   1484  1558		       4a		      lsr
   1485  1559		       4a		      lsr
   1486  155a		       85 d5		      STA	_pf_y
   1487  155c				   .
   1488  155c							;
   1489  155c
   1490  155c				   .L0166		;  if !collision(playfield,player0) then goto noPlayfieldCollision
   1491  155c
   1492  155c		       24 02		      bit	CXP0FB
   1493  155e		       30 03		      BMI	.skipL0166
   1494  1560				   .condpart51
   1495  1560		       4c c8 95 	      jmp	.noPlayfieldCollision
   1496  1563
   1497  1563				   .skipL0166
   1498  1563				   .
   1499  1563							;
   1500  1563
   1501  1563				   .L0167		;  if !pfread ( _pf_x ,  _pf_y )  then goto noPlayfieldCollision
   1502  1563
   1503  1563		       a5 d4		      LDA	_pf_x
   1504  1565		       a4 d5		      LDY	_pf_y
   1505  1567		       85 ee		      sta	temp7
   1506  1569		       a9 95		      lda	#>(ret_point4-1)
   1507  156b		       48		      pha
   1508  156c		       a9 7e		      lda	#<(ret_point4-1)
   1509  156e		       48		      pha
   1510  156f		       a9 f2		      lda	#>(pfread-1)
   1511  1571		       48		      pha
   1512  1572		       a9 ab		      lda	#<(pfread-1)
   1513  1574		       48		      pha
   1514  1575		       a5 ee		      lda	temp7
   1515  1577		       48		      pha
   1516  1578		       8a		      txa
   1517  1579		       48		      pha
   1518  157a		       a2 04		      ldx	#4
   1519  157c		       4c eb ff 	      jmp	BS_jsr
   1520  157f				   ret_point4
   1521  157f		       f0 03		      BEQ	.skipL0167
   1522  1581				   .condpart52
   1523  1581		       4c c8 95 	      jmp	.noPlayfieldCollision
   1524  1584
   1525  1584				   .skipL0167
   1526  1584				   .
   1527  1584							;
   1528  1584
   1529  1584				   .L0168		;  score  =  score  +	1
   1530  1584
   1531  1584		       f8		      SED
   1532  1585		       18		      CLC
   1533  1586		       a5 95		      LDA	score+2
   1534  1588		       69 01		      ADC	#$01
   1535  158a		       85 95		      STA	score+2
   1536  158c		       a5 94		      LDA	score+1
   1537  158e		       69 00		      ADC	#$00
   1538  1590		       85 94		      STA	score+1
   1539  1592		       a5 93		      LDA	score
   1540  1594		       69 00		      ADC	#$00
   1541  1596		       85 93		      STA	score
   1542  1598		       d8		      CLD
   1543  1599				   .L0169		;  pfpixel _pf_x _pf_y off
   1544  1599
   1545  1599		       a2 01		      LDX	#1
   1546  159b		       a4 d5		      LDY	_pf_y
   1547  159d		       a5 d4		      LDA	_pf_x
   1548  159f		       85 ee		      sta	temp7
   1549  15a1		       a9 95		      lda	#>(ret_point5-1)
   1550  15a3		       48		      pha
   1551  15a4		       a9 b6		      lda	#<(ret_point5-1)
   1552  15a6		       48		      pha
   1553  15a7		       a9 f2		      lda	#>(pfpixel-1)
   1554  15a9		       48		      pha
   1555  15aa		       a9 ba		      lda	#<(pfpixel-1)
   1556  15ac		       48		      pha
   1557  15ad		       a5 ee		      lda	temp7
   1558  15af		       48		      pha
   1559  15b0		       8a		      txa
   1560  15b1		       48		      pha
   1561  15b2		       a2 04		      ldx	#4
   1562  15b4		       4c eb ff 	      jmp	BS_jsr
   1563  15b7				   ret_point5
   1564  15b7				   .L0170		;  diamondsLeft  =  diamondsLeft  -  1
   1565  15b7
   1566  15b7		       c6 de		      DEC	k
   1567  15b9				   .
   1568  15b9							;
   1569  15b9
   1570  15b9				   .L0171		;  if diamondsLeft  <=  0 then isDying  =  0  :  endLevelPause  =  0  :  goto waitforlevelend
   1571  15b9
   1572  15b9		       a9 00		      LDA	#0
   1573  15bb		       c5 de		      CMP	k
   1574  15bd		       90 09		      BCC	.skipL0171
   1575  15bf				   .condpart53
   1576  15bf		       a9 00		      LDA	#0
   1577  15c1		       85 e2		      STA	o
   1578  15c3		       85 df		      STA	l
   1579  15c5		       4c 7a 96 	      jmp	.waitforlevelend
   1580  15c8
   1581  15c8				   .skipL0171
   1582  15c8				   .
   1583  15c8							;
   1584  15c8
   1585  15c8				   .noPlayfieldCollision
   1586  15c8							; noPlayfieldCollision
   1587  15c8
   1588  15c8				   .
   1589  15c8							;
   1590  15c8
   1591  15c8				   .L0172		;  if !collision(player0,player1) then goto noAlienCollision
   1592  15c8
   1593  15c8		       24 07		      bit	CXPPMM
   1594  15ca		       30 03		      BMI	.skipL0172
   1595  15cc				   .condpart54
   1596  15cc		       4c ec 95 	      jmp	.noAlienCollision
   1597  15cf
   1598  15cf				   .skipL0172
   1599  15cf				   .L0173		;  AUDV0  =  0  :  AUDV1  =  0
   1600  15cf
   1601  15cf		       a9 00		      LDA	#0
   1602  15d1		       85 19		      STA	AUDV0
   1603  15d3		       85 1a		      STA	AUDV1
   1604  15d5				   .
   1605  15d5							;
   1606  15d5
   1607  15d5				   .L0174		;  playerLives  =  playerLives  -  1
   1608  15d5
   1609  15d5		       c6 e5		      DEC	r
   1610  15d7				   .L0175		;  pfscore1  =  pfscore1 / 4
   1611  15d7
   1612  15d7		       a5 f2		      LDA	pfscore1
   1613  15d9		       4a		      lsr
   1614  15da		       4a		      lsr
   1615  15db		       85 f2		      STA	pfscore1
   1616  15dd				   .L0176		;  pfscore2  =  %00000000
   1617  15dd
   1618  15dd		       a9 00		      LDA	#%00000000
   1619  15df		       85 f3		      STA	pfscore2
   1620  15e1				   .
   1621  15e1							;
   1622  15e1
   1623  15e1				   .L0177		;  endLevelPause  =  0
   1624  15e1
   1625  15e1		       a9 00		      LDA	#0
   1626  15e3		       85 df		      STA	l
   1627  15e5				   .L0178		;  isDying  =	1
   1628  15e5
   1629  15e5		       a9 01		      LDA	#1
   1630  15e7		       85 e2		      STA	o
   1631  15e9				   .L0179		;  goto waitforlevelend
   1632  15e9
   1633  15e9		       4c 7a 96 	      jmp	.waitforlevelend
   1634  15ec
   1635  15ec				   .
   1636  15ec							;
   1637  15ec
   1638  15ec				   .noAlienCollision
   1639  15ec							; noAlienCollision
   1640  15ec
   1641  15ec				   .
   1642  15ec							;
   1643  15ec
   1644  15ec				   .L0180		;  if !collision(player0,ball) then goto noBallCollision
   1645  15ec
   1646  15ec		       24 02		      bit	CXP0FB
   1647  15ee		       70 03		      BVS	.skipL0180
   1648  15f0				   .condpart55
   1649  15f0		       4c 13 96 	      jmp	.noBallCollision
   1650  15f3
   1651  15f3				   .skipL0180
   1652  15f3				   .L0181		;  if ballActive  =  0 then goto noBallCollision
   1653  15f3
   1654  15f3		       a5 e8		      LDA	u
   1655  15f5		       c9 00		      CMP	#0
   1656  15f7		       d0 03		      BNE	.skipL0181
   1657  15f9				   .condpart56
   1658  15f9		       4c 13 96 	      jmp	.noBallCollision
   1659  15fc
   1660  15fc				   .skipL0181
   1661  15fc				   .
   1662  15fc							;
   1663  15fc
   1664  15fc				   .L0182		;  playerLives  =  playerLives  -  1
   1665  15fc
   1666  15fc		       c6 e5		      DEC	r
   1667  15fe				   .L0183		;  pfscore1  =  pfscore1 / 4
   1668  15fe
   1669  15fe		       a5 f2		      LDA	pfscore1
   1670  1600		       4a		      lsr
   1671  1601		       4a		      lsr
   1672  1602		       85 f2		      STA	pfscore1
   1673  1604				   .L0184		;  pfscore2  =  %00000000
   1674  1604
   1675  1604		       a9 00		      LDA	#%00000000
   1676  1606		       85 f3		      STA	pfscore2
   1677  1608				   .
   1678  1608							;
   1679  1608
   1680  1608				   .L0185		;  endLevelPause  =  0
   1681  1608
   1682  1608		       a9 00		      LDA	#0
   1683  160a		       85 df		      STA	l
   1684  160c				   .L0186		;  isDying  =	1
   1685  160c
   1686  160c		       a9 01		      LDA	#1
   1687  160e		       85 e2		      STA	o
   1688  1610				   .L0187		;  goto waitforlevelend
   1689  1610
   1690  1610		       4c 7a 96 	      jmp	.waitforlevelend
   1691  1613
   1692  1613				   .
   1693  1613							;
   1694  1613
   1695  1613				   .noBallCollision
   1696  1613							; noBallCollision
   1697  1613
   1698  1613				   .L0188		;  if dy  <  1 then dy  =  1
   1699  1613
   1700  1613		       a5 da		      LDA	g
   1701  1615		       c9 01		      CMP	#1
   1702  1617		       b0 04		      BCS	.skipL0188
   1703  1619				   .condpart57
   1704  1619		       a9 01		      LDA	#1
   1705  161b		       85 da		      STA	g
   1706  161d				   .skipL0188
   1707  161d				   .L0189		;  if dx  <  1 then dx  =  1
   1708  161d
   1709  161d		       a5 d9		      LDA	f
   1710  161f		       c9 01		      CMP	#1
   1711  1621		       b0 04		      BCS	.skipL0189
   1712  1623				   .condpart58
   1713  1623		       a9 01		      LDA	#1
   1714  1625		       85 d9		      STA	f
   1715  1627				   .skipL0189
   1716  1627				   .L0190		;  if dy  >  5 then dy  =  5
   1717  1627
   1718  1627		       a9 05		      LDA	#5
   1719  1629		       c5 da		      CMP	g
   1720  162b		       b0 04		      BCS	.skipL0190
   1721  162d				   .condpart59
   1722  162d		       a9 05		      LDA	#5
   1723  162f		       85 da		      STA	g
   1724  1631				   .skipL0190
   1725  1631				   .L0191		;  if dx  >  5 then dx  =  5
   1726  1631
   1727  1631		       a9 05		      LDA	#5
   1728  1633		       c5 d9		      CMP	f
   1729  1635		       b0 04		      BCS	.skipL0191
   1730  1637				   .condpart60
   1731  1637		       a9 05		      LDA	#5
   1732  1639		       85 d9		      STA	f
   1733  163b				   .skipL0191
   1734  163b				   .
   1735  163b							;
   1736  163b
   1737  163b				   .L0192		;  if rot < 1 then rot = 8
   1738  163b
   1739  163b		       a5 d7		      LDA	d
   1740  163d		       c9 01		      CMP	#1
   1741  163f		       b0 04		      BCS	.skipL0192
   1742  1641				   .condpart61
   1743  1641		       a9 08		      LDA	#8
   1744  1643		       85 d7		      STA	d
   1745  1645				   .skipL0192
   1746  1645				   .L0193		;  if rot > 8 then rot = 1
   1747  1645
   1748  1645		       a9 08		      LDA	#8
   1749  1647		       c5 d7		      CMP	d
   1750  1649		       b0 04		      BCS	.skipL0193
   1751  164b				   .condpart62
   1752  164b		       a9 01		      LDA	#1
   1753  164d		       85 d7		      STA	d
   1754  164f				   .skipL0193
   1755  164f				   .
   1756  164f							;
   1757  164f
   1758  164f				   .L0194		;  if _P1_y  <  _P_Edge_Top then dy  =  4
   1759  164f
   1760  164f		       a5 85		      LDA	_P1_y
   1761  1651		       c9 0e		      CMP	#_P_Edge_Top
   1762  1653		       b0 04		      BCS	.skipL0194
   1763  1655				   .condpart63
   1764  1655		       a9 04		      LDA	#4
   1765  1657		       85 da		      STA	g
   1766  1659				   .skipL0194
   1767  1659				   .L0195		;  if _P1_y  >  _P_Edge_Bottom then dy  =  2
   1768  1659
   1769  1659		       a9 4d		      LDA	#_P_Edge_Bottom
   1770  165b		       c5 85		      CMP	_P1_y
   1771  165d		       b0 04		      BCS	.skipL0195
   1772  165f				   .condpart64
   1773  165f		       a9 02		      LDA	#2
   1774  1661		       85 da		      STA	g
   1775  1663				   .skipL0195
   1776  1663				   .L0196		;  if _P1_x  <  _P_Edge_Left then dx  =  4
   1777  1663
   1778  1663		       a5 80		      LDA	_P1_x
   1779  1665		       c9 15		      CMP	#_P_Edge_Left
   1780  1667		       b0 04		      BCS	.skipL0196
   1781  1669				   .condpart65
   1782  1669		       a9 04		      LDA	#4
   1783  166b		       85 d9		      STA	f
   1784  166d				   .skipL0196
   1785  166d				   .L0197		;  if _P1_x  >  _P_Edge_Right then dx	=  2
   1786  166d
   1787  166d		       a9 85		      LDA	#_P_Edge_Right
   1788  166f		       c5 80		      CMP	_P1_x
   1789  1671		       b0 04		      BCS	.skipL0197
   1790  1673				   .condpart66
   1791  1673		       a9 02		      LDA	#2
   1792  1675		       85 d9		      STA	f
   1793  1677				   .skipL0197
   1794  1677				   .
   1795  1677							;
   1796  1677
   1797  1677				   .L0198		;  goto moveAliens
   1798  1677
   1799  1677		       4c 31 97 	      jmp	.moveAliens
   1800  167a
   1801  167a				   .
   1802  167a							;
   1803  167a
   1804  167a				   .waitforlevelend
   1805  167a							; waitforlevelend
   1806  167a
   1807  167a				   .L0199		;  dx	=  3 :	dy  =  3
   1808  167a
   1809  167a		       a9 03		      LDA	#3
   1810  167c		       85 d9		      STA	f
   1811  167e		       85 da		      STA	g
   1812  1680				   .L0200		;  _P1_y  =  _P_Start_Y
   1813  1680
   1814  1680		       a9 32		      LDA	#_P_Start_Y
   1815  1682		       85 85		      STA	_P1_y
   1816  1684				   .L0201		;  _P1_x  =  _P_Start_X
   1817  1684
   1818  1684		       a9 4c		      LDA	#_P_Start_X
   1819  1686		       85 80		      STA	_P1_x
   1820  1688				   .L0202		;  if endLevelPause  >  _End_Level_Pause  &&  isDying	=  0 then _CurrentLevel  =  _CurrentLevel  +  1  :  goto newlevel
   1821  1688
   1822  1688		       a9 78		      LDA	#_End_Level_Pause
   1823  168a		       c5 df		      CMP	l
   1824  168c		       b0 0b		      BCS	.skipL0202
   1825  168e				   .condpart67
   1826  168e		       a5 e2		      LDA	o
   1827  1690		       c9 00		      CMP	#0
   1828  1692		       d0 05		      BNE	.skip67then
   1829  1694				   .condpart68
   1830  1694		       e6 e1		      INC	_CurrentLevel
   1831  1696		       4c 1b 91 	      jmp	.newlevel
   1832  1699
   1833  1699				   .skip67then
   1834  1699				   .skipL0202
   1835  1699				   .L0203		;  if endLevelPause  >  _End_Level_Pause  &&  isDying	=  1 then lives  =  lives  -  1  :  goto newlevel
   1836  1699
   1837  1699		       a9 78		      LDA	#_End_Level_Pause
   1838  169b		       c5 df		      CMP	l
   1839  169d		       b0 0b		      BCS	.skipL0203
   1840  169f				   .condpart69
   1841  169f		       a5 e2		      LDA	o
   1842  16a1		       c9 01		      CMP	#1
   1843  16a3		       d0 05		      BNE	.skip69then
   1844  16a5				   .condpart70
   1845  16a5		       c6 f3		      DEC	lives
   1846  16a7		       4c 1b 91 	      jmp	.newlevel
   1847  16aa
   1848  16aa				   .skip69then
   1849  16aa				   .skipL0203
   1850  16aa				   .
   1851  16aa							;
   1852  16aa
   1853  16aa				   .L0204		;  if isDying	=  0 then score  =  score  +  1
   1854  16aa
   1855  16aa		       a5 e2		      LDA	o
   1856  16ac		       c9 00		      CMP	#0
   1857  16ae		       d0 15		      BNE	.skipL0204
   1858  16b0				   .condpart71
   1859  16b0		       f8		      SED
   1860  16b1		       18		      CLC
   1861  16b2		       a5 95		      LDA	score+2
   1862  16b4		       69 01		      ADC	#$01
   1863  16b6		       85 95		      STA	score+2
   1864  16b8		       a5 94		      LDA	score+1
   1865  16ba		       69 00		      ADC	#$00
   1866  16bc		       85 94		      STA	score+1
   1867  16be		       a5 93		      LDA	score
   1868  16c0		       69 00		      ADC	#$00
   1869  16c2		       85 93		      STA	score
   1870  16c4		       d8		      CLD
   1871  16c5				   .skipL0204
   1872  16c5				   .
   1873  16c5							;
   1874  16c5
   1875  16c5				   .L0205		;  temp1  =   ( _End_Level_Pause  /  5 )
   1876  16c5
   1877  16c5							; complex statement detected
   1878  16c5		       a9 78		      LDA	#_End_Level_Pause
   1879  16c7		       a0 05		      LDY	#5
   1880  16c9		       20 14 90 	      jsr	div8
   1881  16cc		       85 9c		      STA	temp1
   1882  16ce				   .L0206		;  temp2  =  temp1  *	2
   1883  16ce
   1884  16ce		       a5 9c		      LDA	temp1
   1885  16d0		       0a		      asl
   1886  16d1		       85 9d		      STA	temp2
   1887  16d3				   .L0207		;  temp3  =  temp1  *	3
   1888  16d3
   1889  16d3		       a5 9c		      LDA	temp1
   1890  16d5		       0a		      asl
   1891  16d6		       18		      clc
   1892  16d7		       65 9c		      adc	temp1
   1893  16d9		       85 9e		      STA	temp3
   1894  16db				   .L0208		;  temp4  =  temp1  *	4
   1895  16db
   1896  16db		       a5 9c		      LDA	temp1
   1897  16dd		       0a		      asl
   1898  16de		       0a		      asl
   1899  16df		       85 9f		      STA	temp4
   1900  16e1				   .L0209		;  temp5  =  temp1  *	5
   1901  16e1
   1902  16e1		       a5 9c		      LDA	temp1
   1903  16e3		       0a		      asl
   1904  16e4		       0a		      asl
   1905  16e5		       18		      clc
   1906  16e6		       65 9c		      adc	temp1
   1907  16e8		       85 a0		      STA	temp5
   1908  16ea				   .
   1909  16ea							;
   1910  16ea
   1911  16ea				   .L0210		;  endLevelPause  =  endLevelPause  +	1
   1912  16ea
   1913  16ea		       e6 df		      INC	l
   1914  16ec				   .
   1915  16ec							;
   1916  16ec
   1917  16ec				   .L0211		;  if endLevelPause  <  temp1 then COLUP0  =  $2A  :  goto showGraphics
   1918  16ec
   1919  16ec		       a5 df		      LDA	l
   1920  16ee		       c5 9c		      CMP	temp1
   1921  16f0		       b0 07		      BCS	.skipL0211
   1922  16f2				   .condpart72
   1923  16f2		       a9 2a		      LDA	#$2A
   1924  16f4		       85 06		      STA	COLUP0
   1925  16f6		       4c 78 9a 	      jmp	.showGraphics
   1926  16f9
   1927  16f9				   .skipL0211
   1928  16f9				   .L0212		;  if endLevelPause  <  temp2 then COLUP0  =  $26  :  goto showGraphics
   1929  16f9
   1930  16f9		       a5 df		      LDA	l
   1931  16fb		       c5 9d		      CMP	temp2
   1932  16fd		       b0 07		      BCS	.skipL0212
   1933  16ff				   .condpart73
   1934  16ff		       a9 26		      LDA	#$26
   1935  1701		       85 06		      STA	COLUP0
   1936  1703		       4c 78 9a 	      jmp	.showGraphics
   1937  1706
   1938  1706				   .skipL0212
   1939  1706				   .L0213		;  if endLevelPause  <  temp3 then COLUP0  =  $22  :  goto showGraphics
   1940  1706
   1941  1706		       a5 df		      LDA	l
   1942  1708		       c5 9e		      CMP	temp3
   1943  170a		       b0 07		      BCS	.skipL0213
   1944  170c				   .condpart74
   1945  170c		       a9 22		      LDA	#$22
   1946  170e		       85 06		      STA	COLUP0
   1947  1710		       4c 78 9a 	      jmp	.showGraphics
   1948  1713
   1949  1713				   .skipL0213
   1950  1713				   .L0214		;  if endLevelPause  <  temp4 then COLUP0  =  $20  :  goto showGraphics
   1951  1713
   1952  1713		       a5 df		      LDA	l
   1953  1715		       c5 9f		      CMP	temp4
   1954  1717		       b0 07		      BCS	.skipL0214
   1955  1719				   .condpart75
   1956  1719		       a9 20		      LDA	#$20
   1957  171b		       85 06		      STA	COLUP0
   1958  171d		       4c 78 9a 	      jmp	.showGraphics
   1959  1720
   1960  1720				   .skipL0214
   1961  1720				   .L0215		;  if endLevelPause  <  temp5 then COLUP0  =  $00  :  goto showGraphics
   1962  1720
   1963  1720		       a5 df		      LDA	l
   1964  1722		       c5 a0		      CMP	temp5
   1965  1724		       b0 07		      BCS	.skipL0215
   1966  1726				   .condpart76
   1967  1726		       a9 00		      LDA	#$00
   1968  1728		       85 06		      STA	COLUP0
   1969  172a		       4c 78 9a 	      jmp	.showGraphics
   1970  172d
   1971  172d				   .skipL0215
   1972  172d				   .
   1973  172d							;
   1974  172d
   1975  172d				   .L0216		;  temp5  =  1
   1976  172d
   1977  172d		       a9 01		      LDA	#1
   1978  172f		       85 a0		      STA	temp5
   1979  1731				   .moveAliens
   1980  1731							; moveAliens
   1981  1731
   1982  1731				   .
   1983  1731							;
   1984  1731
   1985  1731				   .L0217		;  temp6  =   ( _CurrentLevel	//  5 )
   1986  1731
   1987  1731							; complex statement detected
   1988  1731		       a5 e1		      LDA	_CurrentLevel
   1989  1733		       a0 05		      LDY	#5
   1990  1735		       20 3a 90 	      jsr	div16
   1991  1738		       85 a1		      STA	temp6
   1992  173a				   .L0218		;  temp6  =  temp1
   1993  173a
   1994  173a		       a5 9c		      LDA	temp1
   1995  173c		       85 a1		      STA	temp6
   1996  173e				   .
   1997  173e							;
   1998  173e
   1999  173e				   .L0219		;  if temp6  =  2 then goto alien2
   2000  173e
   2001  173e		       a5 a1		      LDA	temp6
   2002  1740		       c9 02		      CMP	#2
   2003  1742		       d0 03		      BNE	.skipL0219
   2004  1744				   .condpart77
   2005  1744		       4c a7 97 	      jmp	.alien2
   2006  1747
   2007  1747				   .skipL0219
   2008  1747				   .L0220		;  if temp6  =  3 then goto alien3
   2009  1747
   2010  1747		       a5 a1		      LDA	temp6
   2011  1749		       c9 03		      CMP	#3
   2012  174b		       d0 03		      BNE	.skipL0220
   2013  174d				   .condpart78
   2014  174d		       4c ec 97 	      jmp	.alien3
   2015  1750
   2016  1750				   .skipL0220
   2017  1750				   .L0221		;  if temp6  =  4 then goto alien4
   2018  1750
   2019  1750		       a5 a1		      LDA	temp6
   2020  1752		       c9 04		      CMP	#4
   2021  1754		       d0 03		      BNE	.skipL0221
   2022  1756				   .condpart79
   2023  1756		       4c 69 98 	      jmp	.alien4
   2024  1759
   2025  1759				   .skipL0221
   2026  1759				   .L0222		;  if temp6  =  5 then goto alien5
   2027  1759
   2028  1759		       a5 a1		      LDA	temp6
   2029  175b		       c9 05		      CMP	#5
   2030  175d		       d0 03		      BNE	.skipL0222
   2031  175f				   .condpart80
   2032  175f		       4c e6 98 	      jmp	.alien5
   2033  1762
   2034  1762				   .skipL0222
   2035  1762				   .
   2036  1762							;
   2037  1762
   2038  1762				   .L0223		;  temp1  =  rand
   2039  1762
   2040  1762		       a5 a2		      lda	rand
   2041  1764		       4a		      lsr
   2042  1765					      ifconst	rand16
   2043  1765		       26 ed		      rol	rand16
   2044  1767					      endif
   2045  1767		       90 02		      bcc	*+4
   2046  1769		       49 b4		      eor	#$B4
   2047  176b		       85 a2		      sta	rand
   2048  176d					      ifconst	rand16
   2049  176d		       45 ed		      eor	rand16
   2050  176f					      endif
   2051  176f		       85 9c		      STA	temp1
   2052  1771				   .L0224		;  temp2  =  rand
   2053  1771
   2054  1771		       a5 a2		      lda	rand
   2055  1773		       4a		      lsr
   2056  1774					      ifconst	rand16
   2057  1774		       26 ed		      rol	rand16
   2058  1776					      endif
   2059  1776		       90 02		      bcc	*+4
   2060  1778		       49 b4		      eor	#$B4
   2061  177a		       85 a2		      sta	rand
   2062  177c					      ifconst	rand16
   2063  177c		       45 ed		      eor	rand16
   2064  177e					      endif
   2065  177e		       85 9d		      STA	temp2
   2066  1780				   .L0225		;  temp5  =  1
   2067  1780
   2068  1780		       a9 01		      LDA	#1
   2069  1782		       85 a0		      STA	temp5
   2070  1784				   .
   2071  1784							;
   2072  1784
   2073  1784				   .L0226		;  if temp1  <  100 then aX  =  aX  -	1
   2074  1784
   2075  1784		       a5 9c		      LDA	temp1
   2076  1786		       c9 64		      CMP	#100
   2077  1788		       b0 02		      BCS	.skipL0226
   2078  178a				   .condpart81
   2079  178a		       c6 e3		      DEC	p
   2080  178c				   .skipL0226
   2081  178c				   .L0227		;  if temp1  >  156 then aX  =  aX  +	1
   2082  178c
   2083  178c		       a9 9c		      LDA	#156
   2084  178e		       c5 9c		      CMP	temp1
   2085  1790		       b0 02		      BCS	.skipL0227
   2086  1792				   .condpart82
   2087  1792		       e6 e3		      INC	p
   2088  1794				   .skipL0227
   2089  1794				   .
   2090  1794							;
   2091  1794
   2092  1794				   .L0228		;  if temp2  <  100 then aY  =  aY  -	1
   2093  1794
   2094  1794		       a5 9d		      LDA	temp2
   2095  1796		       c9 64		      CMP	#100
   2096  1798		       b0 02		      BCS	.skipL0228
   2097  179a				   .condpart83
   2098  179a		       c6 e4		      DEC	q
   2099  179c				   .skipL0228
   2100  179c				   .L0229		;  if temp2  >  156 then aY  =  aY  +	1
   2101  179c
   2102  179c		       a9 9c		      LDA	#156
   2103  179e		       c5 9d		      CMP	temp2
   2104  17a0		       b0 02		      BCS	.skipL0229
   2105  17a2				   .condpart84
   2106  17a2		       e6 e4		      INC	q
   2107  17a4				   .skipL0229
   2108  17a4				   .
   2109  17a4							;
   2110  17a4
   2111  17a4				   .L0230		;  goto applyAlienMovement
   2112  17a4
   2113  17a4		       4c 09 99 	      jmp	.applyAlienMovement
   2114  17a7
   2115  17a7				   .
   2116  17a7							;
   2117  17a7
   2118  17a7				   .alien2
   2119  17a7							; alien2
   2120  17a7
   2121  17a7				   .
   2122  17a7							;
   2123  17a7
   2124  17a7				   .L0231		;  temp1  =  rand
   2125  17a7
   2126  17a7		       a5 a2		      lda	rand
   2127  17a9		       4a		      lsr
   2128  17aa					      ifconst	rand16
   2129  17aa		       26 ed		      rol	rand16
   2130  17ac					      endif
   2131  17ac		       90 02		      bcc	*+4
   2132  17ae		       49 b4		      eor	#$B4
   2133  17b0		       85 a2		      sta	rand
   2134  17b2					      ifconst	rand16
   2135  17b2		       45 ed		      eor	rand16
   2136  17b4					      endif
   2137  17b4		       85 9c		      STA	temp1
   2138  17b6				   .L0232		;  temp2  =  rand
   2139  17b6
   2140  17b6		       a5 a2		      lda	rand
   2141  17b8		       4a		      lsr
   2142  17b9					      ifconst	rand16
   2143  17b9		       26 ed		      rol	rand16
   2144  17bb					      endif
   2145  17bb		       90 02		      bcc	*+4
   2146  17bd		       49 b4		      eor	#$B4
   2147  17bf		       85 a2		      sta	rand
   2148  17c1					      ifconst	rand16
   2149  17c1		       45 ed		      eor	rand16
   2150  17c3					      endif
   2151  17c3		       85 9d		      STA	temp2
   2152  17c5				   .L0233		;  temp5  =  2
   2153  17c5
   2154  17c5		       a9 02		      LDA	#2
   2155  17c7		       85 a0		      STA	temp5
   2156  17c9				   .
   2157  17c9							;
   2158  17c9
   2159  17c9				   .L0234		;  if temp1  <  100 then aX  =  aX  -	1
   2160  17c9
   2161  17c9		       a5 9c		      LDA	temp1
   2162  17cb		       c9 64		      CMP	#100
   2163  17cd		       b0 02		      BCS	.skipL0234
   2164  17cf				   .condpart85
   2165  17cf		       c6 e3		      DEC	p
   2166  17d1				   .skipL0234
   2167  17d1				   .L0235		;  if temp1  >  156 then aX  =  aX  +	1
   2168  17d1
   2169  17d1		       a9 9c		      LDA	#156
   2170  17d3		       c5 9c		      CMP	temp1
   2171  17d5		       b0 02		      BCS	.skipL0235
   2172  17d7				   .condpart86
   2173  17d7		       e6 e3		      INC	p
   2174  17d9				   .skipL0235
   2175  17d9				   .
   2176  17d9							;
   2177  17d9
   2178  17d9				   .L0236		;  if temp2  <  100 then aY  =  aY  -	1
   2179  17d9
   2180  17d9		       a5 9d		      LDA	temp2
   2181  17db		       c9 64		      CMP	#100
   2182  17dd		       b0 02		      BCS	.skipL0236
   2183  17df				   .condpart87
   2184  17df		       c6 e4		      DEC	q
   2185  17e1				   .skipL0236
   2186  17e1				   .L0237		;  if temp2  >  156 then aY  =  aY  +	1
   2187  17e1
   2188  17e1		       a9 9c		      LDA	#156
   2189  17e3		       c5 9d		      CMP	temp2
   2190  17e5		       b0 02		      BCS	.skipL0237
   2191  17e7				   .condpart88
   2192  17e7		       e6 e4		      INC	q
   2193  17e9				   .skipL0237
   2194  17e9				   .
   2195  17e9							;
   2196  17e9
   2197  17e9				   .L0238		;  goto applyAlienMovement
   2198  17e9
   2199  17e9		       4c 09 99 	      jmp	.applyAlienMovement
   2200  17ec
   2201  17ec				   .
   2202  17ec							;
   2203  17ec
   2204  17ec				   .alien3
   2205  17ec							; alien3
   2206  17ec
   2207  17ec				   .L0239		;  temp1  =  rand
   2208  17ec
   2209  17ec		       a5 a2		      lda	rand
   2210  17ee		       4a		      lsr
   2211  17ef					      ifconst	rand16
   2212  17ef		       26 ed		      rol	rand16
   2213  17f1					      endif
   2214  17f1		       90 02		      bcc	*+4
   2215  17f3		       49 b4		      eor	#$B4
   2216  17f5		       85 a2		      sta	rand
   2217  17f7					      ifconst	rand16
   2218  17f7		       45 ed		      eor	rand16
   2219  17f9					      endif
   2220  17f9		       85 9c		      STA	temp1
   2221  17fb				   .L0240		;  temp2  =  rand
   2222  17fb
   2223  17fb		       a5 a2		      lda	rand
   2224  17fd		       4a		      lsr
   2225  17fe					      ifconst	rand16
   2226  17fe		       26 ed		      rol	rand16
   2227  1800					      endif
   2228  1800		       90 02		      bcc	*+4
   2229  1802		       49 b4		      eor	#$B4
   2230  1804		       85 a2		      sta	rand
   2231  1806					      ifconst	rand16
   2232  1806		       45 ed		      eor	rand16
   2233  1808					      endif
   2234  1808		       85 9d		      STA	temp2
   2235  180a				   .L0241		;  temp5  =  1
   2236  180a
   2237  180a		       a9 01		      LDA	#1
   2238  180c		       85 a0		      STA	temp5
   2239  180e				   .
   2240  180e							;
   2241  180e
   2242  180e				   .L0242		;  if temp1  <  100 then aX  =  aX  -	1
   2243  180e
   2244  180e		       a5 9c		      LDA	temp1
   2245  1810		       c9 64		      CMP	#100
   2246  1812		       b0 02		      BCS	.skipL0242
   2247  1814				   .condpart89
   2248  1814		       c6 e3		      DEC	p
   2249  1816				   .skipL0242
   2250  1816				   .L0243		;  if temp1  >  156 then aX  =  aX  +	1
   2251  1816
   2252  1816		       a9 9c		      LDA	#156
   2253  1818		       c5 9c		      CMP	temp1
   2254  181a		       b0 02		      BCS	.skipL0243
   2255  181c				   .condpart90
   2256  181c		       e6 e3		      INC	p
   2257  181e				   .skipL0243
   2258  181e				   .
   2259  181e							;
   2260  181e
   2261  181e				   .L0244		;  if temp2  <  100 then aY  =  aY  -	1
   2262  181e
   2263  181e		       a5 9d		      LDA	temp2
   2264  1820		       c9 64		      CMP	#100
   2265  1822		       b0 02		      BCS	.skipL0244
   2266  1824				   .condpart91
   2267  1824		       c6 e4		      DEC	q
   2268  1826				   .skipL0244
   2269  1826				   .L0245		;  if temp2  >  156 then aY  =  aY  +	1
   2270  1826
   2271  1826		       a9 9c		      LDA	#156
   2272  1828		       c5 9d		      CMP	temp2
   2273  182a		       b0 02		      BCS	.skipL0245
   2274  182c				   .condpart92
   2275  182c		       e6 e4		      INC	q
   2276  182e				   .skipL0245
   2277  182e				   .
   2278  182e							;
   2279  182e
   2280  182e				   .L0246		;  temp3  =  rand
   2281  182e
   2282  182e		       a5 a2		      lda	rand
   2283  1830		       4a		      lsr
   2284  1831					      ifconst	rand16
   2285  1831		       26 ed		      rol	rand16
   2286  1833					      endif
   2287  1833		       90 02		      bcc	*+4
   2288  1835		       49 b4		      eor	#$B4
   2289  1837		       85 a2		      sta	rand
   2290  1839					      ifconst	rand16
   2291  1839		       45 ed		      eor	rand16
   2292  183b					      endif
   2293  183b		       85 9e		      STA	temp3
   2294  183d				   .L0247		;  if temp3  <  130 then goto applyAlienMovement
   2295  183d
   2296  183d		       a5 9e		      LDA	temp3
   2297  183f		       c9 82		      CMP	#130
   2298  1841		       b0 03		      BCS	.skipL0247
   2299  1843				   .condpart93
   2300  1843		       4c 09 99 	      jmp	.applyAlienMovement
   2301  1846
   2302  1846				   .skipL0247
   2303  1846				   .
   2304  1846							;
   2305  1846
   2306  1846				   .L0248		;  if player0x  <  player1x then aX  =  aX  -	1
   2307  1846
   2308  1846		       a5 80		      LDA	player0x
   2309  1848		       c5 81		      CMP	player1x
   2310  184a		       b0 02		      BCS	.skipL0248
   2311  184c				   .condpart94
   2312  184c		       c6 e3		      DEC	p
   2313  184e				   .skipL0248
   2314  184e				   .L0249		;  if player0x  >  player1x then aX  =  aX  +	1
   2315  184e
   2316  184e		       a5 81		      LDA	player1x
   2317  1850		       c5 80		      CMP	player0x
   2318  1852		       b0 02		      BCS	.skipL0249
   2319  1854				   .condpart95
   2320  1854		       e6 e3		      INC	p
   2321  1856				   .skipL0249
   2322  1856				   .
   2323  1856							;
   2324  1856
   2325  1856				   .L0250		;  if player0y  <  player1y then aY  =  aY  -	1
   2326  1856
   2327  1856		       a5 85		      LDA	player0y
   2328  1858		       c5 86		      CMP	player1y
   2329  185a		       b0 02		      BCS	.skipL0250
   2330  185c				   .condpart96
   2331  185c		       c6 e4		      DEC	q
   2332  185e				   .skipL0250
   2333  185e				   .L0251		;  if player0y  >  player1y then aY  =  aY  +	1
   2334  185e
   2335  185e		       a5 86		      LDA	player1y
   2336  1860		       c5 85		      CMP	player0y
   2337  1862		       b0 02		      BCS	.skipL0251
   2338  1864				   .condpart97
   2339  1864		       e6 e4		      INC	q
   2340  1866				   .skipL0251
   2341  1866				   .
   2342  1866							;
   2343  1866
   2344  1866				   .L0252		;  goto applyAlienMovement
   2345  1866
   2346  1866		       4c 09 99 	      jmp	.applyAlienMovement
   2347  1869
   2348  1869				   .
   2349  1869							;
   2350  1869
   2351  1869				   .alien4
   2352  1869							; alien4
   2353  1869
   2354  1869				   .L0253		;  temp1  =  rand
   2355  1869
   2356  1869		       a5 a2		      lda	rand
   2357  186b		       4a		      lsr
   2358  186c					      ifconst	rand16
   2359  186c		       26 ed		      rol	rand16
   2360  186e					      endif
   2361  186e		       90 02		      bcc	*+4
   2362  1870		       49 b4		      eor	#$B4
   2363  1872		       85 a2		      sta	rand
   2364  1874					      ifconst	rand16
   2365  1874		       45 ed		      eor	rand16
   2366  1876					      endif
   2367  1876		       85 9c		      STA	temp1
   2368  1878				   .L0254		;  temp2  =  rand
   2369  1878
   2370  1878		       a5 a2		      lda	rand
   2371  187a		       4a		      lsr
   2372  187b					      ifconst	rand16
   2373  187b		       26 ed		      rol	rand16
   2374  187d					      endif
   2375  187d		       90 02		      bcc	*+4
   2376  187f		       49 b4		      eor	#$B4
   2377  1881		       85 a2		      sta	rand
   2378  1883					      ifconst	rand16
   2379  1883		       45 ed		      eor	rand16
   2380  1885					      endif
   2381  1885		       85 9d		      STA	temp2
   2382  1887				   .L0255		;  temp5  =  2
   2383  1887
   2384  1887		       a9 02		      LDA	#2
   2385  1889		       85 a0		      STA	temp5
   2386  188b				   .
   2387  188b							;
   2388  188b
   2389  188b				   .L0256		;  if temp1  <  100 then aX  =  aX  -	1
   2390  188b
   2391  188b		       a5 9c		      LDA	temp1
   2392  188d		       c9 64		      CMP	#100
   2393  188f		       b0 02		      BCS	.skipL0256
   2394  1891				   .condpart98
   2395  1891		       c6 e3		      DEC	p
   2396  1893				   .skipL0256
   2397  1893				   .L0257		;  if temp1  >  156 then aX  =  aX  +	1
   2398  1893
   2399  1893		       a9 9c		      LDA	#156
   2400  1895		       c5 9c		      CMP	temp1
   2401  1897		       b0 02		      BCS	.skipL0257
   2402  1899				   .condpart99
   2403  1899		       e6 e3		      INC	p
   2404  189b				   .skipL0257
   2405  189b				   .
   2406  189b							;
   2407  189b
   2408  189b				   .L0258		;  if temp2  <  100 then aY  =  aY  -	1
   2409  189b
   2410  189b		       a5 9d		      LDA	temp2
   2411  189d		       c9 64		      CMP	#100
   2412  189f		       b0 02		      BCS	.skipL0258
   2413  18a1				   .condpart100
   2414  18a1		       c6 e4		      DEC	q
   2415  18a3				   .skipL0258
   2416  18a3				   .L0259		;  if temp2  >  156 then aY  =  aY  +	1
   2417  18a3
   2418  18a3		       a9 9c		      LDA	#156
   2419  18a5		       c5 9d		      CMP	temp2
   2420  18a7		       b0 02		      BCS	.skipL0259
   2421  18a9				   .condpart101
   2422  18a9		       e6 e4		      INC	q
   2423  18ab				   .skipL0259
   2424  18ab				   .
   2425  18ab							;
   2426  18ab
   2427  18ab				   .L0260		;  temp3  =  rand
   2428  18ab
   2429  18ab		       a5 a2		      lda	rand
   2430  18ad		       4a		      lsr
   2431  18ae					      ifconst	rand16
   2432  18ae		       26 ed		      rol	rand16
   2433  18b0					      endif
   2434  18b0		       90 02		      bcc	*+4
   2435  18b2		       49 b4		      eor	#$B4
   2436  18b4		       85 a2		      sta	rand
   2437  18b6					      ifconst	rand16
   2438  18b6		       45 ed		      eor	rand16
   2439  18b8					      endif
   2440  18b8		       85 9e		      STA	temp3
   2441  18ba				   .L0261		;  if temp3  <  130 then goto applyAlienMovement
   2442  18ba
   2443  18ba		       a5 9e		      LDA	temp3
   2444  18bc		       c9 82		      CMP	#130
   2445  18be		       b0 03		      BCS	.skipL0261
   2446  18c0				   .condpart102
   2447  18c0		       4c 09 99 	      jmp	.applyAlienMovement
   2448  18c3
   2449  18c3				   .skipL0261
   2450  18c3				   .
   2451  18c3							;
   2452  18c3
   2453  18c3				   .L0262		;  if player0x  <  player1x then aX  =  aX  -	1
   2454  18c3
   2455  18c3		       a5 80		      LDA	player0x
   2456  18c5		       c5 81		      CMP	player1x
   2457  18c7		       b0 02		      BCS	.skipL0262
   2458  18c9				   .condpart103
   2459  18c9		       c6 e3		      DEC	p
   2460  18cb				   .skipL0262
   2461  18cb				   .L0263		;  if player0x  >  player1x then aX  =  aX  +	1
   2462  18cb
   2463  18cb		       a5 81		      LDA	player1x
   2464  18cd		       c5 80		      CMP	player0x
   2465  18cf		       b0 02		      BCS	.skipL0263
   2466  18d1				   .condpart104
   2467  18d1		       e6 e3		      INC	p
   2468  18d3				   .skipL0263
   2469  18d3				   .
   2470  18d3							;
   2471  18d3
   2472  18d3				   .L0264		;  if player0y  <  player1y then aY  =  aY  -	1
   2473  18d3
   2474  18d3		       a5 85		      LDA	player0y
   2475  18d5		       c5 86		      CMP	player1y
   2476  18d7		       b0 02		      BCS	.skipL0264
   2477  18d9				   .condpart105
   2478  18d9		       c6 e4		      DEC	q
   2479  18db				   .skipL0264
   2480  18db				   .L0265		;  if player0y  >  player1y then aY  =  aY  +	1
   2481  18db
   2482  18db		       a5 86		      LDA	player1y
   2483  18dd		       c5 85		      CMP	player0y
   2484  18df		       b0 02		      BCS	.skipL0265
   2485  18e1				   .condpart106
   2486  18e1		       e6 e4		      INC	q
   2487  18e3				   .skipL0265
   2488  18e3				   .
   2489  18e3							;
   2490  18e3
   2491  18e3				   .L0266		;  goto applyAlienMovement
   2492  18e3
   2493  18e3		       4c 09 99 	      jmp	.applyAlienMovement
   2494  18e6
   2495  18e6				   .
   2496  18e6							;
   2497  18e6
   2498  18e6				   .alien5
   2499  18e6							; alien5
   2500  18e6
   2501  18e6				   .L0267		;  if player0x  <  player1x then aX  =  aX  -	1
   2502  18e6
   2503  18e6		       a5 80		      LDA	player0x
   2504  18e8		       c5 81		      CMP	player1x
   2505  18ea		       b0 02		      BCS	.skipL0267
   2506  18ec				   .condpart107
   2507  18ec		       c6 e3		      DEC	p
   2508  18ee				   .skipL0267
   2509  18ee				   .L0268		;  if player0x  >  player1x then aX  =  aX  +	1
   2510  18ee
   2511  18ee		       a5 81		      LDA	player1x
   2512  18f0		       c5 80		      CMP	player0x
   2513  18f2		       b0 02		      BCS	.skipL0268
   2514  18f4				   .condpart108
   2515  18f4		       e6 e3		      INC	p
   2516  18f6				   .skipL0268
   2517  18f6				   .
   2518  18f6							;
   2519  18f6
   2520  18f6				   .L0269		;  if player0y  <  player1y then aY  =  aY  -	1
   2521  18f6
   2522  18f6		       a5 85		      LDA	player0y
   2523  18f8		       c5 86		      CMP	player1y
   2524  18fa		       b0 02		      BCS	.skipL0269
   2525  18fc				   .condpart109
   2526  18fc		       c6 e4		      DEC	q
   2527  18fe				   .skipL0269
   2528  18fe				   .L0270		;  if player0y  >  player1y then aY  =  aY  +	1
   2529  18fe
   2530  18fe		       a5 86		      LDA	player1y
   2531  1900		       c5 85		      CMP	player0y
   2532  1902		       b0 02		      BCS	.skipL0270
   2533  1904				   .condpart110
   2534  1904		       e6 e4		      INC	q
   2535  1906				   .skipL0270
   2536  1906				   .
   2537  1906							;
   2538  1906
   2539  1906				   .L0271		;  goto applyAlienMovement
   2540  1906
   2541  1906		       4c 09 99 	      jmp	.applyAlienMovement
   2542  1909
   2543  1909				   .
   2544  1909							;
   2545  1909
   2546  1909				   .
   2547  1909							;
   2548  1909
   2549  1909				   .applyAlienMovement
   2550  1909							; applyAlienMovement
   2551  1909
   2552  1909				   .L0272		;  if aX  <  2 then aX  =  2
   2553  1909
   2554  1909		       a5 e3		      LDA	p
   2555  190b		       c9 02		      CMP	#2
   2556  190d		       b0 04		      BCS	.skipL0272
   2557  190f				   .condpart111
   2558  190f		       a9 02		      LDA	#2
   2559  1911		       85 e3		      STA	p
   2560  1913				   .skipL0272
   2561  1913				   .L0273		;  if aX  >  4 then aX  =  4
   2562  1913
   2563  1913		       a9 04		      LDA	#4
   2564  1915		       c5 e3		      CMP	p
   2565  1917		       b0 04		      BCS	.skipL0273
   2566  1919				   .condpart112
   2567  1919		       a9 04		      LDA	#4
   2568  191b		       85 e3		      STA	p
   2569  191d				   .skipL0273
   2570  191d				   .L0274		;  if aY  <  2 then aY  =  2
   2571  191d
   2572  191d		       a5 e4		      LDA	q
   2573  191f		       c9 02		      CMP	#2
   2574  1921		       b0 04		      BCS	.skipL0274
   2575  1923				   .condpart113
   2576  1923		       a9 02		      LDA	#2
   2577  1925		       85 e4		      STA	q
   2578  1927				   .skipL0274
   2579  1927				   .L0275		;  if aY  >  4 then aY  =  4
   2580  1927
   2581  1927		       a9 04		      LDA	#4
   2582  1929		       c5 e4		      CMP	q
   2583  192b		       b0 04		      BCS	.skipL0275
   2584  192d				   .condpart114
   2585  192d		       a9 04		      LDA	#4
   2586  192f		       85 e4		      STA	q
   2587  1931				   .skipL0275
   2588  1931				   .
   2589  1931							;
   2590  1931
   2591  1931				   .L0276		;  if player1y  <  _P_Edge_Top then aY  =  4
   2592  1931
   2593  1931		       a5 86		      LDA	player1y
   2594  1933		       c9 0e		      CMP	#_P_Edge_Top
   2595  1935		       b0 04		      BCS	.skipL0276
   2596  1937				   .condpart115
   2597  1937		       a9 04		      LDA	#4
   2598  1939		       85 e4		      STA	q
   2599  193b				   .skipL0276
   2600  193b				   .L0277		;  if player1y  >  _P_Edge_Bottom then aY  =  2
   2601  193b
   2602  193b		       a9 4d		      LDA	#_P_Edge_Bottom
   2603  193d		       c5 86		      CMP	player1y
   2604  193f		       b0 04		      BCS	.skipL0277
   2605  1941				   .condpart116
   2606  1941		       a9 02		      LDA	#2
   2607  1943		       85 e4		      STA	q
   2608  1945				   .skipL0277
   2609  1945				   .L0278		;  if player1x  <  _P_Edge_Left then aX  =  4
   2610  1945
   2611  1945		       a5 81		      LDA	player1x
   2612  1947		       c9 15		      CMP	#_P_Edge_Left
   2613  1949		       b0 04		      BCS	.skipL0278
   2614  194b				   .condpart117
   2615  194b		       a9 04		      LDA	#4
   2616  194d		       85 e3		      STA	p
   2617  194f				   .skipL0278
   2618  194f				   .L0279		;  if player1x  >  _P_Edge_Right then aX  =  2
   2619  194f
   2620  194f		       a9 85		      LDA	#_P_Edge_Right
   2621  1951		       c5 81		      CMP	player1x
   2622  1953		       b0 04		      BCS	.skipL0279
   2623  1955				   .condpart118
   2624  1955		       a9 02		      LDA	#2
   2625  1957		       85 e3		      STA	p
   2626  1959				   .skipL0279
   2627  1959				   .
   2628  1959							;
   2629  1959
   2630  1959				   .L0280		;  if aX  <  3 then player1x  =  player1x  -  temp5
   2631  1959
   2632  1959		       a5 e3		      LDA	p
   2633  195b		       c9 03		      CMP	#3
   2634  195d		       b0 07		      BCS	.skipL0280
   2635  195f				   .condpart119
   2636  195f		       a5 81		      LDA	player1x
   2637  1961		       38		      SEC
   2638  1962		       e5 a0		      SBC	temp5
   2639  1964		       85 81		      STA	player1x
   2640  1966				   .skipL0280
   2641  1966				   .L0281		;  if aX  >  3 then player1x  =  player1x  +  temp5
   2642  1966
   2643  1966		       a9 03		      LDA	#3
   2644  1968		       c5 e3		      CMP	p
   2645  196a		       b0 07		      BCS	.skipL0281
   2646  196c				   .condpart120
   2647  196c		       a5 81		      LDA	player1x
   2648  196e		       18		      CLC
   2649  196f		       65 a0		      ADC	temp5
   2650  1971		       85 81		      STA	player1x
   2651  1973				   .skipL0281
   2652  1973				   .L0282		;  if aY  <  3 then player1y  =  player1y  -  temp5
   2653  1973
   2654  1973		       a5 e4		      LDA	q
   2655  1975		       c9 03		      CMP	#3
   2656  1977		       b0 07		      BCS	.skipL0282
   2657  1979				   .condpart121
   2658  1979		       a5 86		      LDA	player1y
   2659  197b		       38		      SEC
   2660  197c		       e5 a0		      SBC	temp5
   2661  197e		       85 86		      STA	player1y
   2662  1980				   .skipL0282
   2663  1980				   .L0283		;  if aY  >  3 then player1y  =  player1y  +  temp5
   2664  1980
   2665  1980		       a9 03		      LDA	#3
   2666  1982		       c5 e4		      CMP	q
   2667  1984		       b0 07		      BCS	.skipL0283
   2668  1986				   .condpart122
   2669  1986		       a5 86		      LDA	player1y
   2670  1988		       18		      CLC
   2671  1989		       65 a0		      ADC	temp5
   2672  198b		       85 86		      STA	player1y
   2673  198d				   .skipL0283
   2674  198d				   .
   2675  198d							;
   2676  198d
   2677  198d				   .ballMovement
   2678  198d							; ballMovement
   2679  198d
   2680  198d				   .L0284		;  if ballActive  =  0 then ballx  =  200  :  bally  =  200
   2681  198d
   2682  198d		       a5 e8		      LDA	u
   2683  198f		       c9 00		      CMP	#0
   2684  1991		       d0 06		      BNE	.skipL0284
   2685  1993				   .condpart123
   2686  1993		       a9 c8		      LDA	#200
   2687  1995		       85 84		      STA	ballx
   2688  1997		       85 89		      STA	bally
   2689  1999				   .skipL0284
   2690  1999				   .L0285		;  if ballActive  =  0 then goto showGraphics
   2691  1999
   2692  1999		       a5 e8		      LDA	u
   2693  199b		       c9 00		      CMP	#0
   2694  199d		       d0 03		      BNE	.skipL0285
   2695  199f				   .condpart124
   2696  199f		       4c 78 9a 	      jmp	.showGraphics
   2697  19a2
   2698  19a2				   .skipL0285
   2699  19a2				   .
   2700  19a2							;
   2701  19a2
   2702  19a2				   .L0286		;  temp1  =  rand
   2703  19a2
   2704  19a2		       a5 a2		      lda	rand
   2705  19a4		       4a		      lsr
   2706  19a5					      ifconst	rand16
   2707  19a5		       26 ed		      rol	rand16
   2708  19a7					      endif
   2709  19a7		       90 02		      bcc	*+4
   2710  19a9		       49 b4		      eor	#$B4
   2711  19ab		       85 a2		      sta	rand
   2712  19ad					      ifconst	rand16
   2713  19ad		       45 ed		      eor	rand16
   2714  19af					      endif
   2715  19af		       85 9c		      STA	temp1
   2716  19b1				   .L0287		;  temp2  =  rand
   2717  19b1
   2718  19b1		       a5 a2		      lda	rand
   2719  19b3		       4a		      lsr
   2720  19b4					      ifconst	rand16
   2721  19b4		       26 ed		      rol	rand16
   2722  19b6					      endif
   2723  19b6		       90 02		      bcc	*+4
   2724  19b8		       49 b4		      eor	#$B4
   2725  19ba		       85 a2		      sta	rand
   2726  19bc					      ifconst	rand16
   2727  19bc		       45 ed		      eor	rand16
   2728  19be					      endif
   2729  19be		       85 9d		      STA	temp2
   2730  19c0				   .L0288		;  temp5  =  1
   2731  19c0
   2732  19c0		       a9 01		      LDA	#1
   2733  19c2		       85 a0		      STA	temp5
   2734  19c4				   .
   2735  19c4							;
   2736  19c4
   2737  19c4				   .L0289		;  if temp1  <  100 then bX  =  bX  -	1
   2738  19c4
   2739  19c4		       a5 9c		      LDA	temp1
   2740  19c6		       c9 64		      CMP	#100
   2741  19c8		       b0 02		      BCS	.skipL0289
   2742  19ca				   .condpart125
   2743  19ca		       c6 e6		      DEC	s
   2744  19cc				   .skipL0289
   2745  19cc				   .L0290		;  if temp1  >  156 then bX  =  bX  +	1
   2746  19cc
   2747  19cc		       a9 9c		      LDA	#156
   2748  19ce		       c5 9c		      CMP	temp1
   2749  19d0		       b0 02		      BCS	.skipL0290
   2750  19d2				   .condpart126
   2751  19d2		       e6 e6		      INC	s
   2752  19d4				   .skipL0290
   2753  19d4				   .
   2754  19d4							;
   2755  19d4
   2756  19d4				   .L0291		;  if temp2  <  100 then bY  =  bY  -	1
   2757  19d4
   2758  19d4		       a5 9d		      LDA	temp2
   2759  19d6		       c9 64		      CMP	#100
   2760  19d8		       b0 02		      BCS	.skipL0291
   2761  19da				   .condpart127
   2762  19da		       c6 e7		      DEC	t
   2763  19dc				   .skipL0291
   2764  19dc				   .L0292		;  if temp2  >  156 then bY  =  bY  +	1
   2765  19dc
   2766  19dc		       a9 9c		      LDA	#156
   2767  19de		       c5 9d		      CMP	temp2
   2768  19e0		       b0 02		      BCS	.skipL0292
   2769  19e2				   .condpart128
   2770  19e2		       e6 e7		      INC	t
   2771  19e4				   .skipL0292
   2772  19e4				   .
   2773  19e4							;
   2774  19e4
   2775  19e4				   .L0293		;  temp3  =  rand
   2776  19e4
   2777  19e4		       a5 a2		      lda	rand
   2778  19e6		       4a		      lsr
   2779  19e7					      ifconst	rand16
   2780  19e7		       26 ed		      rol	rand16
   2781  19e9					      endif
   2782  19e9		       90 02		      bcc	*+4
   2783  19eb		       49 b4		      eor	#$B4
   2784  19ed		       85 a2		      sta	rand
   2785  19ef					      ifconst	rand16
   2786  19ef		       45 ed		      eor	rand16
   2787  19f1					      endif
   2788  19f1		       85 9e		      STA	temp3
   2789  19f3				   .L0294		;  if temp3  <  130 then goto applyBallMovement
   2790  19f3
   2791  19f3		       a5 9e		      LDA	temp3
   2792  19f5		       c9 82		      CMP	#130
   2793  19f7		       b0 03		      BCS	.skipL0294
   2794  19f9				   .condpart129
   2795  19f9		       4c 1c 9a 	      jmp	.applyBallMovement
   2796  19fc
   2797  19fc				   .skipL0294
   2798  19fc				   .
   2799  19fc							;
   2800  19fc
   2801  19fc				   .L0295		;  if player0x  <  ballx then bX  =  bX  -  1
   2802  19fc
   2803  19fc		       a5 80		      LDA	player0x
   2804  19fe		       c5 84		      CMP	ballx
   2805  1a00		       b0 02		      BCS	.skipL0295
   2806  1a02				   .condpart130
   2807  1a02		       c6 e6		      DEC	s
   2808  1a04				   .skipL0295
   2809  1a04				   .L0296		;  if player0x  >  ballx then bX  =  bX  +  1
   2810  1a04
   2811  1a04		       a5 84		      LDA	ballx
   2812  1a06		       c5 80		      CMP	player0x
   2813  1a08		       b0 02		      BCS	.skipL0296
   2814  1a0a				   .condpart131
   2815  1a0a		       e6 e6		      INC	s
   2816  1a0c				   .skipL0296
   2817  1a0c				   .
   2818  1a0c							;
   2819  1a0c
   2820  1a0c				   .L0297		;  if player0y  <  bally then bY  =  bY  -  1
   2821  1a0c
   2822  1a0c		       a5 85		      LDA	player0y
   2823  1a0e		       c5 89		      CMP	bally
   2824  1a10		       b0 02		      BCS	.skipL0297
   2825  1a12				   .condpart132
   2826  1a12		       c6 e7		      DEC	t
   2827  1a14				   .skipL0297
   2828  1a14				   .L0298		;  if player0y  >  bally then bY  =  bY  +  1
   2829  1a14
   2830  1a14		       a5 89		      LDA	bally
   2831  1a16		       c5 85		      CMP	player0y
   2832  1a18		       b0 02		      BCS	.skipL0298
   2833  1a1a				   .condpart133
   2834  1a1a		       e6 e7		      INC	t
   2835  1a1c				   .skipL0298
   2836  1a1c				   .
   2837  1a1c							;
   2838  1a1c
   2839  1a1c				   .applyBallMovement
   2840  1a1c							; applyBallMovement
   2841  1a1c
   2842  1a1c				   .
   2843  1a1c							;
   2844  1a1c
   2845  1a1c				   .L0299		;  if bX  <  3 then ballx  =  ballx  -  temp5
   2846  1a1c
   2847  1a1c		       a5 e6		      LDA	s
   2848  1a1e		       c9 03		      CMP	#3
   2849  1a20		       b0 07		      BCS	.skipL0299
   2850  1a22				   .condpart134
   2851  1a22		       a5 84		      LDA	ballx
   2852  1a24		       38		      SEC
   2853  1a25		       e5 a0		      SBC	temp5
   2854  1a27		       85 84		      STA	ballx
   2855  1a29				   .skipL0299
   2856  1a29				   .L0300		;  if bX  >  3 then ballx  =  ballx  +  temp5
   2857  1a29
   2858  1a29		       a9 03		      LDA	#3
   2859  1a2b		       c5 e6		      CMP	s
   2860  1a2d		       b0 07		      BCS	.skipL0300
   2861  1a2f				   .condpart135
   2862  1a2f		       a5 84		      LDA	ballx
   2863  1a31		       18		      CLC
   2864  1a32		       65 a0		      ADC	temp5
   2865  1a34		       85 84		      STA	ballx
   2866  1a36				   .skipL0300
   2867  1a36				   .L0301		;  if bY  <  3 then bally  =  bally  -  temp5
   2868  1a36
   2869  1a36		       a5 e7		      LDA	t
   2870  1a38		       c9 03		      CMP	#3
   2871  1a3a		       b0 07		      BCS	.skipL0301
   2872  1a3c				   .condpart136
   2873  1a3c		       a5 89		      LDA	bally
   2874  1a3e		       38		      SEC
   2875  1a3f		       e5 a0		      SBC	temp5
   2876  1a41		       85 89		      STA	bally
   2877  1a43				   .skipL0301
   2878  1a43				   .L0302		;  if bY  >  3 then bally  =  bally  +  temp5
   2879  1a43
   2880  1a43		       a9 03		      LDA	#3
   2881  1a45		       c5 e7		      CMP	t
   2882  1a47		       b0 07		      BCS	.skipL0302
   2883  1a49				   .condpart137
   2884  1a49		       a5 89		      LDA	bally
   2885  1a4b		       18		      CLC
   2886  1a4c		       65 a0		      ADC	temp5
   2887  1a4e		       85 89		      STA	bally
   2888  1a50				   .skipL0302
   2889  1a50				   .
   2890  1a50							;
   2891  1a50
   2892  1a50				   .L0303		;  if ballx  <  _P_Edge_Top then aY  =  4
   2893  1a50
   2894  1a50		       a5 84		      LDA	ballx
   2895  1a52		       c9 0e		      CMP	#_P_Edge_Top
   2896  1a54		       b0 04		      BCS	.skipL0303
   2897  1a56				   .condpart138
   2898  1a56		       a9 04		      LDA	#4
   2899  1a58		       85 e4		      STA	q
   2900  1a5a				   .skipL0303
   2901  1a5a				   .L0304		;  if bally  >  _P_Edge_Bottom then aY  =  2
   2902  1a5a
   2903  1a5a		       a9 4d		      LDA	#_P_Edge_Bottom
   2904  1a5c		       c5 89		      CMP	bally
   2905  1a5e		       b0 04		      BCS	.skipL0304
   2906  1a60				   .condpart139
   2907  1a60		       a9 02		      LDA	#2
   2908  1a62		       85 e4		      STA	q
   2909  1a64				   .skipL0304
   2910  1a64				   .L0305		;  if ballx  <  _P_Edge_Left then aX  =  4
   2911  1a64
   2912  1a64		       a5 84		      LDA	ballx
   2913  1a66		       c9 15		      CMP	#_P_Edge_Left
   2914  1a68		       b0 04		      BCS	.skipL0305
   2915  1a6a				   .condpart140
   2916  1a6a		       a9 04		      LDA	#4
   2917  1a6c		       85 e3		      STA	p
   2918  1a6e				   .skipL0305
   2919  1a6e				   .L0306		;  if bally  >  _P_Edge_Right then aX	=  2
   2920  1a6e
   2921  1a6e		       a9 85		      LDA	#_P_Edge_Right
   2922  1a70		       c5 89		      CMP	bally
   2923  1a72		       b0 04		      BCS	.skipL0306
   2924  1a74				   .condpart141
   2925  1a74		       a9 02		      LDA	#2
   2926  1a76		       85 e3		      STA	p
   2927  1a78				   .skipL0306
   2928  1a78				   .
   2929  1a78							;
   2930  1a78
   2931  1a78				   .showGraphics
   2932  1a78							; showGraphics
   2933  1a78
   2934  1a78				   .
   2935  1a78							;
   2936  1a78
   2937  1a78				   .L0307		;  rem ------------------------------------------------------------------
   2938  1a78
   2939  1a78				   .L0308		;  rem Player Animation
   2940  1a78
   2941  1a78				   .L0309		;  rem   Y is the counter for the player animation.  You can change the
   2942  1a78
   2943  1a78				   .L0310		;  rem   animation rate by changing the 30,20,10 to a different 
   2944  1a78
   2945  1a78				   .L0311		;  rem   sequence of numbers.
   2946  1a78
   2947  1a78				   .L0312		;  rem ------------------------------------------------------------------
   2948  1a78
   2949  1a78				   .
   2950  1a78							;
   2951  1a78
   2952  1a78				   .L0313		;  if dx  <  3 then _P1_x  =  _P1_x  -   ( 3  -  dx )
   2953  1a78
   2954  1a78		       a5 d9		      LDA	f
   2955  1a7a		       c9 03		      CMP	#3
   2956  1a7c		       b0 12		      BCS	.skipL0313
   2957  1a7e				   .condpart142
   2958  1a7e							; complex statement detected
   2959  1a7e		       a5 80		      LDA	_P1_x
   2960  1a80		       48		      PHA
   2961  1a81		       a9 03		      LDA	#3
   2962  1a83		       38		      SEC
   2963  1a84		       e5 d9		      SBC	f
   2964  1a86		       a8		      TAY
   2965  1a87		       68		      PLA
   2966  1a88		       ba		      TSX
   2967  1a89		       94 00		      STY	$00,x
   2968  1a8b		       38		      SEC
   2969  1a8c		       f5 00		      SBC	$00,x
   2970  1a8e		       85 80		      STA	_P1_x
   2971  1a90				   .skipL0313
   2972  1a90				   .L0314		;  if dx  >  3 then _P1_x  =  _P1_x  +  dx  -	3
   2973  1a90
   2974  1a90		       a9 03		      LDA	#3
   2975  1a92		       c5 d9		      CMP	f
   2976  1a94		       b0 0a		      BCS	.skipL0314
   2977  1a96				   .condpart143
   2978  1a96							; complex statement detected
   2979  1a96		       a5 80		      LDA	_P1_x
   2980  1a98		       18		      CLC
   2981  1a99		       65 d9		      ADC	f
   2982  1a9b		       38		      SEC
   2983  1a9c		       e9 03		      SBC	#3
   2984  1a9e		       85 80		      STA	_P1_x
   2985  1aa0				   .skipL0314
   2986  1aa0				   .L0315		;  if dy  <  3 then _P1_y  =  _P1_y  -   ( 3  -  dy )
   2987  1aa0
   2988  1aa0		       a5 da		      LDA	g
   2989  1aa2		       c9 03		      CMP	#3
   2990  1aa4		       b0 12		      BCS	.skipL0315
   2991  1aa6				   .condpart144
   2992  1aa6							; complex statement detected
   2993  1aa6		       a5 85		      LDA	_P1_y
   2994  1aa8		       48		      PHA
   2995  1aa9		       a9 03		      LDA	#3
   2996  1aab		       38		      SEC
   2997  1aac		       e5 da		      SBC	g
   2998  1aae		       a8		      TAY
   2999  1aaf		       68		      PLA
   3000  1ab0		       ba		      TSX
   3001  1ab1		       94 00		      STY	$00,x
   3002  1ab3		       38		      SEC
   3003  1ab4		       f5 00		      SBC	$00,x
   3004  1ab6		       85 85		      STA	_P1_y
   3005  1ab8				   .skipL0315
   3006  1ab8				   .L0316		;  if dy  >  3 then _P1_y  =  _P1_y  +  dy  -	3
   3007  1ab8
   3008  1ab8		       a9 03		      LDA	#3
   3009  1aba		       c5 da		      CMP	g
   3010  1abc		       b0 0a		      BCS	.skipL0316
   3011  1abe				   .condpart145
   3012  1abe							; complex statement detected
   3013  1abe		       a5 85		      LDA	_P1_y
   3014  1ac0		       18		      CLC
   3015  1ac1		       65 da		      ADC	g
   3016  1ac3		       38		      SEC
   3017  1ac4		       e9 03		      SBC	#3
   3018  1ac6		       85 85		      STA	_P1_y
   3019  1ac8				   .skipL0316
   3020  1ac8				   .
   3021  1ac8							;
   3022  1ac8
   3023  1ac8				   .L0317		;  if rot = 1 then player0: 
   3024  1ac8
   3025  1ac8		       a5 d7		      LDA	d
   3026  1aca		       c9 01		      CMP	#1
   3027  1acc		       d0 0c		      BNE	.skipL0317
   3028  1ace				   .condpart146
   3029  1ace		       a2 84		      LDX	#<player146then_0
   3030  1ad0		       86 8a		      STX	player0pointerlo
   3031  1ad2		       a9 f5		      LDA	#>player146then_0
   3032  1ad4		       85 8b		      STA	player0pointerhi
   3033  1ad6		       a9 04		      LDA	#4
   3034  1ad8		       85 8e		      STA	player0height
   3035  1ada				   .skipL0317
   3036  1ada				   .
   3037  1ada							;
   3038  1ada
   3039  1ada				   .L0318		;  if rot = 2 then player0:
   3040  1ada
   3041  1ada		       a5 d7		      LDA	d
   3042  1adc		       c9 02		      CMP	#2
   3043  1ade		       d0 0c		      BNE	.skipL0318
   3044  1ae0				   .condpart147
   3045  1ae0		       a2 89		      LDX	#<player147then_0
   3046  1ae2		       86 8a		      STX	player0pointerlo
   3047  1ae4		       a9 f5		      LDA	#>player147then_0
   3048  1ae6		       85 8b		      STA	player0pointerhi
   3049  1ae8		       a9 04		      LDA	#4
   3050  1aea		       85 8e		      STA	player0height
   3051  1aec				   .skipL0318
   3052  1aec				   .
   3053  1aec							;
   3054  1aec
   3055  1aec				   .L0319		;  if rot = 3 then player0:
   3056  1aec
   3057  1aec		       a5 d7		      LDA	d
   3058  1aee		       c9 03		      CMP	#3
   3059  1af0		       d0 0c		      BNE	.skipL0319
   3060  1af2				   .condpart148
   3061  1af2		       a2 8e		      LDX	#<player148then_0
   3062  1af4		       86 8a		      STX	player0pointerlo
   3063  1af6		       a9 f5		      LDA	#>player148then_0
   3064  1af8		       85 8b		      STA	player0pointerhi
   3065  1afa		       a9 05		      LDA	#5
   3066  1afc		       85 8e		      STA	player0height
   3067  1afe				   .skipL0319
   3068  1afe				   .
   3069  1afe							;
   3070  1afe
   3071  1afe				   .L0320		;  if rot = 4 then player0:  
   3072  1afe
   3073  1afe		       a5 d7		      LDA	d
   3074  1b00		       c9 04		      CMP	#4
   3075  1b02		       d0 0c		      BNE	.skipL0320
   3076  1b04				   .condpart149
   3077  1b04		       a2 94		      LDX	#<player149then_0
   3078  1b06		       86 8a		      STX	player0pointerlo
   3079  1b08		       a9 f5		      LDA	#>player149then_0
   3080  1b0a		       85 8b		      STA	player0pointerhi
   3081  1b0c		       a9 04		      LDA	#4
   3082  1b0e		       85 8e		      STA	player0height
   3083  1b10				   .skipL0320
   3084  1b10				   .
   3085  1b10							;
   3086  1b10
   3087  1b10				   .L0321		;  if rot = 5 then player0:
   3088  1b10
   3089  1b10		       a5 d7		      LDA	d
   3090  1b12		       c9 05		      CMP	#5
   3091  1b14		       d0 0c		      BNE	.skipL0321
   3092  1b16				   .condpart150
   3093  1b16		       a2 99		      LDX	#<player150then_0
   3094  1b18		       86 8a		      STX	player0pointerlo
   3095  1b1a		       a9 f5		      LDA	#>player150then_0
   3096  1b1c		       85 8b		      STA	player0pointerhi
   3097  1b1e		       a9 04		      LDA	#4
   3098  1b20		       85 8e		      STA	player0height
   3099  1b22				   .skipL0321
   3100  1b22				   .
   3101  1b22							;
   3102  1b22
   3103  1b22				   .L0322		;  if rot = 6 then player0:
   3104  1b22
   3105  1b22		       a5 d7		      LDA	d
   3106  1b24		       c9 06		      CMP	#6
   3107  1b26		       d0 0c		      BNE	.skipL0322
   3108  1b28				   .condpart151
   3109  1b28		       a2 9e		      LDX	#<player151then_0
   3110  1b2a		       86 8a		      STX	player0pointerlo
   3111  1b2c		       a9 f5		      LDA	#>player151then_0
   3112  1b2e		       85 8b		      STA	player0pointerhi
   3113  1b30		       a9 04		      LDA	#4
   3114  1b32		       85 8e		      STA	player0height
   3115  1b34				   .skipL0322
   3116  1b34				   .
   3117  1b34							;
   3118  1b34
   3119  1b34				   .L0323		;  if rot = 7 then player0:
   3120  1b34
   3121  1b34		       a5 d7		      LDA	d
   3122  1b36		       c9 07		      CMP	#7
   3123  1b38		       d0 0c		      BNE	.skipL0323
   3124  1b3a				   .condpart152
   3125  1b3a		       a2 a3		      LDX	#<player152then_0
   3126  1b3c		       86 8a		      STX	player0pointerlo
   3127  1b3e		       a9 f5		      LDA	#>player152then_0
   3128  1b40		       85 8b		      STA	player0pointerhi
   3129  1b42		       a9 05		      LDA	#5
   3130  1b44		       85 8e		      STA	player0height
   3131  1b46				   .skipL0323
   3132  1b46				   .
   3133  1b46							;
   3134  1b46
   3135  1b46				   .L0324		;  if rot = 8 then player0:
   3136  1b46
   3137  1b46		       a5 d7		      LDA	d
   3138  1b48		       c9 08		      CMP	#8
   3139  1b4a		       d0 0c		      BNE	.skipL0324
   3140  1b4c				   .condpart153
   3141  1b4c		       a2 a9		      LDX	#<player153then_0
   3142  1b4e		       86 8a		      STX	player0pointerlo
   3143  1b50		       a9 f5		      LDA	#>player153then_0
   3144  1b52		       85 8b		      STA	player0pointerhi
   3145  1b54		       a9 04		      LDA	#4
   3146  1b56		       85 8e		      STA	player0height
   3147  1b58				   .skipL0324
   3148  1b58				   .
   3149  1b58							;
   3150  1b58
   3151  1b58				   .L0325		;  temp6  =   ( _CurrentLevel	//  5 )
   3152  1b58
   3153  1b58							; complex statement detected
   3154  1b58		       a5 e1		      LDA	_CurrentLevel
   3155  1b5a		       a0 05		      LDY	#5
   3156  1b5c		       20 3a 90 	      jsr	div16
   3157  1b5f		       85 a1		      STA	temp6
   3158  1b61				   .L0326		;  temp6  =  temp1
   3159  1b61
   3160  1b61		       a5 9c		      LDA	temp1
   3161  1b63		       85 a1		      STA	temp6
   3162  1b65				   .
   3163  1b65							;
   3164  1b65
   3165  1b65				   .L0327		;  if temp6  >  1 then goto level2
   3166  1b65
   3167  1b65		       a9 01		      LDA	#1
   3168  1b67		       c5 a1		      CMP	temp6
   3169  1b69		       b0 03		      BCS	.skipL0327
   3170  1b6b				   .condpart154
   3171  1b6b		       4c 81 9b 	      jmp	.level2
   3172  1b6e
   3173  1b6e				   .skipL0327
   3174  1b6e				   .L0328		;  player1:
   3175  1b6e
   3176  1b6e		       a2 ae		      LDX	#<playerL0328_1
   3177  1b70		       86 8c		      STX	player1pointerlo
   3178  1b72		       a9 f5		      LDA	#>playerL0328_1
   3179  1b74		       85 8d		      STA	player1pointerhi
   3180  1b76		       a9 04		      LDA	#4
   3181  1b78		       85 8f		      STA	player1height
   3182  1b7a				   .L0329		;  COLUP1  =  $5A
   3183  1b7a
   3184  1b7a		       a9 5a		      LDA	#$5A
   3185  1b7c		       85 07		      STA	COLUP1
   3186  1b7e				   .
   3187  1b7e							;
   3188  1b7e
   3189  1b7e				   .L0330		;  goto skipref
   3190  1b7e
   3191  1b7e		       4c f1 9b 	      jmp	.skipref
   3192  1b81
   3193  1b81				   .
   3194  1b81							;
   3195  1b81
   3196  1b81				   .level2
   3197  1b81							; level2
   3198  1b81
   3199  1b81				   .L0331		;  if temp6  >  2 then goto level3
   3200  1b81
   3201  1b81		       a9 02		      LDA	#2
   3202  1b83		       c5 a1		      CMP	temp6
   3203  1b85		       b0 03		      BCS	.skipL0331
   3204  1b87				   .condpart155
   3205  1b87		       4c 9d 9b 	      jmp	.level3
   3206  1b8a
   3207  1b8a				   .skipL0331
   3208  1b8a				   .L0332		;  player1:
   3209  1b8a
   3210  1b8a		       a2 b3		      LDX	#<playerL0332_1
   3211  1b8c		       86 8c		      STX	player1pointerlo
   3212  1b8e		       a9 f5		      LDA	#>playerL0332_1
   3213  1b90		       85 8d		      STA	player1pointerhi
   3214  1b92		       a9 04		      LDA	#4
   3215  1b94		       85 8f		      STA	player1height
   3216  1b96				   .L0333		;  COLUP1  =  $56
   3217  1b96
   3218  1b96		       a9 56		      LDA	#$56
   3219  1b98		       85 07		      STA	COLUP1
   3220  1b9a				   .
   3221  1b9a							;
   3222  1b9a
   3223  1b9a				   .L0334		;  goto skipref
   3224  1b9a
   3225  1b9a		       4c f1 9b 	      jmp	.skipref
   3226  1b9d
   3227  1b9d				   .
   3228  1b9d							;
   3229  1b9d
   3230  1b9d				   .level3
   3231  1b9d							; level3
   3232  1b9d
   3233  1b9d				   .L0335		;  if temp6  >  3 then goto level4
   3234  1b9d
   3235  1b9d		       a9 03		      LDA	#3
   3236  1b9f		       c5 a1		      CMP	temp6
   3237  1ba1		       b0 03		      BCS	.skipL0335
   3238  1ba3				   .condpart156
   3239  1ba3		       4c b9 9b 	      jmp	.level4
   3240  1ba6
   3241  1ba6				   .skipL0335
   3242  1ba6				   .L0336		;  player1:
   3243  1ba6
   3244  1ba6		       a2 b8		      LDX	#<playerL0336_1
   3245  1ba8		       86 8c		      STX	player1pointerlo
   3246  1baa		       a9 f5		      LDA	#>playerL0336_1
   3247  1bac		       85 8d		      STA	player1pointerhi
   3248  1bae		       a9 04		      LDA	#4
   3249  1bb0		       85 8f		      STA	player1height
   3250  1bb2				   .L0337		;  COLUP1  =  $9A
   3251  1bb2
   3252  1bb2		       a9 9a		      LDA	#$9A
   3253  1bb4		       85 07		      STA	COLUP1
   3254  1bb6				   .
   3255  1bb6							;
   3256  1bb6
   3257  1bb6				   .L0338		;  goto skipref
   3258  1bb6
   3259  1bb6		       4c f1 9b 	      jmp	.skipref
   3260  1bb9
   3261  1bb9				   .
   3262  1bb9							;
   3263  1bb9
   3264  1bb9				   .level4
   3265  1bb9							; level4
   3266  1bb9
   3267  1bb9				   .L0339		;  if temp6  >  4 then goto level5
   3268  1bb9
   3269  1bb9		       a9 04		      LDA	#4
   3270  1bbb		       c5 a1		      CMP	temp6
   3271  1bbd		       b0 03		      BCS	.skipL0339
   3272  1bbf				   .condpart157
   3273  1bbf		       4c d5 9b 	      jmp	.level5
   3274  1bc2
   3275  1bc2				   .skipL0339
   3276  1bc2				   .L0340		;  player1:
   3277  1bc2
   3278  1bc2		       a2 bd		      LDX	#<playerL0340_1
   3279  1bc4		       86 8c		      STX	player1pointerlo
   3280  1bc6		       a9 f5		      LDA	#>playerL0340_1
   3281  1bc8		       85 8d		      STA	player1pointerhi
   3282  1bca		       a9 04		      LDA	#4
   3283  1bcc		       85 8f		      STA	player1height
   3284  1bce				   .L0341		;  COLUP1  =  $96
   3285  1bce
   3286  1bce		       a9 96		      LDA	#$96
   3287  1bd0		       85 07		      STA	COLUP1
   3288  1bd2				   .
   3289  1bd2							;
   3290  1bd2
   3291  1bd2				   .L0342		;  goto skipref
   3292  1bd2
   3293  1bd2		       4c f1 9b 	      jmp	.skipref
   3294  1bd5
   3295  1bd5				   .
   3296  1bd5							;
   3297  1bd5
   3298  1bd5				   .level5
   3299  1bd5							; level5
   3300  1bd5
   3301  1bd5				   .L0343		;  if temp6  =  5 then goto skipref
   3302  1bd5
   3303  1bd5		       a5 a1		      LDA	temp6
   3304  1bd7		       c9 05		      CMP	#5
   3305  1bd9		       d0 03		      BNE	.skipL0343
   3306  1bdb				   .condpart158
   3307  1bdb		       4c f1 9b 	      jmp	.skipref
   3308  1bde
   3309  1bde				   .skipL0343
   3310  1bde				   .L0344		;  player1:
   3311  1bde
   3312  1bde		       a2 c2		      LDX	#<playerL0344_1
   3313  1be0		       86 8c		      STX	player1pointerlo
   3314  1be2		       a9 f5		      LDA	#>playerL0344_1
   3315  1be4		       85 8d		      STA	player1pointerhi
   3316  1be6		       a9 04		      LDA	#4
   3317  1be8		       85 8f		      STA	player1height
   3318  1bea				   .L0345		;  COLUP1  =  $A6
   3319  1bea
   3320  1bea		       a9 a6		      LDA	#$A6
   3321  1bec		       85 07		      STA	COLUP1
   3322  1bee				   .
   3323  1bee							;
   3324  1bee
   3325  1bee				   .L0346		;  goto skipref
   3326  1bee
   3327  1bee		       4c f1 9b 	      jmp	.skipref
   3328  1bf1
   3329  1bf1				   .
   3330  1bf1							;
   3331  1bf1
   3332  1bf1				   .skipref
   3333  1bf1							; skipref
   3334  1bf1
   3335  1bf1				   .
   3336  1bf1							;
   3337  1bf1
   3338  1bf1				   .L0347		;  goto start
   3339  1bf1
   3340  1bf1		       4c 3a 92 	      jmp	.start
   3341  1bf4
   3342  1bf4				   .
   3343  1bf4							;
   3344  1bf4
   3345  1bf4				   .gameover
   3346  1bf4							; gameover
   3347  1bf4
   3348  1bf4				   .
   3349  1bf4							;
   3350  1bf4
   3351  1bf4				   .L0348		;  COLUP0  =  $00
   3352  1bf4
   3353  1bf4		       a9 00		      LDA	#$00
   3354  1bf6		       85 06		      STA	COLUP0
   3355  1bf8				   .L0349		;  COLUP1  =  $00
   3356  1bf8
   3357  1bf8		       a9 00		      LDA	#$00
   3358  1bfa		       85 07		      STA	COLUP1
   3359  1bfc				   .L0350		;  player0x  =  200
   3360  1bfc
   3361  1bfc		       a9 c8		      LDA	#200
   3362  1bfe		       85 80		      STA	player0x
   3363  1c00				   .L0351		;  player1x  =  200
   3364  1c00
   3365  1c00		       a9 c8		      LDA	#200
   3366  1c02		       85 81		      STA	player1x
   3367  1c04				   .
   3368  1c04							;
   3369  1c04
   3370  1c04				   .L0352		;  playfield:
   3371  1c04
   3372  1c04				  -	      ifconst	pfres
   3373  1c04				  -	      ldx	#(11>pfres)*(pfres*pfwidth-1)+(11<=pfres)*43
   3374  1c04					      else
   3375  1c04		       a2 2b		      ldx	#((11*pfwidth-1)*((11*pfwidth-1)<47))+(47*((11*pfwidth-1)>=47))
   3376  1c06					      endif
   3377  1c06		       4c 35 9c 	      jmp	pflabel2
   3378  1c09				   PF_data2
   3379  1c09		       07 fb		      .byte.b	%00000111, %11111011
   3380  1c0b					      if	(pfwidth>2)
   3381  1c0b		       6d 0f		      .byte.b	%01101101, %00001111
   3382  1c0d					      endif
   3383  1c0d		       04 88		      .byte.b	%00000100, %10001000
   3384  1c0f					      if	(pfwidth>2)
   3385  1c0f		       55 00		      .byte.b	%01010101, %00000000
   3386  1c11					      endif
   3387  1c11		       04 fb		      .byte.b	%00000100, %11111011
   3388  1c13					      if	(pfwidth>2)
   3389  1c13		       45 0f		      .byte.b	%01000101, %00001111
   3390  1c15					      endif
   3391  1c15		       04 8a		      .byte.b	%00000100, %10001010
   3392  1c17					      if	(pfwidth>2)
   3393  1c17		       45 00		      .byte.b	%01000101, %00000000
   3394  1c19					      endif
   3395  1c19		       07 8b		      .byte.b	%00000111, %10001011
   3396  1c1b					      if	(pfwidth>2)
   3397  1c1b		       45 0f		      .byte.b	%01000101, %00001111
   3398  1c1d					      endif
   3399  1c1d		       00 00		      .byte.b	%00000000, %00000000
   3400  1c1f					      if	(pfwidth>2)
   3401  1c1f		       00 00		      .byte.b	%00000000, %00000000
   3402  1c21					      endif
   3403  1c21		       07 8b		      .byte.b	%00000111, %10001011
   3404  1c23					      if	(pfwidth>2)
   3405  1c23		       7d 0f		      .byte.b	%01111101, %00001111
   3406  1c25					      endif
   3407  1c25		       04 8a		      .byte.b	%00000100, %10001010
   3408  1c27					      if	(pfwidth>2)
   3409  1c27		       41 08		      .byte.b	%01000001, %00001000
   3410  1c29					      endif
   3411  1c29		       04 8a		      .byte.b	%00000100, %10001010
   3412  1c2b					      if	(pfwidth>2)
   3413  1c2b		       7d 0f		      .byte.b	%01111101, %00001111
   3414  1c2d					      endif
   3415  1c2d		       04 52		      .byte.b	%00000100, %01010010
   3416  1c2f					      if	(pfwidth>2)
   3417  1c2f		       41 02		      .byte.b	%01000001, %00000010
   3418  1c31					      endif
   3419  1c31		       07 23		      .byte.b	%00000111, %00100011
   3420  1c33					      if	(pfwidth>2)
   3421  1c33		       7d 0c		      .byte.b	%01111101, %00001100
   3422  1c35					      endif
   3423  1c35				   pflabel2
   3424  1c35		       bd 09 9c 	      lda	PF_data2,x
   3425  1c38		       95 a4		      sta	playfield,x
   3426  1c3a		       ca		      dex
   3427  1c3b		       10 f8		      bpl	pflabel2
   3428  1c3d				   .
   3429  1c3d							;
   3430  1c3d
   3431  1c3d				   .L0353		;  pfcolors:
   3432  1c3d
   3433  1c3d		       a9 42		      lda	# $42
   3434  1c3f		       85 08		      sta	COLUPF
   3435  1c41				  -	      ifconst	pfres
   3436  1c41				  -	      lda	#>(pfcolorlabel13-130+pfres*pfwidth)
   3437  1c41					      else
   3438  1c41		       a9 f5		      lda	#>(pfcolorlabel13-82)
   3439  1c43					      endif
   3440  1c43		       85 f1		      sta	pfcolortable+1
   3441  1c45				  -	      ifconst	pfres
   3442  1c45				  -	      lda	#<(pfcolorlabel13-130+pfres*pfwidth)
   3443  1c45					      else
   3444  1c45		       a9 06		      lda	#<(pfcolorlabel13-82)
   3445  1c47					      endif
   3446  1c47		       85 f0		      sta	pfcolortable
   3447  1c49				   .
   3448  1c49							;
   3449  1c49
   3450  1c49				   .L0354		;  drawscreen
   3451  1c49
   3452  1c49		       85 ee		      sta	temp7
   3453  1c4b		       a9 9c		      lda	#>(ret_point6-1)
   3454  1c4d		       48		      pha
   3455  1c4e		       a9 60		      lda	#<(ret_point6-1)
   3456  1c50		       48		      pha
   3457  1c51		       a9 f4		      lda	#>(drawscreen-1)
   3458  1c53		       48		      pha
   3459  1c54		       a9 3b		      lda	#<(drawscreen-1)
   3460  1c56		       48		      pha
   3461  1c57		       a5 ee		      lda	temp7
   3462  1c59		       48		      pha
   3463  1c5a		       8a		      txa
   3464  1c5b		       48		      pha
   3465  1c5c		       a2 04		      ldx	#4
   3466  1c5e		       4c eb ff 	      jmp	BS_jsr
   3467  1c61				   ret_point6
   3468  1c61				   .L0355		;  j  =  j  +	1
   3469  1c61
   3470  1c61		       e6 dd		      INC	j
   3471  1c63				   .L0356		;  if joy0fire  &&  j	>  5 then goto titlescreen
   3472  1c63
   3473  1c63		       24 0c		      bit	INPT4
   3474  1c65		       30 09		      BMI	.skipL0356
   3475  1c67				   .condpart159
   3476  1c67		       a9 05		      LDA	#5
   3477  1c69		       c5 dd		      CMP	j
   3478  1c6b		       b0 03		      BCS	.skip159then
   3479  1c6d				   .condpart160
   3480  1c6d		       4c 9d 90 	      jmp	.titlescreen
   3481  1c70
   3482  1c70				   .skip159then
   3483  1c70				   .skipL0356
   3484  1c70				   .L0357		;  goto gameover
   3485  1c70
   3486  1c70		       4c f4 9b 	      jmp	.gameover
   3487  1c73
   3488  1c73				   .
   3489  1c73							;
   3490  1c73
   3491  1c73				   .L0358		;  bank 2
   3492  1c73
   3493  1c73					      if	ECHO1
      865 bytes of ROM space left in bank 1
   3494  1c73					      echo	"    ",[(start_bank1 - *)]d , "bytes of ROM space left in bank 1")
   3495  1c73					      endif
   3496  1c73		       00 01	   ECHO1      =	1
   3497  1fd4					      ORG	$1FF4-bscode_length
   3498  1fd4					      RORG	$9FF4-bscode_length
   3499  1fd4		       a2 ff	   start_bank1 ldx	#$ff
   3500  1fd6				  -	      ifconst	FASTFETCH	; using DPC+
   3501  1fd6				  -	      stx	FASTFETCH
   3502  1fd6					      endif
   3503  1fd6		       9a		      txs
   3504  1fd7				  -	      if	bankswitch == 64
   3505  1fd7				  -	      lda	#(((>(start-1)) & $0F) | $F0)
   3506  1fd7					      else
   3507  1fd7		       a9 f2		      lda	#>(start-1)
   3508  1fd9					      endif
   3509  1fd9		       48		      pha
   3510  1fda		       a9 51		      lda	#<(start-1)
   3511  1fdc		       48		      pha
   3512  1fdd		       48		      pha
   3513  1fde		       8a		      txa
   3514  1fdf		       48		      pha
   3515  1fe0		       ba		      tsx
   3516  1fe1					      if	bankswitch != 64
   3517  1fe1		       b5 04		      lda	4,x	; get high byte of return address
   3518  1fe3		       2a		      rol
   3519  1fe4		       2a		      rol
   3520  1fe5		       2a		      rol
   3521  1fe6		       2a		      rol
   3522  1fe7		       29 03		      and	#bs_mask	;1 3 or 7 for F8/F6/F4
   3523  1fe9		       aa		      tax
   3524  1fea		       e8		      inx
   3525  1feb				  -	      else
   3526  1feb				  -	      lda	4,x	; get high byte of return address
   3527  1feb				  -	      tay
   3528  1feb				  -	      ora	#$10	; change our bank nibble into a valid rom mirror
   3529  1feb				  -	      sta	4,x
   3530  1feb				  -	      tya
   3531  1feb				  -	      lsr
   3532  1feb				  -	      lsr
   3533  1feb				  -	      lsr
   3534  1feb				  -	      lsr
   3535  1feb				  -	      tax
   3536  1feb				  -	      inx
   3537  1feb					      endif
   3538  1feb		       bd f5 1f 	      lda	bankswitch_hotspot-1,x
   3539  1fee		       68		      pla
   3540  1fef		       aa		      tax
   3541  1ff0		       68		      pla
   3542  1ff1		       60		      rts
   3543  1ff2				  -	      if	((* & $1FFF) > ((bankswitch_hotspot & $1FFF) - 1))
   3544  1ff2				  -	      echo	"WARNING: size parameter in banksw.asm too small - the program probably will not work."
   3545  1ff2				  -	      echo	"Change to",[(*-begin_bscode+1)&$FF]d,"and try again."
   3546  1ff2					      endif
   3547  1ffc					      ORG	$1FFC
   3548  1ffc					      RORG	$9FFC
   3549  1ffc		       d4 9f		      .word.w	(start_bank1 & $ffff)
   3550  1ffe		       d4 9f		      .word.w	(start_bank1 & $ffff)
   3551  2000					      ORG	$2000
   3552  2000					      RORG	$B000
   3553  2000				   .L0359		;  rem *** We're putting the title kernel here, but it can go in any bank you
   3554  2000
   3555  2000				   .L0360		;  rem *** like. Just don't let your program flow accidentally fall into the
   3556  2000
   3557  2000				   .L0361		;  rem *** line below.
   3558  2000
   3559  2000				   .L0362		;  asm
   3560  2000
------- FILE titlescreen/asm/titlescreen.asm LEVEL 2 PASS 2
      0  2000					      include	"titlescreen/asm/titlescreen.asm"
      1  2000
------- FILE titlescreen/asm/layoutmacros.asm LEVEL 3 PASS 2
      0  2000					      include	"titlescreen/asm/layoutmacros.asm"
      1  2000
      2  2000							; the macro's used in the "titlescreen_layout.asm" file
      3  2000
      4  2000					      MAC	draw_96x2_1
      5  2000				   mk_96x2_1_on =	1
      6  2000					      jsr	draw_bmp_96x2_1
      7  2000					      ENDM
      8  2000
      9  2000					      MAC	draw_96x2_2
     10  2000				   mk_96x2_2_on =	1
     11  2000					      jsr	draw_bmp_96x2_2
     12  2000					      ENDM
     13  2000
     14  2000					      MAC	draw_96x2_3
     15  2000				   mk_96x2_3_on =	1
     16  2000					      jsr	draw_bmp_96x2_3
     17  2000					      ENDM
     18  2000
     19  2000					      MAC	draw_96x2_4
     20  2000				   mk_96x2_4_on =	1
     21  2000					      jsr	draw_bmp_96x2_4
     22  2000					      ENDM
     23  2000
     24  2000					      MAC	draw_96x2_5
     25  2000				   mk_96x2_5_on =	1
     26  2000					      jsr	draw_bmp_96x2_5
     27  2000					      ENDM
     28  2000
     29  2000					      MAC	draw_96x2_6
     30  2000				   mk_96x2_6_on =	1
     31  2000					      jsr	draw_bmp_96x2_6
     32  2000					      ENDM
     33  2000
     34  2000					      MAC	draw_96x2_7
     35  2000				   mk_96x2_7_on =	1
     36  2000					      jsr	draw_bmp_96x2_7
     37  2000					      ENDM
     38  2000
     39  2000					      MAC	draw_96x2_8
     40  2000				   mk_96x2_8_on =	1
     41  2000					      jsr	draw_bmp_96x2_8
     42  2000					      ENDM
     43  2000
     44  2000					      MAC	draw_48x1_1
     45  2000				   mk_48x1_X_on =	1
     46  2000				   mk_48x1_1_on =	1
     47  2000					      jsr	draw_bmp_48x1_1
     48  2000					      ENDM
     49  2000
     50  2000					      MAC	draw_48x1_2
     51  2000				   mk_48x1_X_on =	1
     52  2000				   mk_48x1_2_on =	1
     53  2000					      jsr	draw_bmp_48x1_2
     54  2000					      ENDM
     55  2000
     56  2000					      MAC	draw_48x1_3
     57  2000				   mk_48x1_X_on =	1
     58  2000				   mk_48x1_3_on =	1
     59  2000					      jsr	draw_bmp_48x1_3
     60  2000					      ENDM
     61  2000
     62  2000					      MAC	draw_48x1_4
     63  2000				   mk_48x1_X_on =	1
     64  2000				   mk_48x1_4_on =	1
     65  2000					      jsr	draw_bmp_48x1_4
     66  2000					      ENDM
     67  2000
     68  2000					      MAC	draw_48x1_5
     69  2000				   mk_48x1_X_on =	1
     70  2000				   mk_48x1_5_on =	1
     71  2000					      jsr	draw_bmp_48x1_5
     72  2000					      ENDM
     73  2000
     74  2000					      MAC	draw_48x1_6
     75  2000				   mk_48x1_X_on =	1
     76  2000				   mk_48x1_6_on =	1
     77  2000					      jsr	draw_bmp_48x1_6
     78  2000					      ENDM
     79  2000
     80  2000					      MAC	draw_48x1_7
     81  2000				   mk_48x1_X_on =	1
     82  2000				   mk_48x1_7_on =	1
     83  2000					      jsr	draw_bmp_48x1_7
     84  2000					      ENDM
     85  2000
     86  2000					      MAC	draw_48x1_8
     87  2000				   mk_48x1_X_on =	1
     88  2000				   mk_48x1_8_on =	1
     89  2000					      jsr	draw_bmp_48x1_8
     90  2000					      ENDM
     91  2000
     92  2000
     93  2000					      MAC	draw_48x2_1
     94  2000				   mk_48x2_X_on =	1
     95  2000				   mk_48x2_1_on =	1
     96  2000					      jsr	draw_bmp_48x2_1
     97  2000					      ENDM
     98  2000
     99  2000					      MAC	draw_48x2_2
    100  2000				   mk_48x2_X_on =	1
    101  2000				   mk_48x2_2_on =	1
    102  2000					      jsr	draw_bmp_48x2_2
    103  2000					      ENDM
    104  2000
    105  2000					      MAC	draw_48x2_3
    106  2000				   mk_48x2_X_on =	1
    107  2000				   mk_48x2_3_on =	1
    108  2000					      jsr	draw_bmp_48x2_3
    109  2000					      ENDM
    110  2000
    111  2000					      MAC	draw_48x2_4
    112  2000				   mk_48x2_X_on =	1
    113  2000				   mk_48x2_4_on =	1
    114  2000					      jsr	draw_bmp_48x2_4
    115  2000					      ENDM
    116  2000
    117  2000					      MAC	draw_48x2_5
    118  2000				   mk_48x2_X_on =	1
    119  2000				   mk_48x2_5_on =	1
    120  2000					      jsr	draw_bmp_48x2_5
    121  2000					      ENDM
    122  2000
    123  2000					      MAC	draw_48x2_6
    124  2000				   mk_48x2_X_on =	1
    125  2000				   mk_48x2_6_on =	1
    126  2000					      jsr	draw_bmp_48x2_6
    127  2000					      ENDM
    128  2000
    129  2000					      MAC	draw_48x2_7
    130  2000				   mk_48x2_X_on =	1
    131  2000				   mk_48x2_7_on =	1
    132  2000					      jsr	draw_bmp_48x2_7
    133  2000					      ENDM
    134  2000
    135  2000					      MAC	draw_48x2_8
    136  2000				   mk_48x2_X_on =	1
    137  2000				   mk_48x2_8_on =	1
    138  2000					      jsr	draw_bmp_48x2_8
    139  2000					      ENDM
    140  2000
    141  2000					      MAC	draw_player
    142  2000				   mk_player_on =	1
    143  2000					      jsr	draw_player_display
    144  2000					      ENDM
    145  2000
    146  2000					      MAC	draw_score
    147  2000				   mk_score_on =	1
    148  2000				   mk_48x1_X_on =	1
    149  2000					      jsr	draw_score_display
    150  2000					      ENDM
    151  2000
    152  2000					      MAC	draw_gameselect
    153  2000				   mk_gameselect_on =	1
    154  2000				   mk_48x1_X_on =	1
    155  2000					      jsr	draw_gameselect_display
    156  2000					      ENDM
    157  2000
    158  2000					      MAC	draw_space
    159  2000					      ldy	#{1}
    160  2000				   .loop
    161  2000					      sta	WSYNC
    162  2000					      dey
    163  2000					      bne	.loop
    164  2000					      ENDM
    165  2000
------- FILE titlescreen/asm/titlescreen.asm
------- FILE titlescreen/asm/dpcfix.asm LEVEL 3 PASS 2
      0  2000					      include	"titlescreen/asm/dpcfix.asm"
      1  2000							; reassign variables that DPC+ doesn't have
      2  2000
      3  2000				  -	      ifnconst	aux2
      4  2000				  -aux2       =	player2x
      5  2000					      endif
      6  2000				  -	      ifnconst	aux4
      7  2000				  -aux4       =	player4x
      8  2000					      endif
      9  2000				  -	      ifnconst	aux5
     10  2000				  -aux5       =	player5x
     11  2000					      endif
     12  2000				  -	      ifnconst	aux6
     13  2000				  -aux6       =	player6x
     14  2000					      endif
     15  2000
     16  2000				  -	      ifnconst	player0pointer
     17  2000				  -player0pointer =	player2y
     18  2000					      endif
     19  2000				  -	      ifnconst	player1pointer
     20  2000				  -player1pointer =	player2height	; to player3height
     21  2000					      endif
     22  2000				  -	      ifnconst	player1color
     23  2000				  -player1color =	player4height	; to player5height
     24  2000					      endif
     25  2000				  -	      ifnconst	scorepointers
     26  2000				  -scorepointers =	player6height	; to NUSIZ8
     27  2000					      endif
------- FILE titlescreen/asm/titlescreen.asm
------- FILE titlescreen/titlescreen_layout.asm LEVEL 3 PASS 2
      0  2000					      include	"titlescreen/titlescreen_layout.asm"
      1  2000
      2  2000							; To use a minikernel, just list it below. They'll be drawn on the screen in
      3  2000							; in the order they were listed.
      4  2000							;
      5  2000							; If a minikernel isn't listed, it won't be compiled into your program, and
      6  2000							; it won't use any rom space.
      7  2000
      8  2000					      MAC	titlescreenlayout
      9  2000					      draw_96x2_1
     10  2000					      draw_48x1_1
     11  2000					      draw_48x1_2
     12  2000					      draw_space	3
     13  2000					      draw_48x1_3
     14  2000					      ENDM
------- FILE titlescreen/asm/titlescreen.asm
      5  2000
      6  2000				   .titledrawscreen
      7  2000				   title_eat_overscan
      8  2000							;bB runs in overscan. Wait for the overscan to run out...
      9  2000		       18		      clc
     10  2001		       ad 84 02 	      lda	INTIM
     11  2004		       30 fa		      bmi	title_eat_overscan
     12  2006		       4c 09 b0 	      jmp	title_do_vertical_sync
     13  2009
     14  2009				   title_do_vertical_sync
     15  2009		       a9 02		      lda	#2
     16  200b		       85 02		      sta	WSYNC	;one line with VSYNC
     17  200d		       85 00		      sta	VSYNC	;enable VSYNC
     18  200f		       85 02		      sta	WSYNC	;one line with VSYNC
     19  2011		       85 02		      sta	WSYNC	;one line with VSYNC
     20  2013		       a9 00		      lda	#0
     21  2015		       85 02		      sta	WSYNC	;one line with VSYNC
     22  2017		       85 00		      sta	VSYNC	;turn off VSYNC
     23  2019
     24  2019							;lda #42+128
     25  2019				  -	      ifnconst	vblank_time
     26  2019				  -	      lda	#42+128
     27  2019					      else
     28  2019		       a9 ba		      lda	#vblank_time+128
     29  201b					      endif
     30  201b
     31  201b		       8d 96 02 	      sta	TIM64T
     32  201e
     33  201e		       00 82	   titleframe =	missile0x
     34  201e		       e6 82		      inc	titleframe	; increment the frame counter
     35  2020
     36  2020				  -	      ifconst	.title_vblank
     37  2020				  -	      jsr	.title_vblank
     38  2020					      endif
     39  2020
     40  2020				   title_vblank_loop
     41  2020		       ad 84 02 	      lda	INTIM
     42  2023		       30 fb		      bmi	title_vblank_loop
     43  2025		       a9 00		      lda	#0
     44  2027		       85 02		      sta	WSYNC
     45  2029		       85 01		      sta	VBLANK
     46  202b		       85 1d		      sta	ENAM0
     47  202d		       85 1f		      sta	ENABL
     48  202f
     49  202f				   title_playfield
     50  202f
     51  202f							; ======== BEGIN of the custom kernel!!!!! All of the work is done in the playfield.
     52  202f
     53  202f		       a9 e6		      lda	#230
     54  2031		       8d 96 02 	      sta	TIM64T
     55  2034
     56  2034		       a9 01		      lda	#1
     57  2036		       85 0a		      sta	CTRLPF
     58  2038		       18		      clc
     59  2039
     60  2039		       a9 00		      lda	#0
     61  203b		       85 0b		      sta	REFP0
     62  203d		       85 0c		      sta	REFP1
     63  203f		       85 02		      sta	WSYNC
     64  2041		       ad 84 b0 	      lda	titlescreencolor
     65  2044		       85 09		      sta	COLUBK
     66  2046
      0  2046					      titlescreenlayout
      0  2046					      draw_96x2_1
      1  2046		       00 01	   mk_96x2_1_on =	1
      2  2046		       20 d8 b1 	      jsr	draw_bmp_96x2_1
      0  2049					      draw_48x1_1
      1  2049		       00 01	   mk_48x1_X_on =	1
      2  2049		       00 01	   mk_48x1_1_on =	1
      3  2049		       20 85 b0 	      jsr	draw_bmp_48x1_1
      0  204c					      draw_48x1_2
      1  204c		       00 01	   mk_48x1_X_on =	1
      2  204c		       00 01	   mk_48x1_2_on =	1
      3  204c		       20 cd b0 	      jsr	draw_bmp_48x1_2
      0  204f					      draw_space	3
      1  204f		       a0 03		      ldy	#3
      2  2051				   .loop
      3  2051		       85 02		      sta	WSYNC
      4  2053		       88		      dey
      5  2054		       d0 fb		      bne	.loop
      0  2056					      draw_48x1_3
      1  2056		       00 01	   mk_48x1_X_on =	1
      2  2056		       00 01	   mk_48x1_3_on =	1
      3  2056		       20 15 b1 	      jsr	draw_bmp_48x1_3
     68  2059
     69  2059		       4c 71 b3 	      jmp	PFWAIT	; kernel is done. Finish off the screen
     70  205c
------- FILE titlescreen/asm/position48.asm LEVEL 3 PASS 2
      0  205c					      include	"titlescreen/asm/position48.asm"
      1  205c
      2  205c				   position48
      3  205c
      4  205c							;postion P0 and P1
      5  205c
      6  205c		       85 02		      sta	WSYNC
      7  205e
      8  205e		       a9 90		      lda	#$90	;2
      9  2060		       85 20		      sta	HMP0	;3
     10  2062		       a9 a0		      lda	#$A0	;2
     11  2064		       85 21		      sta	HMP1	;3
     12  2066
     13  2066		       e6 9c		      inc	temp1
     14  2068		       c6 9c		      dec	temp1
     15  206a		       e6 9c		      inc	temp1
     16  206c		       c6 9c		      dec	temp1
     17  206e		       e6 9c		      inc	temp1
      0  2070					      sleep	2
      1  2070				   .CYCLES    SET	2
      2  2070
      3  2070				  -	      IF	.CYCLES < 2
      4  2070				  -	      ECHO	"MACRO ERROR: 'SLEEP': Duration must be > 1"
      5  2070				  -	      ERR
      6  2070					      ENDIF
      7  2070
      8  2070				  -	      IF	.CYCLES & 1
      9  2070				  -	      IFNCONST	NO_ILLEGAL_OPCODES
     10  2070				  -	      nop	0
     11  2070				  -	      ELSE
     12  2070				  -	      bit	VSYNC
     13  2070				  -	      ENDIF
     14  2070				  -.CYCLES    SET	.CYCLES - 3
     15  2070					      ENDIF
     16  2070
     17  2070					      REPEAT	.CYCLES / 2
     18  2070		       ea		      nop
     19  2071					      REPEND
     19  2071		       85 10		      sta	RESP0	;  +3
     20  2073		       85 11		      sta	RESP1	;  +3
     21  2075		       c6 9c		      dec	temp1	;  +5
     22  2077		       e6 9c		      inc	temp1	;  +5
     23  2079		       c6 9c		      dec	temp1	;  +5
     24  207b		       e6 9c		      inc	temp1	;  +5
     25  207d		       c6 9c		      dec	temp1	;  +5
      0  207f					      sleep	3
      1  207f				   .CYCLES    SET	3
      2  207f
      3  207f				  -	      IF	.CYCLES < 2
      4  207f				  -	      ECHO	"MACRO ERROR: 'SLEEP': Duration must be > 1"
      5  207f				  -	      ERR
      6  207f					      ENDIF
      7  207f
      8  207f					      IF	.CYCLES & 1
      9  207f					      IFNCONST	NO_ILLEGAL_OPCODES
     10  207f		       04 00		      nop	0
     11  2081				  -	      ELSE
     12  2081				  -	      bit	VSYNC
     13  2081					      ENDIF
     14  2081				   .CYCLES    SET	.CYCLES - 3
     15  2081					      ENDIF
     16  2081
     17  2081				  -	      REPEAT	.CYCLES / 2
     18  2081				  -	      nop
     19  2081					      REPEND
     27  2081		       85 2a		      sta	HMOVE	; +76
     28  2083		       60		      RTS
     29  2084
------- FILE titlescreen/asm/titlescreen.asm
------- FILE titlescreen/titlescreen_color.asm LEVEL 3 PASS 2
      0  2084					      include	"titlescreen/titlescreen_color.asm"
      1  2084
      2  2084							; This is where the titlescreen background color gets set. 
      3  2084							; You can also do a "dim titlescreencolor=[letter]" in bB
      4  2084							; if you want to change the color on the fly.
      5  2084
      6  2084				  -	      ifnconst	titlescreencolor
      7  2084				  -titlescreencolor
      8  2084					      endif
      9  2084		       00		      .byte.b	$00
     10  2085
------- FILE titlescreen/asm/titlescreen.asm
     73  2085
     74  2085					      ifconst	mk_48x1_1_on
------- FILE titlescreen/asm/48x1_1_kernel.asm LEVEL 3 PASS 2
      0  2085					      include	"titlescreen/asm/48x1_1_kernel.asm"
      1  2085
      2  2085				   draw_bmp_48x1_1
      3  2085
      4  2085		       a9 00		      lda	#0
      5  2087		       85 1b		      sta	GRP0
      6  2089		       85 1c		      sta	GRP1
      7  208b
      8  208b		       a0 0b		      ldy	#11
      9  208d				   bmp_48x1_1_pointersetup
     10  208d		       b9 c1 b0 	      lda	bmp_48x1_1_values,y
     11  2090		       99 96 00 	      sta	scorepointers,y
     12  2093		       88		      dey
     13  2094		       b9 c1 b0 	      lda	bmp_48x1_1_values,y
     14  2097				  -	      ifconst	bmp_48x1_1_index
     15  2097				  -	      sec
     16  2097				  -	      sbc	bmp_48x1_1_index
     17  2097					      endif
     18  2097		       99 96 00 	      sta	scorepointers,y
     19  209a		       88		      dey
     20  209b		       10 f0		      bpl	bmp_48x1_1_pointersetup
     21  209d
     22  209d		       a0 5f		      ldy	(#bmp_48x1_1_window-1)
     23  209f		       84 f1		      sty	aux2
     24  20a1
     25  20a1					      ifconst	bmp_48x1_1_background
     26  20a1		       ad 89 b3 	      lda	bmp_48x1_1_background
     27  20a4				  -	      else
     28  20a4				  -	      lda	titlescreencolor
     29  20a4					      endif
     30  20a4		       85 f3		      sta	aux4
     31  20a6
     32  20a6		       ad 86 b3 	      lda	bmp_48x1_1_color
     33  20a9		       85 06		      sta	COLUP0	;3
     34  20ab		       85 07		      sta	COLUP1	;3
     35  20ad		       85 2b		      sta	HMCLR	;3
     36  20af
     37  20af		       ad 84 b0 	      lda	titlescreencolor
     38  20b2		       85 08		      sta	COLUPF
     39  20b4
     40  20b4					      ifconst	bmp_48x1_1_PF1
     41  20b4		       ad 87 b3 	      lda	bmp_48x1_1_PF1
     42  20b7				  -	      else
     43  20b7				  -	      lda	#0
     44  20b7				  -	      nop
     45  20b7					      endif
     46  20b7		       85 0e		      sta	PF1
     47  20b9
     48  20b9					      ifconst	bmp_48x1_1_PF2
     49  20b9		       ad 88 b3 	      lda	bmp_48x1_1_PF2
     50  20bc				  -	      else
     51  20bc				  -	      lda	#0
     52  20bc				  -	      nop
     53  20bc					      endif
     54  20bc		       85 0f		      sta	PF2
     55  20be
     56  20be		       4c 5d b1 	      jmp	draw_bmp_48x1_X	; the common 1lk bitmap minikernel
     57  20c1
     58  20c1				   bmp_48x1_1_values
     59  20c1		       8a b3		      .word.w	(bmp_48x1_1_00+#bmp_48x1_1_height-#bmp_48x1_1_window)
     60  20c3		       00 b4		      .word.w	(bmp_48x1_1_01+#bmp_48x1_1_height-#bmp_48x1_1_window)
     61  20c5		       60 b4		      .word.w	(bmp_48x1_1_02+#bmp_48x1_1_height-#bmp_48x1_1_window)
     62  20c7		       00 b5		      .word.w	(bmp_48x1_1_03+#bmp_48x1_1_height-#bmp_48x1_1_window)
     63  20c9		       60 b5		      .word.w	(bmp_48x1_1_04+#bmp_48x1_1_height-#bmp_48x1_1_window)
     64  20cb		       00 b6		      .word.w	(bmp_48x1_1_05+#bmp_48x1_1_height-#bmp_48x1_1_window)
     65  20cd
------- FILE titlescreen/asm/titlescreen.asm
     76  20cd					      endif		;mk_48x1_1_on
     77  20cd
     78  20cd					      ifconst	mk_48x1_2_on
------- FILE titlescreen/asm/48x1_2_kernel.asm LEVEL 3 PASS 2
      0  20cd					      include	"titlescreen/asm/48x1_2_kernel.asm"
      1  20cd
      2  20cd				   draw_bmp_48x1_2
      3  20cd
      4  20cd		       a9 00		      lda	#0
      5  20cf		       85 1b		      sta	GRP0
      6  20d1		       85 1c		      sta	GRP1
      7  20d3
      8  20d3		       a0 0b		      ldy	#11
      9  20d5				   bmp_48x1_2_pointersetup
     10  20d5		       b9 09 b1 	      lda	bmp_48x1_2_values,y
     11  20d8		       99 96 00 	      sta	scorepointers,y
     12  20db		       88		      dey
     13  20dc		       b9 09 b1 	      lda	bmp_48x1_2_values,y
     14  20df				  -	      ifconst	bmp_48x1_2_index
     15  20df				  -	      sec
     16  20df				  -	      sbc	bmp_48x1_2_index
     17  20df					      endif
     18  20df		       99 96 00 	      sta	scorepointers,y
     19  20e2		       88		      dey
     20  20e3		       10 f0		      bpl	bmp_48x1_2_pointersetup
     21  20e5
     22  20e5		       a0 0a		      ldy	(#bmp_48x1_2_window-1)
     23  20e7		       84 f1		      sty	aux2
     24  20e9
     25  20e9					      ifconst	bmp_48x1_2_background
     26  20e9		       ad 63 b6 	      lda	bmp_48x1_2_background
     27  20ec				  -	      else
     28  20ec				  -	      lda	titlescreencolor
     29  20ec					      endif
     30  20ec		       85 f3		      sta	aux4
     31  20ee
     32  20ee		       ad 60 b6 	      lda	bmp_48x1_2_color
     33  20f1		       85 06		      sta	COLUP0	;3
     34  20f3		       85 07		      sta	COLUP1	;3
     35  20f5		       85 2b		      sta	HMCLR	;3
     36  20f7
     37  20f7		       ad 84 b0 	      lda	titlescreencolor
     38  20fa		       85 08		      sta	COLUPF
     39  20fc
     40  20fc					      ifconst	bmp_48x1_2_PF1
     41  20fc		       ad 61 b6 	      lda	bmp_48x1_2_PF1
     42  20ff				  -	      else
     43  20ff				  -	      lda	#0
     44  20ff				  -	      nop
     45  20ff					      endif
     46  20ff		       85 0e		      sta	PF1
     47  2101
     48  2101					      ifconst	bmp_48x1_2_PF2
     49  2101		       ad 62 b6 	      lda	bmp_48x1_2_PF2
     50  2104				  -	      else
     51  2104				  -	      lda	#0
     52  2104				  -	      nop
     53  2104					      endif
     54  2104		       85 0f		      sta	PF2
     55  2106
     56  2106		       4c 5d b1 	      jmp	draw_bmp_48x1_X	; the common 1lk bitmap minikernel
     57  2109
     58  2109				   bmp_48x1_2_values
     59  2109		       64 b6		      .word.w	(bmp_48x1_2_00+#bmp_48x1_2_height-#bmp_48x1_2_window)
     60  210b		       6f b6		      .word.w	(bmp_48x1_2_01+#bmp_48x1_2_height-#bmp_48x1_2_window)
     61  210d		       7a b6		      .word.w	(bmp_48x1_2_02+#bmp_48x1_2_height-#bmp_48x1_2_window)
     62  210f		       85 b6		      .word.w	(bmp_48x1_2_03+#bmp_48x1_2_height-#bmp_48x1_2_window)
     63  2111		       90 b6		      .word.w	(bmp_48x1_2_04+#bmp_48x1_2_height-#bmp_48x1_2_window)
     64  2113		       9b b6		      .word.w	(bmp_48x1_2_05+#bmp_48x1_2_height-#bmp_48x1_2_window)
     65  2115
------- FILE titlescreen/asm/titlescreen.asm
     80  2115					      endif		;mk_48x1_2_on
     81  2115
     82  2115					      ifconst	mk_48x1_3_on
------- FILE titlescreen/asm/48x1_3_kernel.asm LEVEL 3 PASS 2
      0  2115					      include	"titlescreen/asm/48x1_3_kernel.asm"
      1  2115
      2  2115				   draw_bmp_48x1_3
      3  2115
      4  2115		       a9 00		      lda	#0
      5  2117		       85 1b		      sta	GRP0
      6  2119		       85 1c		      sta	GRP1
      7  211b
      8  211b		       a0 0b		      ldy	#11
      9  211d				   bmp_48x1_3_pointersetup
     10  211d		       b9 51 b1 	      lda	bmp_48x1_3_values,y
     11  2120		       99 96 00 	      sta	scorepointers,y
     12  2123		       88		      dey
     13  2124		       b9 51 b1 	      lda	bmp_48x1_3_values,y
     14  2127				  -	      ifconst	bmp_48x1_3_index
     15  2127				  -	      sec
     16  2127				  -	      sbc	bmp_48x1_3_index
     17  2127					      endif
     18  2127		       99 96 00 	      sta	scorepointers,y
     19  212a		       88		      dey
     20  212b		       10 f0		      bpl	bmp_48x1_3_pointersetup
     21  212d
     22  212d		       a0 0a		      ldy	(#bmp_48x1_3_window-1)
     23  212f		       84 f1		      sty	aux2
     24  2131
     25  2131					      ifconst	bmp_48x1_3_background
     26  2131		       ad a8 b6 	      lda	bmp_48x1_3_background
     27  2134				  -	      else
     28  2134				  -	      lda	titlescreencolor
     29  2134					      endif
     30  2134		       85 f3		      sta	aux4
     31  2136
     32  2136		       ad a9 b6 	      lda	bmp_48x1_3_color
     33  2139		       85 06		      sta	COLUP0	;3
     34  213b		       85 07		      sta	COLUP1	;3
     35  213d		       85 2b		      sta	HMCLR	;3
     36  213f
     37  213f		       ad 84 b0 	      lda	titlescreencolor
     38  2142		       85 08		      sta	COLUPF
     39  2144
     40  2144					      ifconst	bmp_48x1_3_PF1
     41  2144		       ad a6 b6 	      lda	bmp_48x1_3_PF1
     42  2147				  -	      else
     43  2147				  -	      lda	#0
     44  2147				  -	      nop
     45  2147					      endif
     46  2147		       85 0e		      sta	PF1
     47  2149
     48  2149					      ifconst	bmp_48x1_3_PF2
     49  2149		       ad a7 b6 	      lda	bmp_48x1_3_PF2
     50  214c				  -	      else
     51  214c				  -	      lda	#0
     52  214c				  -	      nop
     53  214c					      endif
     54  214c		       85 0f		      sta	PF2
     55  214e
     56  214e		       4c 5d b1 	      jmp	draw_bmp_48x1_X	; the common 1lk bitmap minikernel
     57  2151
     58  2151				   bmp_48x1_3_values
     59  2151		       aa b6		      .word.w	(bmp_48x1_3_00+#bmp_48x1_3_height-#bmp_48x1_3_window)
     60  2153		       b5 b6		      .word.w	(bmp_48x1_3_01+#bmp_48x1_3_height-#bmp_48x1_3_window)
     61  2155		       c0 b6		      .word.w	(bmp_48x1_3_02+#bmp_48x1_3_height-#bmp_48x1_3_window)
     62  2157		       cb b6		      .word.w	(bmp_48x1_3_03+#bmp_48x1_3_height-#bmp_48x1_3_window)
     63  2159		       d6 b6		      .word.w	(bmp_48x1_3_04+#bmp_48x1_3_height-#bmp_48x1_3_window)
     64  215b		       e1 b6		      .word.w	(bmp_48x1_3_05+#bmp_48x1_3_height-#bmp_48x1_3_window)
     65  215d
------- FILE titlescreen/asm/titlescreen.asm
     84  215d					      endif		;mk_48x1_3_on
     85  215d
     86  215d				  -	      ifconst	mk_48x1_4_on
     87  215d				  -	      include	"titlescreen/asm/48x1_4_kernel.asm"
     88  215d					      endif		;mk_48x1_4_on
     89  215d
     90  215d				  -	      ifconst	mk_48x1_5_on
     91  215d				  -	      include	"titlescreen/asm/48x1_5_kernel.asm"
     92  215d					      endif		;mk_48x1_5_on
     93  215d
     94  215d				  -	      ifconst	mk_48x1_6_on
     95  215d				  -	      include	"titlescreen/asm/48x1_6_kernel.asm"
     96  215d					      endif		;mk_48x1_6_on
     97  215d
     98  215d				  -	      ifconst	mk_48x1_7_on
     99  215d				  -	      include	"titlescreen/asm/48x1_7_kernel.asm"
    100  215d					      endif		;mk_48x1_7_on
    101  215d
    102  215d				  -	      ifconst	mk_48x1_8_on
    103  215d				  -	      include	"titlescreen/asm/48x1_8_kernel.asm"
    104  215d					      endif		;mk_48x1_8_on
    105  215d
    106  215d				  -	      ifconst	mk_48x2_1_on
    107  215d				  -	      include	"titlescreen/asm/48x2_1_kernel.asm"
    108  215d					      endif		;mk_48x2_1_on
    109  215d
    110  215d				  -	      ifconst	mk_48x2_2_on
    111  215d				  -	      include	"titlescreen/asm/48x2_2_kernel.asm"
    112  215d					      endif		;mk_48x2_2_on
    113  215d
    114  215d				  -	      ifconst	mk_48x2_3_on
    115  215d				  -	      include	"titlescreen/asm/48x2_3_kernel.asm"
    116  215d					      endif		;mk_48x2_3_on
    117  215d
    118  215d				  -	      ifconst	mk_48x2_4_on
    119  215d				  -	      include	"titlescreen/asm/48x2_4_kernel.asm"
    120  215d					      endif		;mk_48x2_4_on
    121  215d
    122  215d				  -	      ifconst	mk_48x2_5_on
    123  215d				  -	      include	"titlescreen/asm/48x2_5_kernel.asm"
    124  215d					      endif		;mk_48x2_5_on
    125  215d
    126  215d				  -	      ifconst	mk_48x2_6_on
    127  215d				  -	      include	"titlescreen/asm/48x2_6_kernel.asm"
    128  215d					      endif		;mk_48x2_6_on
    129  215d
    130  215d				  -	      ifconst	mk_48x2_7_on
    131  215d				  -	      include	"titlescreen/asm/48x2_7_kernel.asm"
    132  215d					      endif		;mk_48x2_7_on
    133  215d
    134  215d				  -	      ifconst	mk_48x2_8_on
    135  215d				  -	      include	"titlescreen/asm/48x2_8_kernel.asm"
    136  215d					      endif		;mk_48x2_8_on
    137  215d
    138  215d					      ifconst	mk_48x1_X_on
------- FILE titlescreen/asm/48x1_X_kernel.asm LEVEL 3 PASS 2
      0  215d					      include	"titlescreen/asm/48x1_X_kernel.asm"
      1  215d				   draw_bmp_48x1_X
      2  215d
      3  215d		       a9 03		      lda	#3
      4  215f		       85 04		      sta	NUSIZ0	;3=Player and Missile are drawn twice 32 clocks apart
      5  2161		       85 05		      sta	NUSIZ1	;3=Player and Missile are drawn twice 32 clocks apart
      6  2163
      7  2163		       ba		      tsx
      8  2164		       86 f6		      stx	stack1	;save the stack pointer
      9  2166
     10  2166		       20 5c b0 	      jsr	position48
     11  2169
     12  2169		       a9 03		      lda	#3	;2
     13  216b		       85 25		      sta	VDELP0	;3
     14  216d		       85 26		      sta	VDELP1	;3
     15  216f
     16  216f		       a9 01		      lda	#1	;2
     17  2171		       85 0a		      sta	CTRLPF	;3
     18  2173
     19  2173							;enough cycles have passed for the HMOV, so we can clear HMCLR
     20  2173		       85 2b		      sta	HMCLR
     21  2175
     22  2175		       85 02		      sta	WSYNC
     23  2177
     24  2177		       e6 9c		      inc	temp1	;5
     25  2179		       c6 9c		      dec	temp1	;5
     26  217b		       e6 9c		      inc	temp1	;5
     27  217d		       c6 9c		      dec	temp1	;5
     28  217f		       e6 9c		      inc	temp1	;5
     29  2181		       c6 9c		      dec	temp1	;5
     30  2183		       e6 9c		      inc	temp1	;5
     31  2185		       c6 9c		      dec	temp1	;5
     32  2187		       e6 9c		      inc	temp1	;5
     33  2189		       c6 9c		      dec	temp1	;5
     34  218b
      0  218b					      sleep	5
      1  218b				   .CYCLES    SET	5
      2  218b
      3  218b				  -	      IF	.CYCLES < 2
      4  218b				  -	      ECHO	"MACRO ERROR: 'SLEEP': Duration must be > 1"
      5  218b				  -	      ERR
      6  218b					      ENDIF
      7  218b
      8  218b					      IF	.CYCLES & 1
      9  218b					      IFNCONST	NO_ILLEGAL_OPCODES
     10  218b		       04 00		      nop	0
     11  218d				  -	      ELSE
     12  218d				  -	      bit	VSYNC
     13  218d					      ENDIF
     14  218d				   .CYCLES    SET	.CYCLES - 3
     15  218d					      ENDIF
     16  218d
     17  218d					      REPEAT	.CYCLES / 2
     18  218d		       ea		      nop
     19  218e					      REPEND
     36  218e
     37  218e		       c8		      iny
     38  218f
     39  218f		       4c 92 b1 	      jmp	pf48x1_X_loop_entry
     40  2192
     41  2192				  -	      if	>. != >[.+$2a]
     42  2192				  -	      align	256
     43  2192					      endif
     44  2192
     45  2192				   pf48x1_X_loop_entry
     46  2192				   pf48x1_X_loop
     47  2192		       88		      dey		;2
     48  2193		       84 f1		      sty	aux2	;3
     49  2195		       b1 96		      lda	(scorepointers+0),y	;5
     50  2197		       85 1b		      sta	GRP0	;3
     51  2199
     52  2199		       b1 98		      lda	(scorepointers+2),y	;5
     53  219b		       85 1c		      sta	GRP1	;3
     54  219d		       b1 9a		      lda	(scorepointers+4),y	;5
     55  219f		       85 1b		      sta	GRP0	;3
     56  21a1
      0  21a1					      sleep	2	; I could make this indirect, if we want to burn more rom
      1  21a1				   .CYCLES    SET	2
      2  21a1
      3  21a1				  -	      IF	.CYCLES < 2
      4  21a1				  -	      ECHO	"MACRO ERROR: 'SLEEP': Duration must be > 1"
      5  21a1				  -	      ERR
      6  21a1					      ENDIF
      7  21a1
      8  21a1				  -	      IF	.CYCLES & 1
      9  21a1				  -	      IFNCONST	NO_ILLEGAL_OPCODES
     10  21a1				  -	      nop	0
     11  21a1				  -	      ELSE
     12  21a1				  -	      bit	VSYNC
     13  21a1				  -	      ENDIF
     14  21a1				  -.CYCLES    SET	.CYCLES - 3
     15  21a1					      ENDIF
     16  21a1
     17  21a1					      REPEAT	.CYCLES / 2
     18  21a1		       ea		      nop
     19  21a2					      REPEND
     58  21a2		       a5 f3		      lda	aux4	;3
     59  21a4		       85 08		      sta	COLUPF	;3 this is a big fat waste...
     60  21a6
     61  21a6		       b3 a0		      lax	(scorepointers+10),y	;5
     62  21a8		       b1 9e		      lda	(scorepointers+8),y	;5
     63  21aa		       85 f7		      sta	stack2	;3
     64  21ac		       b1 9c		      lda	(scorepointers+6),y	;5
     65  21ae		       a4 f7		      ldy	stack2	;3
     66  21b0
     67  21b0		       85 1c		      sta	GRP1	;3
     68  21b2		       84 1b		      sty	GRP0	;3
     69  21b4		       86 1c		      stx	GRP1	;3
     70  21b6		       84 1b		      sty	GRP0	;3
     71  21b8
     72  21b8		       a4 f1		      ldy	aux2	;3
     73  21ba		       d0 d6		      bne	pf48x1_X_loop	;2/3
     74  21bc
     75  21bc				   pf48x1_X_codeend
     76  21bc							;echo "critical code in 48x1 is ",(pf48x1_X_codeend-pf48x1_X_loop), " bytes long."
     77  21bc
     78  21bc		       a9 00		      lda	#0
     79  21be		       85 1b		      sta	GRP0
     80  21c0		       85 1c		      sta	GRP1
     81  21c2		       85 1b		      sta	GRP0
     82  21c4		       85 1c		      sta	GRP1
     83  21c6		       85 1f		      sta	ENABL
     84  21c8		       85 1d		      sta	ENAM0
     85  21ca		       85 25		      sta	VDELP0
     86  21cc		       85 26		      sta	VDELP1
     87  21ce		       85 0d		      sta	PF0
     88  21d0		       85 0e		      sta	PF1
     89  21d2		       85 0f		      sta	PF2
     90  21d4
     91  21d4		       a6 f6		      ldx	stack1	;restore the stack pointer
     92  21d6		       9a		      txs
     93  21d7		       60		      rts
------- FILE titlescreen/asm/titlescreen.asm
    140  21d8					      endif		;mk_48x1_X_on
    141  21d8
    142  21d8				  -	      ifconst	mk_48x2_X_on
    143  21d8				  -	      include	"titlescreen/asm/48x2_X_kernel.asm"
    144  21d8					      endif		;mk_48x2_X_on
    145  21d8
    146  21d8
    147  21d8					      ifconst	mk_96x2_1_on
------- FILE titlescreen/asm/96x2_1_kernel.asm LEVEL 3 PASS 2
      0  21d8					      include	"titlescreen/asm/96x2_1_kernel.asm"
      1  21d8				   draw_bmp_96x2_1
      2  21d8
      3  21d8				  -	      ifconst	bmp_96x2_1_index
      4  21d8				  -	      lda	#(bmp_96x2_1_height-1)
      5  21d8				  -	      sec
      6  21d8				  -	      sbc	bmp_96x2_1_index
      7  21d8				  -	      tay
      8  21d8				  -	      sbc	#bmp_96x2_1_window
      9  21d8				  -	      sta	temp1
     10  21d8					      else
     11  21d8		       a0 0a		      ldy	#(bmp_96x2_1_window-1)
     12  21da		       a9 ff		      lda	#255
     13  21dc		       85 9c		      sta	temp1
     14  21de					      endif
     15  21de
     16  21de		       a9 03		      lda	#3
     17  21e0		       85 04		      sta	NUSIZ0	;3=Player and Missile are drawn twice 32 clocks apart
     18  21e2		       85 05		      sta	NUSIZ1	;3=Player and Missile are drawn twice 32 clocks apart
     19  21e4		       a9 00		      lda	#0
     20  21e6
     21  21e6		       b9 ec b6 	      lda	bmp_96x2_1_colors,y	;4
     22  21e9				  -	      ifconst	bmp_96x2_1_fade
     23  21e9				  -	      and	bmp_96x2_1_fade
     24  21e9					      endif
     25  21e9		       85 06		      sta	COLUP0	;3
     26  21eb		       85 07		      sta	COLUP1	;3
     27  21ed		       85 2b		      sta	HMCLR	;3
     28  21ef
     29  21ef		       a5 82		      lda	titleframe
     30  21f1		       29 01		      and	#1
     31  21f3		       f0 03		      beq	jmp_pf96x2_1_frame0
     32  21f5		       4c 9f b2 	      jmp	pf96x2_1_frame1
     33  21f8				   jmp_pf96x2_1_frame0
     34  21f8		       4c fb b1 	      jmp	pf96x2_1_frame0
     35  21fb
     36  21fb				   pf96x2_1_frame0
     37  21fb							;postion P0 and P1
     38  21fb		       85 02		      sta	WSYNC
     39  21fd		       a9 e0		      lda	#%11100000
     40  21ff		       85 20		      sta	HMP0
     41  2201		       a9 10		      lda	#%00010000
     42  2203		       85 21		      sta	HMP1
     43  2205		       85 02		      sta	WSYNC
      0  2207					      sleep	28
      1  2207				   .CYCLES    SET	28
      2  2207
      3  2207				  -	      IF	.CYCLES < 2
      4  2207				  -	      ECHO	"MACRO ERROR: 'SLEEP': Duration must be > 1"
      5  2207				  -	      ERR
      6  2207					      ENDIF
      7  2207
      8  2207				  -	      IF	.CYCLES & 1
      9  2207				  -	      IFNCONST	NO_ILLEGAL_OPCODES
     10  2207				  -	      nop	0
     11  2207				  -	      ELSE
     12  2207				  -	      bit	VSYNC
     13  2207				  -	      ENDIF
     14  2207				  -.CYCLES    SET	.CYCLES - 3
     15  2207					      ENDIF
     16  2207
     17  2207					      REPEAT	.CYCLES / 2
     18  2207		       ea		      nop
     17  2207					      REPEND
     18  2208		       ea		      nop
     17  2208					      REPEND
     18  2209		       ea		      nop
     17  2209					      REPEND
     18  220a		       ea		      nop
     17  220a					      REPEND
     18  220b		       ea		      nop
     17  220b					      REPEND
     18  220c		       ea		      nop
     17  220c					      REPEND
     18  220d		       ea		      nop
     17  220d					      REPEND
     18  220e		       ea		      nop
     17  220e					      REPEND
     18  220f		       ea		      nop
     17  220f					      REPEND
     18  2210		       ea		      nop
     17  2210					      REPEND
     18  2211		       ea		      nop
     17  2211					      REPEND
     18  2212		       ea		      nop
     17  2212					      REPEND
     18  2213		       ea		      nop
     17  2213					      REPEND
     18  2214		       ea		      nop
     19  2215					      REPEND
     45  2215		       85 10		      sta	RESP0
      0  2217					      sleep	14
      1  2217				   .CYCLES    SET	14
      2  2217
      3  2217				  -	      IF	.CYCLES < 2
      4  2217				  -	      ECHO	"MACRO ERROR: 'SLEEP': Duration must be > 1"
      5  2217				  -	      ERR
      6  2217					      ENDIF
      7  2217
      8  2217				  -	      IF	.CYCLES & 1
      9  2217				  -	      IFNCONST	NO_ILLEGAL_OPCODES
     10  2217				  -	      nop	0
     11  2217				  -	      ELSE
     12  2217				  -	      bit	VSYNC
     13  2217				  -	      ENDIF
     14  2217				  -.CYCLES    SET	.CYCLES - 3
     15  2217					      ENDIF
     16  2217
     17  2217					      REPEAT	.CYCLES / 2
     18  2217		       ea		      nop
     17  2217					      REPEND
     18  2218		       ea		      nop
     17  2218					      REPEND
     18  2219		       ea		      nop
     17  2219					      REPEND
     18  221a		       ea		      nop
     17  221a					      REPEND
     18  221b		       ea		      nop
     17  221b					      REPEND
     18  221c		       ea		      nop
     17  221c					      REPEND
     18  221d		       ea		      nop
     19  221e					      REPEND
     47  221e		       85 11		      sta	RESP1
     48  2220		       85 02		      sta	WSYNC
     49  2222		       85 2a		      sta	HMOVE
     50  2224
     51  2224		       85 02		      sta	WSYNC
     52  2226		       85 2b		      sta	HMCLR
     53  2228		       85 02		      sta	WSYNC
     54  222a
      0  222a					      sleep	4
      1  222a				   .CYCLES    SET	4
      2  222a
      3  222a				  -	      IF	.CYCLES < 2
      4  222a				  -	      ECHO	"MACRO ERROR: 'SLEEP': Duration must be > 1"
      5  222a				  -	      ERR
      6  222a					      ENDIF
      7  222a
      8  222a				  -	      IF	.CYCLES & 1
      9  222a				  -	      IFNCONST	NO_ILLEGAL_OPCODES
     10  222a				  -	      nop	0
     11  222a				  -	      ELSE
     12  222a				  -	      bit	VSYNC
     13  222a				  -	      ENDIF
     14  222a				  -.CYCLES    SET	.CYCLES - 3
     15  222a					      ENDIF
     16  222a
     17  222a					      REPEAT	.CYCLES / 2
     18  222a		       ea		      nop
     17  222a					      REPEND
     18  222b		       ea		      nop
     19  222c					      REPEND
     56  222c		       4c 2f b2 	      jmp	pfline_96x2_1_frame0
     57  222f							;align so our branch doesn't unexpectedly cross a page...
     58  222f				  -	      if	>. != >[.+$70]
     59  222f				  -	      align	256
     60  222f					      endif
     61  222f
     62  222f				   pfline_96x2_1_frame0
     63  222f		       a9 80		      lda	#$80	;2
     64  2231		       85 20		      sta	HMP0	;3
     65  2233		       85 21		      sta	HMP1	;3
     66  2235
     67  2235		       b9 42 b7 	      lda	bmp_96x2_1_06,y	;4
     68  2238		       85 1c		      sta	GRP1	;3
     69  223a
     70  223a		       b9 00 b7 	      lda	bmp_96x2_1_00,y
     71  223d		       85 1b		      sta	GRP0
     72  223f		       b9 16 b7 	      lda	bmp_96x2_1_02,y
     73  2242		       85 1b		      sta	GRP0
     74  2244		       b9 2c b7 	      lda	bmp_96x2_1_04,y
     75  2247		       85 1b		      sta	GRP0
     76  2249
      0  2249					      sleep	2
      1  2249				   .CYCLES    SET	2
      2  2249
      3  2249				  -	      IF	.CYCLES < 2
      4  2249				  -	      ECHO	"MACRO ERROR: 'SLEEP': Duration must be > 1"
      5  2249				  -	      ERR
      6  2249					      ENDIF
      7  2249
      8  2249				  -	      IF	.CYCLES & 1
      9  2249				  -	      IFNCONST	NO_ILLEGAL_OPCODES
     10  2249				  -	      nop	0
     11  2249				  -	      ELSE
     12  2249				  -	      bit	VSYNC
     13  2249				  -	      ENDIF
     14  2249				  -.CYCLES    SET	.CYCLES - 3
     15  2249					      ENDIF
     16  2249
     17  2249					      REPEAT	.CYCLES / 2
     18  2249		       ea		      nop
     19  224a					      REPEND
     78  224a
     79  224a		       b9 58 b7 	      lda	bmp_96x2_1_08,y
     80  224d		       85 1c		      sta	GRP1
     81  224f		       b9 6e b7 	      lda	bmp_96x2_1_10,y
     82  2252		       85 1c		      sta	GRP1
     83  2254
     84  2254		       b9 0b b7 	      lda	bmp_96x2_1_01,y
     85  2257		       85 1b		      sta	GRP0
     86  2259
      0  2259					      sleep	8
      1  2259				   .CYCLES    SET	8
      2  2259
      3  2259				  -	      IF	.CYCLES < 2
      4  2259				  -	      ECHO	"MACRO ERROR: 'SLEEP': Duration must be > 1"
      5  2259				  -	      ERR
      6  2259					      ENDIF
      7  2259
      8  2259				  -	      IF	.CYCLES & 1
      9  2259				  -	      IFNCONST	NO_ILLEGAL_OPCODES
     10  2259				  -	      nop	0
     11  2259				  -	      ELSE
     12  2259				  -	      bit	VSYNC
     13  2259				  -	      ENDIF
     14  2259				  -.CYCLES    SET	.CYCLES - 3
     15  2259					      ENDIF
     16  2259
     17  2259					      REPEAT	.CYCLES / 2
     18  2259		       ea		      nop
     17  2259					      REPEND
     18  225a		       ea		      nop
     17  225a					      REPEND
     18  225b		       ea		      nop
     17  225b					      REPEND
     18  225c		       ea		      nop
     19  225d					      REPEND
     88  225d
     89  225d							;sta WSYNC	;=0
     90  225d		       85 2a		      sta	HMOVE	;3 - NORMAL HMOVE
     91  225f
     92  225f		       b9 eb b6 	      lda	bmp_96x2_1_colors-1,y	;4 - get the title color early and store it for later
     93  2262				  -	      ifconst	bmp_96x2_1_fade
     94  2262				  -	      and	bmp_96x2_1_fade
     95  2262					      else
      0  2262					      sleep	3
      1  2262				   .CYCLES    SET	3
      2  2262
      3  2262				  -	      IF	.CYCLES < 2
      4  2262				  -	      ECHO	"MACRO ERROR: 'SLEEP': Duration must be > 1"
      5  2262				  -	      ERR
      6  2262					      ENDIF
      7  2262
      8  2262					      IF	.CYCLES & 1
      9  2262					      IFNCONST	NO_ILLEGAL_OPCODES
     10  2262		       04 00		      nop	0
     11  2264				  -	      ELSE
     12  2264				  -	      bit	VSYNC
     13  2264					      ENDIF
     14  2264				   .CYCLES    SET	.CYCLES - 3
     15  2264					      ENDIF
     16  2264
     17  2264				  -	      REPEAT	.CYCLES / 2
     18  2264				  -	      nop
     19  2264					      REPEND
     97  2264					      endif
     98  2264		       aa		      tax
     99  2265
    100  2265		       a9 00		      lda	#0	;2
    101  2267		       85 20		      sta	HMP0	;3
    102  2269		       85 21		      sta	HMP1	;3
    103  226b
      0  226b					      sleep	7
      1  226b				   .CYCLES    SET	7
      2  226b
      3  226b				  -	      IF	.CYCLES < 2
      4  226b				  -	      ECHO	"MACRO ERROR: 'SLEEP': Duration must be > 1"
      5  226b				  -	      ERR
      6  226b					      ENDIF
      7  226b
      8  226b					      IF	.CYCLES & 1
      9  226b					      IFNCONST	NO_ILLEGAL_OPCODES
     10  226b		       04 00		      nop	0
     11  226d				  -	      ELSE
     12  226d				  -	      bit	VSYNC
     13  226d					      ENDIF
     14  226d				   .CYCLES    SET	.CYCLES - 3
     15  226d					      ENDIF
     16  226d
     17  226d					      REPEAT	.CYCLES / 2
     18  226d		       ea		      nop
     17  226d					      REPEND
     18  226e		       ea		      nop
     19  226f					      REPEND
    105  226f
    106  226f		       b9 4d b7 	      lda	bmp_96x2_1_07,y
    107  2272		       85 1c		      sta	GRP1
    108  2274
    109  2274		       b9 21 b7 	      lda	bmp_96x2_1_03,y	;5
    110  2277		       85 1b		      sta	GRP0	;3 =  8
    111  2279		       b9 37 b7 	      lda	bmp_96x2_1_05,y	;5
    112  227c		       85 1b		      sta	GRP0	;3 =  8
    113  227e
      0  227e					      sleep	2
      1  227e				   .CYCLES    SET	2
      2  227e
      3  227e				  -	      IF	.CYCLES < 2
      4  227e				  -	      ECHO	"MACRO ERROR: 'SLEEP': Duration must be > 1"
      5  227e				  -	      ERR
      6  227e					      ENDIF
      7  227e
      8  227e				  -	      IF	.CYCLES & 1
      9  227e				  -	      IFNCONST	NO_ILLEGAL_OPCODES
     10  227e				  -	      nop	0
     11  227e				  -	      ELSE
     12  227e				  -	      bit	VSYNC
     13  227e				  -	      ENDIF
     14  227e				  -.CYCLES    SET	.CYCLES - 3
     15  227e					      ENDIF
     16  227e
     17  227e					      REPEAT	.CYCLES / 2
     18  227e		       ea		      nop
     19  227f					      REPEND
    115  227f
    116  227f		       b9 63 b7 	      lda	bmp_96x2_1_09,y	;5
    117  2282		       85 1c		      sta	GRP1	;3 =  8
    118  2284		       b9 79 b7 	      lda	bmp_96x2_1_11,y	;5
    119  2287		       85 1c		      sta	GRP1	;3 =  8
    120  2289
      0  2289					      sleep	2
      1  2289				   .CYCLES    SET	2
      2  2289
      3  2289				  -	      IF	.CYCLES < 2
      4  2289				  -	      ECHO	"MACRO ERROR: 'SLEEP': Duration must be > 1"
      5  2289				  -	      ERR
      6  2289					      ENDIF
      7  2289
      8  2289				  -	      IF	.CYCLES & 1
      9  2289				  -	      IFNCONST	NO_ILLEGAL_OPCODES
     10  2289				  -	      nop	0
     11  2289				  -	      ELSE
     12  2289				  -	      bit	VSYNC
     13  2289				  -	      ENDIF
     14  2289				  -.CYCLES    SET	.CYCLES - 3
     15  2289					      ENDIF
     16  2289
     17  2289					      REPEAT	.CYCLES / 2
     18  2289		       ea		      nop
     19  228a					      REPEND
    122  228a		       86 07		      stx	COLUP1
    123  228c		       86 06		      stx	COLUP0
    124  228e
    125  228e		       85 2a		      sta	HMOVE	;3 - CYCLE 74 HMOVE
      0  2290					      sleep	2
      1  2290				   .CYCLES    SET	2
      2  2290
      3  2290				  -	      IF	.CYCLES < 2
      4  2290				  -	      ECHO	"MACRO ERROR: 'SLEEP': Duration must be > 1"
      5  2290				  -	      ERR
      6  2290					      ENDIF
      7  2290
      8  2290				  -	      IF	.CYCLES & 1
      9  2290				  -	      IFNCONST	NO_ILLEGAL_OPCODES
     10  2290				  -	      nop	0
     11  2290				  -	      ELSE
     12  2290				  -	      bit	VSYNC
     13  2290				  -	      ENDIF
     14  2290				  -.CYCLES    SET	.CYCLES - 3
     15  2290					      ENDIF
     16  2290
     17  2290					      REPEAT	.CYCLES / 2
     18  2290		       ea		      nop
     19  2291					      REPEND
    127  2291		       88		      dey
    128  2292
    129  2292		       c4 9c		      cpy	temp1	;3
    130  2294		       d0 99		      bne	pfline_96x2_1_frame0	;2/3
    131  2296
    132  2296				   pf96x2_1_0codeend
    133  2296							;echo "critical code #1 in 96x2_1 is ",(pf96x2_1_0codeend-pfline_96x2_1_frame0), " bytes long."
    134  2296
    135  2296		       a9 00		      lda	#0
    136  2298		       85 1b		      sta	GRP0
    137  229a		       85 1c		      sta	GRP1
    138  229c		       4c 6e b3 	      jmp	pfdone_96x2_1
    139  229f
    140  229f
    141  229f				   pf96x2_1_frame1
    142  229f
    143  229f							;postion P0 and P1
    144  229f		       85 02		      sta	WSYNC
    145  22a1		       a9 20		      lda	#%00100000
    146  22a3		       85 20		      sta	HMP0
    147  22a5		       a9 00		      lda	#0
    148  22a7		       a9 f0		      lda	#%11110000
    149  22a9		       85 21		      sta	HMP1
    150  22ab		       85 02		      sta	WSYNC
      0  22ad					      sleep	32
      1  22ad				   .CYCLES    SET	32
      2  22ad
      3  22ad				  -	      IF	.CYCLES < 2
      4  22ad				  -	      ECHO	"MACRO ERROR: 'SLEEP': Duration must be > 1"
      5  22ad				  -	      ERR
      6  22ad					      ENDIF
      7  22ad
      8  22ad				  -	      IF	.CYCLES & 1
      9  22ad				  -	      IFNCONST	NO_ILLEGAL_OPCODES
     10  22ad				  -	      nop	0
     11  22ad				  -	      ELSE
     12  22ad				  -	      bit	VSYNC
     13  22ad				  -	      ENDIF
     14  22ad				  -.CYCLES    SET	.CYCLES - 3
     15  22ad					      ENDIF
     16  22ad
     17  22ad					      REPEAT	.CYCLES / 2
     18  22ad		       ea		      nop
     17  22ad					      REPEND
     18  22ae		       ea		      nop
     17  22ae					      REPEND
     18  22af		       ea		      nop
     17  22af					      REPEND
     18  22b0		       ea		      nop
     17  22b0					      REPEND
     18  22b1		       ea		      nop
     17  22b1					      REPEND
     18  22b2		       ea		      nop
     17  22b2					      REPEND
     18  22b3		       ea		      nop
     17  22b3					      REPEND
     18  22b4		       ea		      nop
     17  22b4					      REPEND
     18  22b5		       ea		      nop
     17  22b5					      REPEND
     18  22b6		       ea		      nop
     17  22b6					      REPEND
     18  22b7		       ea		      nop
     17  22b7					      REPEND
     18  22b8		       ea		      nop
     17  22b8					      REPEND
     18  22b9		       ea		      nop
     17  22b9					      REPEND
     18  22ba		       ea		      nop
     17  22ba					      REPEND
     18  22bb		       ea		      nop
     17  22bb					      REPEND
     18  22bc		       ea		      nop
     19  22bd					      REPEND
    152  22bd		       85 10		      sta	RESP0
      0  22bf					      sleep	12
      1  22bf				   .CYCLES    SET	12
      2  22bf
      3  22bf				  -	      IF	.CYCLES < 2
      4  22bf				  -	      ECHO	"MACRO ERROR: 'SLEEP': Duration must be > 1"
      5  22bf				  -	      ERR
      6  22bf					      ENDIF
      7  22bf
      8  22bf				  -	      IF	.CYCLES & 1
      9  22bf				  -	      IFNCONST	NO_ILLEGAL_OPCODES
     10  22bf				  -	      nop	0
     11  22bf				  -	      ELSE
     12  22bf				  -	      bit	VSYNC
     13  22bf				  -	      ENDIF
     14  22bf				  -.CYCLES    SET	.CYCLES - 3
     15  22bf					      ENDIF
     16  22bf
     17  22bf					      REPEAT	.CYCLES / 2
     18  22bf		       ea		      nop
     17  22bf					      REPEND
     18  22c0		       ea		      nop
     17  22c0					      REPEND
     18  22c1		       ea		      nop
     17  22c1					      REPEND
     18  22c2		       ea		      nop
     17  22c2					      REPEND
     18  22c3		       ea		      nop
     17  22c3					      REPEND
     18  22c4		       ea		      nop
     19  22c5					      REPEND
    154  22c5		       85 11		      sta	RESP1
    155  22c7		       85 02		      sta	WSYNC
    156  22c9		       85 2a		      sta	HMOVE
    157  22cb
    158  22cb		       85 02		      sta	WSYNC
    159  22cd		       85 2b		      sta	HMCLR
    160  22cf
    161  22cf
    162  22cf
    163  22cf		       85 02		      sta	WSYNC
      0  22d1					      sleep	3
      1  22d1				   .CYCLES    SET	3
      2  22d1
      3  22d1				  -	      IF	.CYCLES < 2
      4  22d1				  -	      ECHO	"MACRO ERROR: 'SLEEP': Duration must be > 1"
      5  22d1				  -	      ERR
      6  22d1					      ENDIF
      7  22d1
      8  22d1					      IF	.CYCLES & 1
      9  22d1					      IFNCONST	NO_ILLEGAL_OPCODES
     10  22d1		       04 00		      nop	0
     11  22d3				  -	      ELSE
     12  22d3				  -	      bit	VSYNC
     13  22d3					      ENDIF
     14  22d3				   .CYCLES    SET	.CYCLES - 3
     15  22d3					      ENDIF
     16  22d3
     17  22d3				  -	      REPEAT	.CYCLES / 2
     18  22d3				  -	      nop
     19  22d3					      REPEND
    165  22d3		       4c 00 b3 	      jmp	pfline_96x2_1_frame1
    166  22d6
    167  22d6							;align so our branch doesn't unexpectedly cross a page...
    168  22d6					      if	>. != >[.+$70]
    169  2300		       00 00 00 00*	      align	256
    170  2300					      endif
    171  2300
    172  2300				   pfline_96x2_1_frame1
    173  2300
    174  2300		       85 2a		      sta	HMOVE
    175  2302
    176  2302		       b9 4d b7 	      lda	bmp_96x2_1_07,y	;4
    177  2305		       85 1c		      sta	GRP1	;3
    178  2307
    179  2307		       a9 00		      lda	#$0	;2
    180  2309		       85 20		      sta	HMP0	;3
    181  230b		       85 21		      sta	HMP1	;3
    182  230d
    183  230d		       b9 0b b7 	      lda	bmp_96x2_1_01,y
    184  2310		       8d 1b 00 	      sta.w	GRP0
    185  2313		       b9 21 b7 	      lda	bmp_96x2_1_03,y
    186  2316		       85 1b		      sta	GRP0
    187  2318		       b9 37 b7 	      lda	bmp_96x2_1_05,y
    188  231b		       85 1b		      sta	GRP0
    189  231d
      0  231d					      sleep	2
      1  231d				   .CYCLES    SET	2
      2  231d
      3  231d				  -	      IF	.CYCLES < 2
      4  231d				  -	      ECHO	"MACRO ERROR: 'SLEEP': Duration must be > 1"
      5  231d				  -	      ERR
      6  231d					      ENDIF
      7  231d
      8  231d				  -	      IF	.CYCLES & 1
      9  231d				  -	      IFNCONST	NO_ILLEGAL_OPCODES
     10  231d				  -	      nop	0
     11  231d				  -	      ELSE
     12  231d				  -	      bit	VSYNC
     13  231d				  -	      ENDIF
     14  231d				  -.CYCLES    SET	.CYCLES - 3
     15  231d					      ENDIF
     16  231d
     17  231d					      REPEAT	.CYCLES / 2
     18  231d		       ea		      nop
     19  231e					      REPEND
    191  231e
    192  231e		       b9 63 b7 	      lda	bmp_96x2_1_09,y
    193  2321		       85 1c		      sta	GRP1
    194  2323		       b9 79 b7 	      lda	bmp_96x2_1_11,y
    195  2326		       85 1c		      sta	GRP1
    196  2328
    197  2328		       b9 00 b7 	      lda	bmp_96x2_1_00,y
    198  232b		       85 1b		      sta	GRP0
    199  232d
    200  232d		       8d 2a 00 	      sta.w	HMOVE	;3 - cycle 74
    201  2330
    202  2330							;sta WSYNC	;=0 -----------------------------------------
    203  2330
    204  2330		       b9 42 b7 	      lda	bmp_96x2_1_06,y
    205  2333		       85 1c		      sta	GRP1
    206  2335
      0  2335					      sleep	8
      1  2335				   .CYCLES    SET	8
      2  2335
      3  2335				  -	      IF	.CYCLES < 2
      4  2335				  -	      ECHO	"MACRO ERROR: 'SLEEP': Duration must be > 1"
      5  2335				  -	      ERR
      6  2335					      ENDIF
      7  2335
      8  2335				  -	      IF	.CYCLES & 1
      9  2335				  -	      IFNCONST	NO_ILLEGAL_OPCODES
     10  2335				  -	      nop	0
     11  2335				  -	      ELSE
     12  2335				  -	      bit	VSYNC
     13  2335				  -	      ENDIF
     14  2335				  -.CYCLES    SET	.CYCLES - 3
     15  2335					      ENDIF
     16  2335
     17  2335					      REPEAT	.CYCLES / 2
     18  2335		       ea		      nop
     17  2335					      REPEND
     18  2336		       ea		      nop
     17  2336					      REPEND
     18  2337		       ea		      nop
     17  2337					      REPEND
     18  2338		       ea		      nop
     19  2339					      REPEND
    208  2339
    209  2339		       b9 eb b6 	      lda	bmp_96x2_1_colors-1,y	;get the title color early and store it for later
    210  233c		       aa		      tax		;2
    211  233d
      0  233d					      sleep	3
      1  233d				   .CYCLES    SET	3
      2  233d
      3  233d				  -	      IF	.CYCLES < 2
      4  233d				  -	      ECHO	"MACRO ERROR: 'SLEEP': Duration must be > 1"
      5  233d				  -	      ERR
      6  233d					      ENDIF
      7  233d
      8  233d					      IF	.CYCLES & 1
      9  233d					      IFNCONST	NO_ILLEGAL_OPCODES
     10  233d		       04 00		      nop	0
     11  233f				  -	      ELSE
     12  233f				  -	      bit	VSYNC
     13  233f					      ENDIF
     14  233f				   .CYCLES    SET	.CYCLES - 3
     15  233f					      ENDIF
     16  233f
     17  233f				  -	      REPEAT	.CYCLES / 2
     18  233f				  -	      nop
     19  233f					      REPEND
    213  233f
    214  233f		       a9 80		      lda	#$80	;2
    215  2341		       85 20		      sta	HMP0	;3
    216  2343		       85 21		      sta	HMP1	;3
    217  2345
    218  2345
    219  2345		       b9 16 b7 	      lda	bmp_96x2_1_02,y	;5
    220  2348		       85 1b		      sta	GRP0	;3 =  8
    221  234a
    222  234a		       b9 2c b7 	      lda	bmp_96x2_1_04,y	;5
    223  234d		       85 1b		      sta	GRP0	;3 =  8
    224  234f
      0  234f					      sleep	2
      1  234f				   .CYCLES    SET	2
      2  234f
      3  234f				  -	      IF	.CYCLES < 2
      4  234f				  -	      ECHO	"MACRO ERROR: 'SLEEP': Duration must be > 1"
      5  234f				  -	      ERR
      6  234f					      ENDIF
      7  234f
      8  234f				  -	      IF	.CYCLES & 1
      9  234f				  -	      IFNCONST	NO_ILLEGAL_OPCODES
     10  234f				  -	      nop	0
     11  234f				  -	      ELSE
     12  234f				  -	      bit	VSYNC
     13  234f				  -	      ENDIF
     14  234f				  -.CYCLES    SET	.CYCLES - 3
     15  234f					      ENDIF
     16  234f
     17  234f					      REPEAT	.CYCLES / 2
     18  234f		       ea		      nop
     19  2350					      REPEND
    226  2350
    227  2350		       b9 58 b7 	      lda	bmp_96x2_1_08,y	;5
    228  2353		       85 1c		      sta	GRP1	;3 =  8
    229  2355
    230  2355		       b9 6e b7 	      lda	bmp_96x2_1_10,y	;5
    231  2358		       85 1c		      sta	GRP1	;3 =  8
    232  235a
      0  235a					      sleep	4
      1  235a				   .CYCLES    SET	4
      2  235a
      3  235a				  -	      IF	.CYCLES < 2
      4  235a				  -	      ECHO	"MACRO ERROR: 'SLEEP': Duration must be > 1"
      5  235a				  -	      ERR
      6  235a					      ENDIF
      7  235a
      8  235a				  -	      IF	.CYCLES & 1
      9  235a				  -	      IFNCONST	NO_ILLEGAL_OPCODES
     10  235a				  -	      nop	0
     11  235a				  -	      ELSE
     12  235a				  -	      bit	VSYNC
     13  235a				  -	      ENDIF
     14  235a				  -.CYCLES    SET	.CYCLES - 3
     15  235a					      ENDIF
     16  235a
     17  235a					      REPEAT	.CYCLES / 2
     18  235a		       ea		      nop
     17  235a					      REPEND
     18  235b		       ea		      nop
     19  235c					      REPEND
    234  235c
    235  235c		       88		      dey
    236  235d
    237  235d		       8a		      txa
    238  235e				  -	      ifconst	bmp_96x2_1_fade
    239  235e				  -	      and	bmp_96x2_1_fade
    240  235e					      else
      0  235e					      sleep	3
      1  235e				   .CYCLES    SET	3
      2  235e
      3  235e				  -	      IF	.CYCLES < 2
      4  235e				  -	      ECHO	"MACRO ERROR: 'SLEEP': Duration must be > 1"
      5  235e				  -	      ERR
      6  235e					      ENDIF
      7  235e
      8  235e					      IF	.CYCLES & 1
      9  235e					      IFNCONST	NO_ILLEGAL_OPCODES
     10  235e		       04 00		      nop	0
     11  2360				  -	      ELSE
     12  2360				  -	      bit	VSYNC
     13  2360					      ENDIF
     14  2360				   .CYCLES    SET	.CYCLES - 3
     15  2360					      ENDIF
     16  2360
     17  2360				  -	      REPEAT	.CYCLES / 2
     18  2360				  -	      nop
     19  2360					      REPEND
    242  2360					      endif
    243  2360		       85 07		      sta	COLUP1	;3
    244  2362		       85 06		      sta	COLUP0	;3
    245  2364
    246  2364		       c4 9c		      cpy	temp1	;2
    247  2366		       d0 98		      bne	pfline_96x2_1_frame1	;2/3
    248  2368
    249  2368				   pf96x2_1_1codeend
    250  2368							;echo "critical code #2 in 96x2_1 is ",(pf96x2_1_1codeend-pfline_96x2_1_frame1), " bytes long."
    251  2368
    252  2368		       a9 00		      lda	#0
    253  236a		       85 1b		      sta	GRP0
    254  236c		       85 1c		      sta	GRP1
    255  236e
    256  236e				   pfdone_96x2_1
    257  236e		       85 02		      sta	WSYNC	; debug
    258  2370
    259  2370		       60		      rts
------- FILE titlescreen/asm/titlescreen.asm
    149  2371					      endif		;mk_96x2_1_on
    150  2371
    151  2371				  -	      ifconst	mk_96x2_2_on
    152  2371				  -	      include	"titlescreen/asm/96x2_2_kernel.asm"
    153  2371					      endif		;mk_96x2_2_on
    154  2371
    155  2371				  -	      ifconst	mk_96x2_3_on
    156  2371				  -	      include	"titlescreen/asm/96x2_3_kernel.asm"
    157  2371					      endif		;mk_96x2_3_on
    158  2371
    159  2371				  -	      ifconst	mk_96x2_4_on
    160  2371				  -	      include	"titlescreen/asm/96x2_4_kernel.asm"
    161  2371					      endif		;mk_96x2_4_on
    162  2371
    163  2371				  -	      ifconst	mk_96x2_5_on
    164  2371				  -	      include	"titlescreen/asm/96x2_5_kernel.asm"
    165  2371					      endif		;mk_96x2_5_on
    166  2371
    167  2371				  -	      ifconst	mk_96x2_6_on
    168  2371				  -	      include	"titlescreen/asm/96x2_6_kernel.asm"
    169  2371					      endif		;mk_96x2_6_on
    170  2371
    171  2371				  -	      ifconst	mk_96x2_7_on
    172  2371				  -	      include	"titlescreen/asm/96x2_7_kernel.asm"
    173  2371					      endif		;mk_96x2_7_on
    174  2371
    175  2371				  -	      ifconst	mk_96x2_8_on
    176  2371				  -	      include	"titlescreen/asm/96x2_8_kernel.asm"
    177  2371					      endif		;mk_96x2_8_on
    178  2371
    179  2371				  -	      ifconst	mk_score_on
    180  2371				  -	      include	"titlescreen/asm/score_kernel.asm"
    181  2371					      endif		;mk_score_on
    182  2371
    183  2371				  -	      ifconst	mk_gameselect_on
    184  2371				  -	      include	"titlescreen/asm/gameselect_kernel.asm"
    185  2371					      endif		;mk_gameselect_on
    186  2371
    187  2371				   PFWAIT
    188  2371		       ad 84 02 	      lda	INTIM
    189  2374		       d0 fb		      bne	PFWAIT
    190  2376		       85 02		      sta	WSYNC
    191  2378
    192  2378				   OVERSCAN
    193  2378				  -	      ifnconst	overscan_time
    194  2378				  -	      lda	#34+128
    195  2378					      else
    196  2378		       a9 cd		      lda	#overscan_time+128-5
    197  237a					      endif
    198  237a		       8d 96 02 	      sta	TIM64T
    199  237d
    200  237d							;fix height variables we borrowed, so DPC doesn't crash on drawscreen...
    201  237d				  -	      ifconst	player9height
    202  237d				  -	      ldy	#8
    203  237d				  -	      lda	#0
    204  237d				  -	      sta	player0height
    205  237d				  -.playerheightfixloop
    206  237d				  -	      sta	player1height,y
    207  237d				  -	      ifconst	_NUSIZ1
    208  237d				  -	      sta	_NUSIZ1,y
    209  237d				  -	      endif
    210  237d				  -	      dey
    211  237d				  -	      bpl	.playerheightfixloop
    212  237d					      endif
    213  237d
    214  237d		       a9 c2		      lda	#%11000010
    215  237f		       85 02		      sta	WSYNC
    216  2381		       85 01		      sta	VBLANK
      0  2383					      RETURN
      1  2383				  -	      ifnconst	bankswitch
      2  2383				  -	      rts
      3  2383					      else
      4  2383		       4c dd ff 	      jmp	BS_return
      5  2386					      endif
    218  2386
    219  2386					      ifconst	mk_48x1_1_on
------- FILE titlescreen/48x1_1_image.asm LEVEL 3 PASS 2
      0  2386					      include	"titlescreen/48x1_1_image.asm"
      1  2386
      2  2386
      3  2386							; *** if you want to modify the bitmap color on the fly, just dim a
      4  2386							; *** variable in bB called "bmp_48x1_1_color", and use it to set the
      5  2386							; *** color.
      6  2386
      7  2386
      8  2386							;*** this is the height of the displayed data
      9  2386		       00 60	   bmp_48x1_1_window =	96
     10  2386
     11  2386							;*** this is the height of the bitmap data
     12  2386		       00 60	   bmp_48x1_1_height =	96
     13  2386
     14  2386				  -	      ifnconst	bmp_48x1_1_color
     15  2386				  -bmp_48x1_1_color
     16  2386					      endif
     17  2386		       42		      .byte.b	$42
     18  2387
     19  2387				  -	      ifnconst	bmp_48x1_1_PF1
     20  2387				  -bmp_48x1_1_PF1
     21  2387					      endif
     22  2387		       00		      BYTE.b	%00000000
     23  2388				  -	      ifnconst	bmp_48x1_1_PF2
     24  2388				  -bmp_48x1_1_PF2
     25  2388					      endif
     26  2388		       00		      BYTE.b	%00000000
     27  2389				  -	      ifnconst	bmp_48x1_1_background
     28  2389				  -bmp_48x1_1_background
     29  2389					      endif
     30  2389		       00		      BYTE.b	$00
     31  238a
     32  238a				  -	      if	>. != >[.+bmp_48x1_1_height]
     33  238a				  -	      align	256
     34  238a					      endif
     35  238a
     36  238a				   bmp_48x1_1_00
     37  238a		       00		      BYTE.b	%00000000
     38  238b		       04		      BYTE.b	%00000100
     39  238c		       04		      BYTE.b	%00000100
     40  238d		       0e		      BYTE.b	%00001110
     41  238e		       0e		      BYTE.b	%00001110
     42  238f		       0e		      BYTE.b	%00001110
     43  2390		       0e		      BYTE.b	%00001110
     44  2391		       1e		      BYTE.b	%00011110
     45  2392		       1e		      BYTE.b	%00011110
     46  2393		       1e		      BYTE.b	%00011110
     47  2394		       1e		      BYTE.b	%00011110
     48  2395		       1e		      BYTE.b	%00011110
     49  2396		       3f		      BYTE.b	%00111111
     50  2397		       37		      BYTE.b	%00110111
     51  2398		       37		      BYTE.b	%00110111
     52  2399		       33		      BYTE.b	%00110011
     53  239a		       33		      BYTE.b	%00110011
     54  239b		       23		      BYTE.b	%00100011
     55  239c		       23		      BYTE.b	%00100011
     56  239d		       23		      BYTE.b	%00100011
     57  239e		       23		      BYTE.b	%00100011
     58  239f		       23		      BYTE.b	%00100011
     59  23a0		       03		      BYTE.b	%00000011
     60  23a1		       03		      BYTE.b	%00000011
     61  23a2		       03		      BYTE.b	%00000011
     62  23a3		       03		      BYTE.b	%00000011
     63  23a4		       03		      BYTE.b	%00000011
     64  23a5		       03		      BYTE.b	%00000011
     65  23a6		       01		      BYTE.b	%00000001
     66  23a7		       01		      BYTE.b	%00000001
     67  23a8		       01		      BYTE.b	%00000001
     68  23a9		       01		      BYTE.b	%00000001
     69  23aa		       01		      BYTE.b	%00000001
     70  23ab		       01		      BYTE.b	%00000001
     71  23ac		       01		      BYTE.b	%00000001
     72  23ad		       01		      BYTE.b	%00000001
     73  23ae		       01		      BYTE.b	%00000001
     74  23af		       01		      BYTE.b	%00000001
     75  23b0		       01		      BYTE.b	%00000001
     76  23b1		       01		      BYTE.b	%00000001
     77  23b2		       01		      BYTE.b	%00000001
     78  23b3		       01		      BYTE.b	%00000001
     79  23b4		       01		      BYTE.b	%00000001
     80  23b5		       01		      BYTE.b	%00000001
     81  23b6		       01		      BYTE.b	%00000001
     82  23b7		       01		      BYTE.b	%00000001
     83  23b8		       01		      BYTE.b	%00000001
     84  23b9		       01		      BYTE.b	%00000001
     85  23ba		       01		      BYTE.b	%00000001
     86  23bb		       01		      BYTE.b	%00000001
     87  23bc		       01		      BYTE.b	%00000001
     88  23bd		       01		      BYTE.b	%00000001
     89  23be		       01		      BYTE.b	%00000001
     90  23bf		       01		      BYTE.b	%00000001
     91  23c0		       01		      BYTE.b	%00000001
     92  23c1		       01		      BYTE.b	%00000001
     93  23c2		       01		      BYTE.b	%00000001
     94  23c3		       01		      BYTE.b	%00000001
     95  23c4		       01		      BYTE.b	%00000001
     96  23c5		       00		      BYTE.b	%00000000
     97  23c6		       00		      BYTE.b	%00000000
     98  23c7		       00		      BYTE.b	%00000000
     99  23c8		       00		      BYTE.b	%00000000
    100  23c9		       00		      BYTE.b	%00000000
    101  23ca		       00		      BYTE.b	%00000000
    102  23cb		       00		      BYTE.b	%00000000
    103  23cc		       00		      BYTE.b	%00000000
    104  23cd		       00		      BYTE.b	%00000000
    105  23ce		       00		      BYTE.b	%00000000
    106  23cf		       00		      BYTE.b	%00000000
    107  23d0		       00		      BYTE.b	%00000000
    108  23d1		       00		      BYTE.b	%00000000
    109  23d2		       00		      BYTE.b	%00000000
    110  23d3		       00		      BYTE.b	%00000000
    111  23d4		       0f		      BYTE.b	%00001111
    112  23d5		       0f		      BYTE.b	%00001111
    113  23d6		       0f		      BYTE.b	%00001111
    114  23d7		       0f		      BYTE.b	%00001111
    115  23d8		       0f		      BYTE.b	%00001111
    116  23d9		       0f		      BYTE.b	%00001111
    117  23da		       0f		      BYTE.b	%00001111
    118  23db		       0f		      BYTE.b	%00001111
    119  23dc		       0f		      BYTE.b	%00001111
    120  23dd		       0f		      BYTE.b	%00001111
    121  23de		       0f		      BYTE.b	%00001111
    122  23df		       0f		      BYTE.b	%00001111
    123  23e0		       0f		      BYTE.b	%00001111
    124  23e1		       0f		      BYTE.b	%00001111
    125  23e2		       0f		      BYTE.b	%00001111
    126  23e3		       0b		      BYTE.b	%00001011
    127  23e4		       0b		      BYTE.b	%00001011
    128  23e5		       00		      BYTE.b	%00000000
    129  23e6		       00		      BYTE.b	%00000000
    130  23e7		       00		      BYTE.b	%00000000
    131  23e8		       00		      BYTE.b	%00000000
    132  23e9		       00		      BYTE.b	%00000000
    133  23ea
    134  23ea					      if	>. != >[.+(bmp_48x1_1_height)]
    135  2400		       00 00 00 00*	      align	256
    136  2400					      endif
    137  2400
    138  2400				   bmp_48x1_1_01
    139  2400		       00		      BYTE.b	%00000000
    140  2401		       00		      BYTE.b	%00000000
    141  2402		       00		      BYTE.b	%00000000
    142  2403		       00		      BYTE.b	%00000000
    143  2404		       00		      BYTE.b	%00000000
    144  2405		       00		      BYTE.b	%00000000
    145  2406		       00		      BYTE.b	%00000000
    146  2407		       02		      BYTE.b	%00000010
    147  2408		       02		      BYTE.b	%00000010
    148  2409		       07		      BYTE.b	%00000111
    149  240a		       07		      BYTE.b	%00000111
    150  240b		       07		      BYTE.b	%00000111
    151  240c		       07		      BYTE.b	%00000111
    152  240d		       07		      BYTE.b	%00000111
    153  240e		       07		      BYTE.b	%00000111
    154  240f		       07		      BYTE.b	%00000111
    155  2410		       07		      BYTE.b	%00000111
    156  2411		       07		      BYTE.b	%00000111
    157  2412		       07		      BYTE.b	%00000111
    158  2413		       07		      BYTE.b	%00000111
    159  2414		       07		      BYTE.b	%00000111
    160  2415		       07		      BYTE.b	%00000111
    161  2416		       06		      BYTE.b	%00000110
    162  2417		       86		      BYTE.b	%10000110
    163  2418		       86		      BYTE.b	%10000110
    164  2419		       86		      BYTE.b	%10000110
    165  241a		       86		      BYTE.b	%10000110
    166  241b		       86		      BYTE.b	%10000110
    167  241c		       86		      BYTE.b	%10000110
    168  241d		       86		      BYTE.b	%10000110
    169  241e		       86		      BYTE.b	%10000110
    170  241f		       86		      BYTE.b	%10000110
    171  2420		       86		      BYTE.b	%10000110
    172  2421		       86		      BYTE.b	%10000110
    173  2422		       86		      BYTE.b	%10000110
    174  2423		       86		      BYTE.b	%10000110
    175  2424		       86		      BYTE.b	%10000110
    176  2425		       86		      BYTE.b	%10000110
    177  2426		       86		      BYTE.b	%10000110
    178  2427		       87		      BYTE.b	%10000111
    179  2428		       83		      BYTE.b	%10000011
    180  2429		       83		      BYTE.b	%10000011
    181  242a		       83		      BYTE.b	%10000011
    182  242b		       83		      BYTE.b	%10000011
    183  242c		       83		      BYTE.b	%10000011
    184  242d		       83		      BYTE.b	%10000011
    185  242e		       83		      BYTE.b	%10000011
    186  242f		       83		      BYTE.b	%10000011
    187  2430		       83		      BYTE.b	%10000011
    188  2431		       83		      BYTE.b	%10000011
    189  2432		       83		      BYTE.b	%10000011
    190  2433		       83		      BYTE.b	%10000011
    191  2434		       c3		      BYTE.b	%11000011
    192  2435		       c3		      BYTE.b	%11000011
    193  2436		       c3		      BYTE.b	%11000011
    194  2437		       c3		      BYTE.b	%11000011
    195  2438		       c3		      BYTE.b	%11000011
    196  2439		       c3		      BYTE.b	%11000011
    197  243a		       c3		      BYTE.b	%11000011
    198  243b		       c3		      BYTE.b	%11000011
    199  243c		       c1		      BYTE.b	%11000001
    200  243d		       c1		      BYTE.b	%11000001
    201  243e		       c1		      BYTE.b	%11000001
    202  243f		       c1		      BYTE.b	%11000001
    203  2440		       c1		      BYTE.b	%11000001
    204  2441		       c1		      BYTE.b	%11000001
    205  2442		       c1		      BYTE.b	%11000001
    206  2443		       c1		      BYTE.b	%11000001
    207  2444		       c1		      BYTE.b	%11000001
    208  2445		       c1		      BYTE.b	%11000001
    209  2446		       c1		      BYTE.b	%11000001
    210  2447		       c1		      BYTE.b	%11000001
    211  2448		       c1		      BYTE.b	%11000001
    212  2449		       c1		      BYTE.b	%11000001
    213  244a		       c1		      BYTE.b	%11000001
    214  244b		       c1		      BYTE.b	%11000001
    215  244c		       e1		      BYTE.b	%11100001
    216  244d		       e0		      BYTE.b	%11100000
    217  244e		       e0		      BYTE.b	%11100000
    218  244f		       f0		      BYTE.b	%11110000
    219  2450		       f0		      BYTE.b	%11110000
    220  2451		       f0		      BYTE.b	%11110000
    221  2452		       f0		      BYTE.b	%11110000
    222  2453		       f8		      BYTE.b	%11111000
    223  2454		       f8		      BYTE.b	%11111000
    224  2455		       f8		      BYTE.b	%11111000
    225  2456		       f8		      BYTE.b	%11111000
    226  2457		       f8		      BYTE.b	%11111000
    227  2458		       fc		      BYTE.b	%11111100
    228  2459		       fc		      BYTE.b	%11111100
    229  245a		       fe		      BYTE.b	%11111110
    230  245b		       7e		      BYTE.b	%01111110
    231  245c		       7c		      BYTE.b	%01111100
    232  245d		       1c		      BYTE.b	%00011100
    233  245e		       1c		      BYTE.b	%00011100
    234  245f		       00		      BYTE.b	%00000000
    235  2460
    236  2460				  -	      if	>. != >[.+(bmp_48x1_1_height)]
    237  2460				  -	      align	256
    238  2460					      endif
    239  2460
    240  2460				   bmp_48x1_1_02
    241  2460		       00		      BYTE.b	%00000000
    242  2461		       00		      BYTE.b	%00000000
    243  2462		       00		      BYTE.b	%00000000
    244  2463		       60		      BYTE.b	%01100000
    245  2464		       60		      BYTE.b	%01100000
    246  2465		       70		      BYTE.b	%01110000
    247  2466		       70		      BYTE.b	%01110000
    248  2467		       70		      BYTE.b	%01110000
    249  2468		       70		      BYTE.b	%01110000
    250  2469		       78		      BYTE.b	%01111000
    251  246a		       78		      BYTE.b	%01111000
    252  246b		       78		      BYTE.b	%01111000
    253  246c		       78		      BYTE.b	%01111000
    254  246d		       78		      BYTE.b	%01111000
    255  246e		       78		      BYTE.b	%01111000
    256  246f		       78		      BYTE.b	%01111000
    257  2470		       f8		      BYTE.b	%11111000
    258  2471		       f0		      BYTE.b	%11110000
    259  2472		       f0		      BYTE.b	%11110000
    260  2473		       f0		      BYTE.b	%11110000
    261  2474		       f0		      BYTE.b	%11110000
    262  2475		       f0		      BYTE.b	%11110000
    263  2476		       f0		      BYTE.b	%11110000
    264  2477		       f0		      BYTE.b	%11110000
    265  2478		       f0		      BYTE.b	%11110000
    266  2479		       f0		      BYTE.b	%11110000
    267  247a		       f0		      BYTE.b	%11110000
    268  247b		       f0		      BYTE.b	%11110000
    269  247c		       70		      BYTE.b	%01110000
    270  247d		       70		      BYTE.b	%01110000
    271  247e		       70		      BYTE.b	%01110000
    272  247f		       70		      BYTE.b	%01110000
    273  2480		       70		      BYTE.b	%01110000
    274  2481		       70		      BYTE.b	%01110000
    275  2482		       70		      BYTE.b	%01110000
    276  2483		       70		      BYTE.b	%01110000
    277  2484		       70		      BYTE.b	%01110000
    278  2485		       30		      BYTE.b	%00110000
    279  2486		       30		      BYTE.b	%00110000
    280  2487		       30		      BYTE.b	%00110000
    281  2488		       30		      BYTE.b	%00110000
    282  2489		       38		      BYTE.b	%00111000
    283  248a		       38		      BYTE.b	%00111000
    284  248b		       38		      BYTE.b	%00111000
    285  248c		       38		      BYTE.b	%00111000
    286  248d		       38		      BYTE.b	%00111000
    287  248e		       38		      BYTE.b	%00111000
    288  248f		       38		      BYTE.b	%00111000
    289  2490		       38		      BYTE.b	%00111000
    290  2491		       38		      BYTE.b	%00111000
    291  2492		       38		      BYTE.b	%00111000
    292  2493		       38		      BYTE.b	%00111000
    293  2494		       b8		      BYTE.b	%10111000
    294  2495		       b8		      BYTE.b	%10111000
    295  2496		       b8		      BYTE.b	%10111000
    296  2497		       b8		      BYTE.b	%10111000
    297  2498		       b8		      BYTE.b	%10111000
    298  2499		       98		      BYTE.b	%10011000
    299  249a		       9c		      BYTE.b	%10011100
    300  249b		       9c		      BYTE.b	%10011100
    301  249c		       9c		      BYTE.b	%10011100
    302  249d		       9c		      BYTE.b	%10011100
    303  249e		       9c		      BYTE.b	%10011100
    304  249f		       9c		      BYTE.b	%10011100
    305  24a0		       9c		      BYTE.b	%10011100
    306  24a1		       9c		      BYTE.b	%10011100
    307  24a2		       9c		      BYTE.b	%10011100
    308  24a3		       dc		      BYTE.b	%11011100
    309  24a4		       dc		      BYTE.b	%11011100
    310  24a5		       dc		      BYTE.b	%11011100
    311  24a6		       dc		      BYTE.b	%11011100
    312  24a7		       dc		      BYTE.b	%11011100
    313  24a8		       de		      BYTE.b	%11011110
    314  24a9		       de		      BYTE.b	%11011110
    315  24aa		       de		      BYTE.b	%11011110
    316  24ab		       ce		      BYTE.b	%11001110
    317  24ac		       ce		      BYTE.b	%11001110
    318  24ad		       ce		      BYTE.b	%11001110
    319  24ae		       ce		      BYTE.b	%11001110
    320  24af		       ce		      BYTE.b	%11001110
    321  24b0		       cc		      BYTE.b	%11001100
    322  24b1		       cc		      BYTE.b	%11001100
    323  24b2		       cc		      BYTE.b	%11001100
    324  24b3		       cc		      BYTE.b	%11001100
    325  24b4		       cc		      BYTE.b	%11001100
    326  24b5		       cc		      BYTE.b	%11001100
    327  24b6		       cc		      BYTE.b	%11001100
    328  24b7		       cc		      BYTE.b	%11001100
    329  24b8		       c0		      BYTE.b	%11000000
    330  24b9		       c0		      BYTE.b	%11000000
    331  24ba		       c0		      BYTE.b	%11000000
    332  24bb		       40		      BYTE.b	%01000000
    333  24bc		       40		      BYTE.b	%01000000
    334  24bd		       40		      BYTE.b	%01000000
    335  24be		       40		      BYTE.b	%01000000
    336  24bf		       40		      BYTE.b	%01000000
    337  24c0
    338  24c0					      if	>. != >[.+(bmp_48x1_1_height)]
    339  2500		       00 00 00 00*	      align	256
    340  2500					      endif
    341  2500
    342  2500				   bmp_48x1_1_03
    343  2500		       00		      BYTE.b	%00000000
    344  2501		       00		      BYTE.b	%00000000
    345  2502		       00		      BYTE.b	%00000000
    346  2503		       20		      BYTE.b	%00100000
    347  2504		       20		      BYTE.b	%00100000
    348  2505		       20		      BYTE.b	%00100000
    349  2506		       20		      BYTE.b	%00100000
    350  2507		       20		      BYTE.b	%00100000
    351  2508		       20		      BYTE.b	%00100000
    352  2509		       20		      BYTE.b	%00100000
    353  250a		       30		      BYTE.b	%00110000
    354  250b		       30		      BYTE.b	%00110000
    355  250c		       30		      BYTE.b	%00110000
    356  250d		       30		      BYTE.b	%00110000
    357  250e		       30		      BYTE.b	%00110000
    358  250f		       30		      BYTE.b	%00110000
    359  2510		       30		      BYTE.b	%00110000
    360  2511		       30		      BYTE.b	%00110000
    361  2512		       30		      BYTE.b	%00110000
    362  2513		       30		      BYTE.b	%00110000
    363  2514		       30		      BYTE.b	%00110000
    364  2515		       31		      BYTE.b	%00110001
    365  2516		       31		      BYTE.b	%00110001
    366  2517		       39		      BYTE.b	%00111001
    367  2518		       39		      BYTE.b	%00111001
    368  2519		       39		      BYTE.b	%00111001
    369  251a		       39		      BYTE.b	%00111001
    370  251b		       3b		      BYTE.b	%00111011
    371  251c		       3b		      BYTE.b	%00111011
    372  251d		       3b		      BYTE.b	%00111011
    373  251e		       1b		      BYTE.b	%00011011
    374  251f		       1b		      BYTE.b	%00011011
    375  2520		       1b		      BYTE.b	%00011011
    376  2521		       1b		      BYTE.b	%00011011
    377  2522		       1f		      BYTE.b	%00011111
    378  2523		       1f		      BYTE.b	%00011111
    379  2524		       1f		      BYTE.b	%00011111
    380  2525		       1f		      BYTE.b	%00011111
    381  2526		       1f		      BYTE.b	%00011111
    382  2527		       1f		      BYTE.b	%00011111
    383  2528		       1f		      BYTE.b	%00011111
    384  2529		       1f		      BYTE.b	%00011111
    385  252a		       1e		      BYTE.b	%00011110
    386  252b		       1e		      BYTE.b	%00011110
    387  252c		       1e		      BYTE.b	%00011110
    388  252d		       1f		      BYTE.b	%00011111
    389  252e		       1f		      BYTE.b	%00011111
    390  252f		       3f		      BYTE.b	%00111111
    391  2530		       3f		      BYTE.b	%00111111
    392  2531		       3f		      BYTE.b	%00111111
    393  2532		       3f		      BYTE.b	%00111111
    394  2533		       3f		      BYTE.b	%00111111
    395  2534		       3f		      BYTE.b	%00111111
    396  2535		       19		      BYTE.b	%00011001
    397  2536		       19		      BYTE.b	%00011001
    398  2537		       09		      BYTE.b	%00001001
    399  2538		       0d		      BYTE.b	%00001101
    400  2539		       0c		      BYTE.b	%00001100
    401  253a		       0c		      BYTE.b	%00001100
    402  253b		       0c		      BYTE.b	%00001100
    403  253c		       0c		      BYTE.b	%00001100
    404  253d		       0c		      BYTE.b	%00001100
    405  253e		       0c		      BYTE.b	%00001100
    406  253f		       0c		      BYTE.b	%00001100
    407  2540		       0c		      BYTE.b	%00001100
    408  2541		       0c		      BYTE.b	%00001100
    409  2542		       0c		      BYTE.b	%00001100
    410  2543		       0c		      BYTE.b	%00001100
    411  2544		       1e		      BYTE.b	%00011110
    412  2545		       1e		      BYTE.b	%00011110
    413  2546		       1e		      BYTE.b	%00011110
    414  2547		       1e		      BYTE.b	%00011110
    415  2548		       3e		      BYTE.b	%00111110
    416  2549		       3e		      BYTE.b	%00111110
    417  254a		       3e		      BYTE.b	%00111110
    418  254b		       3e		      BYTE.b	%00111110
    419  254c		       3f		      BYTE.b	%00111111
    420  254d		       3f		      BYTE.b	%00111111
    421  254e		       3f		      BYTE.b	%00111111
    422  254f		       3f		      BYTE.b	%00111111
    423  2550		       3f		      BYTE.b	%00111111
    424  2551		       3f		      BYTE.b	%00111111
    425  2552		       1f		      BYTE.b	%00011111
    426  2553		       1f		      BYTE.b	%00011111
    427  2554		       1f		      BYTE.b	%00011111
    428  2555		       1f		      BYTE.b	%00011111
    429  2556		       1f		      BYTE.b	%00011111
    430  2557		       1f		      BYTE.b	%00011111
    431  2558		       0f		      BYTE.b	%00001111
    432  2559		       0f		      BYTE.b	%00001111
    433  255a		       0f		      BYTE.b	%00001111
    434  255b		       03		      BYTE.b	%00000011
    435  255c		       03		      BYTE.b	%00000011
    436  255d		       01		      BYTE.b	%00000001
    437  255e		       01		      BYTE.b	%00000001
    438  255f		       00		      BYTE.b	%00000000
    439  2560
    440  2560				  -	      if	>. != >[.+(bmp_48x1_1_height)]
    441  2560				  -	      align	256
    442  2560					      endif
    443  2560
    444  2560				   bmp_48x1_1_04
    445  2560		       00		      BYTE.b	%00000000
    446  2561		       01		      BYTE.b	%00000001
    447  2562		       01		      BYTE.b	%00000001
    448  2563		       1b		      BYTE.b	%00011011
    449  2564		       1b		      BYTE.b	%00011011
    450  2565		       1b		      BYTE.b	%00011011
    451  2566		       13		      BYTE.b	%00010011
    452  2567		       13		      BYTE.b	%00010011
    453  2568		       13		      BYTE.b	%00010011
    454  2569		       33		      BYTE.b	%00110011
    455  256a		       33		      BYTE.b	%00110011
    456  256b		       33		      BYTE.b	%00110011
    457  256c		       7b		      BYTE.b	%01111011
    458  256d		       7b		      BYTE.b	%01111011
    459  256e		       7f		      BYTE.b	%01111111
    460  256f		       7f		      BYTE.b	%01111111
    461  2570		       7f		      BYTE.b	%01111111
    462  2571		       77		      BYTE.b	%01110111
    463  2572		       f7		      BYTE.b	%11110111
    464  2573		       f7		      BYTE.b	%11110111
    465  2574		       f7		      BYTE.b	%11110111
    466  2575		       f3		      BYTE.b	%11110011
    467  2576		       e3		      BYTE.b	%11100011
    468  2577		       e3		      BYTE.b	%11100011
    469  2578		       e3		      BYTE.b	%11100011
    470  2579		       e3		      BYTE.b	%11100011
    471  257a		       c3		      BYTE.b	%11000011
    472  257b		       c3		      BYTE.b	%11000011
    473  257c		       c3		      BYTE.b	%11000011
    474  257d		       c3		      BYTE.b	%11000011
    475  257e		       c3		      BYTE.b	%11000011
    476  257f		       83		      BYTE.b	%10000011
    477  2580		       83		      BYTE.b	%10000011
    478  2581		       83		      BYTE.b	%10000011
    479  2582		       83		      BYTE.b	%10000011
    480  2583		       83		      BYTE.b	%10000011
    481  2584		       83		      BYTE.b	%10000011
    482  2585		       03		      BYTE.b	%00000011
    483  2586		       03		      BYTE.b	%00000011
    484  2587		       03		      BYTE.b	%00000011
    485  2588		       03		      BYTE.b	%00000011
    486  2589		       03		      BYTE.b	%00000011
    487  258a		       03		      BYTE.b	%00000011
    488  258b		       03		      BYTE.b	%00000011
    489  258c		       03		      BYTE.b	%00000011
    490  258d		       03		      BYTE.b	%00000011
    491  258e		       01		      BYTE.b	%00000001
    492  258f		       01		      BYTE.b	%00000001
    493  2590		       81		      BYTE.b	%10000001
    494  2591		       81		      BYTE.b	%10000001
    495  2592		       c1		      BYTE.b	%11000001
    496  2593		       c1		      BYTE.b	%11000001
    497  2594		       c1		      BYTE.b	%11000001
    498  2595		       c1		      BYTE.b	%11000001
    499  2596		       e1		      BYTE.b	%11100001
    500  2597		       e1		      BYTE.b	%11100001
    501  2598		       e1		      BYTE.b	%11100001
    502  2599		       e1		      BYTE.b	%11100001
    503  259a		       e1		      BYTE.b	%11100001
    504  259b		       e1		      BYTE.b	%11100001
    505  259c		       e1		      BYTE.b	%11100001
    506  259d		       e1		      BYTE.b	%11100001
    507  259e		       61		      BYTE.b	%01100001
    508  259f		       71		      BYTE.b	%01110001
    509  25a0		       71		      BYTE.b	%01110001
    510  25a1		       71		      BYTE.b	%01110001
    511  25a2		       70		      BYTE.b	%01110000
    512  25a3		       70		      BYTE.b	%01110000
    513  25a4		       70		      BYTE.b	%01110000
    514  25a5		       70		      BYTE.b	%01110000
    515  25a6		       70		      BYTE.b	%01110000
    516  25a7		       70		      BYTE.b	%01110000
    517  25a8		       70		      BYTE.b	%01110000
    518  25a9		       70		      BYTE.b	%01110000
    519  25aa		       f0		      BYTE.b	%11110000
    520  25ab		       f0		      BYTE.b	%11110000
    521  25ac		       f0		      BYTE.b	%11110000
    522  25ad		       f0		      BYTE.b	%11110000
    523  25ae		       f0		      BYTE.b	%11110000
    524  25af		       f0		      BYTE.b	%11110000
    525  25b0		       f0		      BYTE.b	%11110000
    526  25b1		       f0		      BYTE.b	%11110000
    527  25b2		       f0		      BYTE.b	%11110000
    528  25b3		       f0		      BYTE.b	%11110000
    529  25b4		       e0		      BYTE.b	%11100000
    530  25b5		       e0		      BYTE.b	%11100000
    531  25b6		       e0		      BYTE.b	%11100000
    532  25b7		       e0		      BYTE.b	%11100000
    533  25b8		       e0		      BYTE.b	%11100000
    534  25b9		       c0		      BYTE.b	%11000000
    535  25ba		       c0		      BYTE.b	%11000000
    536  25bb		       c0		      BYTE.b	%11000000
    537  25bc		       c0		      BYTE.b	%11000000
    538  25bd		       80		      BYTE.b	%10000000
    539  25be		       80		      BYTE.b	%10000000
    540  25bf		       00		      BYTE.b	%00000000
    541  25c0
    542  25c0					      if	>. != >[.+(bmp_48x1_1_height)]
    543  2600		       00 00 00 00*	      align	256
    544  2600					      endif
    545  2600
    546  2600				   bmp_48x1_1_05
    547  2600		       00		      BYTE.b	%00000000
    548  2601		       00		      BYTE.b	%00000000
    549  2602		       00		      BYTE.b	%00000000
    550  2603		       80		      BYTE.b	%10000000
    551  2604		       80		      BYTE.b	%10000000
    552  2605		       c0		      BYTE.b	%11000000
    553  2606		       c0		      BYTE.b	%11000000
    554  2607		       c0		      BYTE.b	%11000000
    555  2608		       c0		      BYTE.b	%11000000
    556  2609		       e0		      BYTE.b	%11100000
    557  260a		       f0		      BYTE.b	%11110000
    558  260b		       f0		      BYTE.b	%11110000
    559  260c		       f0		      BYTE.b	%11110000
    560  260d		       f0		      BYTE.b	%11110000
    561  260e		       f8		      BYTE.b	%11111000
    562  260f		       f8		      BYTE.b	%11111000
    563  2610		       f8		      BYTE.b	%11111000
    564  2611		       f8		      BYTE.b	%11111000
    565  2612		       f8		      BYTE.b	%11111000
    566  2613		       f8		      BYTE.b	%11111000
    567  2614		       fc		      BYTE.b	%11111100
    568  2615		       fc		      BYTE.b	%11111100
    569  2616		       3c		      BYTE.b	%00111100
    570  2617		       3c		      BYTE.b	%00111100
    571  2618		       1c		      BYTE.b	%00011100
    572  2619		       1c		      BYTE.b	%00011100
    573  261a		       0c		      BYTE.b	%00001100
    574  261b		       0c		      BYTE.b	%00001100
    575  261c		       04		      BYTE.b	%00000100
    576  261d		       06		      BYTE.b	%00000110
    577  261e		       06		      BYTE.b	%00000110
    578  261f		       02		      BYTE.b	%00000010
    579  2620		       00		      BYTE.b	%00000000
    580  2621		       00		      BYTE.b	%00000000
    581  2622		       00		      BYTE.b	%00000000
    582  2623		       00		      BYTE.b	%00000000
    583  2624		       00		      BYTE.b	%00000000
    584  2625		       00		      BYTE.b	%00000000
    585  2626		       00		      BYTE.b	%00000000
    586  2627		       00		      BYTE.b	%00000000
    587  2628		       00		      BYTE.b	%00000000
    588  2629		       00		      BYTE.b	%00000000
    589  262a		       00		      BYTE.b	%00000000
    590  262b		       00		      BYTE.b	%00000000
    591  262c		       00		      BYTE.b	%00000000
    592  262d		       80		      BYTE.b	%10000000
    593  262e		       80		      BYTE.b	%10000000
    594  262f		       80		      BYTE.b	%10000000
    595  2630		       80		      BYTE.b	%10000000
    596  2631		       80		      BYTE.b	%10000000
    597  2632		       80		      BYTE.b	%10000000
    598  2633		       80		      BYTE.b	%10000000
    599  2634		       80		      BYTE.b	%10000000
    600  2635		       80		      BYTE.b	%10000000
    601  2636		       80		      BYTE.b	%10000000
    602  2637		       80		      BYTE.b	%10000000
    603  2638		       80		      BYTE.b	%10000000
    604  2639		       80		      BYTE.b	%10000000
    605  263a		       80		      BYTE.b	%10000000
    606  263b		       80		      BYTE.b	%10000000
    607  263c		       80		      BYTE.b	%10000000
    608  263d		       80		      BYTE.b	%10000000
    609  263e		       80		      BYTE.b	%10000000
    610  263f		       80		      BYTE.b	%10000000
    611  2640		       80		      BYTE.b	%10000000
    612  2641		       c0		      BYTE.b	%11000000
    613  2642		       c0		      BYTE.b	%11000000
    614  2643		       c0		      BYTE.b	%11000000
    615  2644		       c0		      BYTE.b	%11000000
    616  2645		       c0		      BYTE.b	%11000000
    617  2646		       c0		      BYTE.b	%11000000
    618  2647		       c0		      BYTE.b	%11000000
    619  2648		       c0		      BYTE.b	%11000000
    620  2649		       c0		      BYTE.b	%11000000
    621  264a		       c0		      BYTE.b	%11000000
    622  264b		       c0		      BYTE.b	%11000000
    623  264c		       c0		      BYTE.b	%11000000
    624  264d		       c0		      BYTE.b	%11000000
    625  264e		       c0		      BYTE.b	%11000000
    626  264f		       c0		      BYTE.b	%11000000
    627  2650		       c0		      BYTE.b	%11000000
    628  2651		       c0		      BYTE.b	%11000000
    629  2652		       c0		      BYTE.b	%11000000
    630  2653		       c0		      BYTE.b	%11000000
    631  2654		       c0		      BYTE.b	%11000000
    632  2655		       c0		      BYTE.b	%11000000
    633  2656		       c0		      BYTE.b	%11000000
    634  2657		       c0		      BYTE.b	%11000000
    635  2658		       40		      BYTE.b	%01000000
    636  2659		       40		      BYTE.b	%01000000
    637  265a		       40		      BYTE.b	%01000000
    638  265b		       00		      BYTE.b	%00000000
    639  265c		       00		      BYTE.b	%00000000
    640  265d		       00		      BYTE.b	%00000000
    641  265e		       00		      BYTE.b	%00000000
    642  265f		       00		      BYTE.b	%00000000
    643  2660
------- FILE titlescreen/asm/titlescreen.asm
    221  2660					      endif
    222  2660					      ifconst	mk_48x1_2_on
------- FILE titlescreen/48x1_2_image.asm LEVEL 3 PASS 2
      0  2660					      include	"titlescreen/48x1_2_image.asm"
      1  2660
      2  2660
      3  2660							; *** if you want to modify the bitmap color on the fly, just dim a
      4  2660							; *** variable in bB called "bmp_48x1_2_color", and use it to set the
      5  2660							; *** color.
      6  2660
      7  2660
      8  2660							;*** this is the height of the displayed data
      9  2660		       00 0b	   bmp_48x1_2_window =	11
     10  2660
     11  2660							;*** this is the height of the bitmap data
     12  2660		       00 0b	   bmp_48x1_2_height =	11
     13  2660
     14  2660				  -	      ifnconst	bmp_48x1_2_color
     15  2660				  -bmp_48x1_2_color
     16  2660					      endif
     17  2660		       4a		      .byte.b	$4a
     18  2661
     19  2661				  -	      ifnconst	bmp_48x1_2_PF1
     20  2661				  -bmp_48x1_2_PF1
     21  2661					      endif
     22  2661		       00		      BYTE.b	%00000000
     23  2662				  -	      ifnconst	bmp_48x1_2_PF2
     24  2662				  -bmp_48x1_2_PF2
     25  2662					      endif
     26  2662		       00		      BYTE.b	%00000000
     27  2663				  -	      ifnconst	bmp_48x1_2_background
     28  2663				  -bmp_48x1_2_background
     29  2663					      endif
     30  2663		       00		      BYTE.b	$00
     31  2664
     32  2664				  -	      if	>. != >[.+bmp_48x1_2_height]
     33  2664				  -	      align	256
     34  2664					      endif
     35  2664
     36  2664				   bmp_48x1_2_00
     37  2664		       00		      BYTE.b	%00000000
     38  2665		       00		      BYTE.b	%00000000
     39  2666		       00		      BYTE.b	%00000000
     40  2667		       00		      BYTE.b	%00000000
     41  2668		       00		      BYTE.b	%00000000
     42  2669		       00		      BYTE.b	%00000000
     43  266a		       fb		      BYTE.b	%11111011
     44  266b		       82		      BYTE.b	%10000010
     45  266c		       82		      BYTE.b	%10000010
     46  266d		       82		      BYTE.b	%10000010
     47  266e		       fb		      BYTE.b	%11111011
     48  266f
     49  266f				  -	      if	>. != >[.+(bmp_48x1_2_height)]
     50  266f				  -	      align	256
     51  266f					      endif
     52  266f
     53  266f				   bmp_48x1_2_01
     54  266f		       0f		      BYTE.b	%00001111
     55  2670		       08		      BYTE.b	%00001000
     56  2671		       0f		      BYTE.b	%00001111
     57  2672		       00		      BYTE.b	%00000000
     58  2673		       0f		      BYTE.b	%00001111
     59  2674		       00		      BYTE.b	%00000000
     60  2675		       e8		      BYTE.b	%11101000
     61  2676		       28		      BYTE.b	%00101000
     62  2677		       2f		      BYTE.b	%00101111
     63  2678		       28		      BYTE.b	%00101000
     64  2679		       ef		      BYTE.b	%11101111
     65  267a
     66  267a				  -	      if	>. != >[.+(bmp_48x1_2_height)]
     67  267a				  -	      align	256
     68  267a					      endif
     69  267a
     70  267a				   bmp_48x1_2_02
     71  267a		       be		      BYTE.b	%10111110
     72  267b		       26		      BYTE.b	%00100110
     73  267c		       aa		      BYTE.b	%10101010
     74  267d		       b2		      BYTE.b	%10110010
     75  267e		       be		      BYTE.b	%10111110
     76  267f		       00		      BYTE.b	%00000000
     77  2680		       08		      BYTE.b	%00001000
     78  2681		       08		      BYTE.b	%00001000
     79  2682		       be		      BYTE.b	%10111110
     80  2683		       a2		      BYTE.b	%10100010
     81  2684		       a2		      BYTE.b	%10100010
     82  2685
     83  2685				  -	      if	>. != >[.+(bmp_48x1_2_height)]
     84  2685				  -	      align	256
     85  2685					      endif
     86  2685
     87  2685				   bmp_48x1_2_03
     88  2685		       fb		      BYTE.b	%11111011
     89  2686		       82		      BYTE.b	%10000010
     90  2687		       fa		      BYTE.b	%11111010
     91  2688		       0b		      BYTE.b	%00001011
     92  2689		       fb		      BYTE.b	%11111011
     93  268a		       00		      BYTE.b	%00000000
     94  268b		       95		      BYTE.b	%10010101
     95  268c		       a5		      BYTE.b	%10100101
     96  268d		       f5		      BYTE.b	%11110101
     97  268e		       95		      BYTE.b	%10010101
     98  268f		       f5		      BYTE.b	%11110101
     99  2690
    100  2690				  -	      if	>. != >[.+(bmp_48x1_2_height)]
    101  2690				  -	      align	256
    102  2690					      endif
    103  2690
    104  2690				   bmp_48x1_2_04
    105  2690		       e0		      BYTE.b	%11100000
    106  2691		       60		      BYTE.b	%01100000
    107  2692		       a0		      BYTE.b	%10100000
    108  2693		       20		      BYTE.b	%00100000
    109  2694		       e0		      BYTE.b	%11100000
    110  2695		       00		      BYTE.b	%00000000
    111  2696		       f4		      BYTE.b	%11110100
    112  2697		       14		      BYTE.b	%00010100
    113  2698		       37		      BYTE.b	%00110111
    114  2699		       04		      BYTE.b	%00000100
    115  269a		       f4		      BYTE.b	%11110100
    116  269b
    117  269b				  -	      if	>. != >[.+(bmp_48x1_2_height)]
    118  269b				  -	      align	256
    119  269b					      endif
    120  269b
    121  269b				   bmp_48x1_2_05
    122  269b		       00		      BYTE.b	%00000000
    123  269c		       00		      BYTE.b	%00000000
    124  269d		       00		      BYTE.b	%00000000
    125  269e		       00		      BYTE.b	%00000000
    126  269f		       00		      BYTE.b	%00000000
    127  26a0		       00		      BYTE.b	%00000000
    128  26a1		       44		      BYTE.b	%01000100
    129  26a2		       44		      BYTE.b	%01000100
    130  26a3		       c4		      BYTE.b	%11000100
    131  26a4		       44		      BYTE.b	%01000100
    132  26a5		       5f		      BYTE.b	%01011111
    133  26a6
------- FILE titlescreen/asm/titlescreen.asm
    224  26a6					      endif
    225  26a6					      ifconst	mk_48x1_3_on
------- FILE titlescreen/48x1_3_image.asm LEVEL 3 PASS 2
      0  26a6					      include	"titlescreen/48x1_3_image.asm"
      1  26a6
      2  26a6							;*** The height of the displayed data...
      3  26a6		       00 0b	   bmp_48x1_3_window =	11
      4  26a6
      5  26a6							;*** The height of the bitmap data. This can be larger than 
      6  26a6							;*** the displayed data height, if you're scrolling or animating 
      7  26a6							;*** the data...
      8  26a6		       00 0b	   bmp_48x1_3_height =	11
      9  26a6
     10  26a6				  -	      ifnconst	bmp_48x1_3_PF1
     11  26a6				  -bmp_48x1_3_PF1
     12  26a6					      endif
     13  26a6		       0f		      BYTE.b	%00001111
     14  26a7				  -	      ifnconst	bmp_48x1_3_PF2
     15  26a7				  -bmp_48x1_3_PF2
     16  26a7					      endif
     17  26a7		       ff		      BYTE.b	%11111111
     18  26a8				  -	      ifnconst	bmp_48x1_3_background
     19  26a8				  -bmp_48x1_3_background
     20  26a8					      endif
     21  26a8		       00		      BYTE.b	$00
     22  26a9
     23  26a9				  -	      ifnconst	bmp_48x1_3_color
     24  26a9				  -bmp_48x1_3_color
     25  26a9					      endif
     26  26a9							; *** this is the bitmap color. If you want to change it in a 
     27  26a9							; *** variable instead, dim one in bB called "bmp_48x1_3_color"
     28  26a9		       0f		      .byte.b	$0f
     29  26aa
     30  26aa
     31  26aa				  -	      if	>. != >[.+bmp_48x1_3_height]
     32  26aa				  -	      align	256
     33  26aa					      endif
     34  26aa
     35  26aa				   bmp_48x1_3_00
     36  26aa		       00		      BYTE.b	%00000000
     37  26ab		       00		      BYTE.b	%00000000
     38  26ac		       00		      BYTE.b	%00000000
     39  26ad		       00		      BYTE.b	%00000000
     40  26ae		       00		      BYTE.b	%00000000
     41  26af		       00		      BYTE.b	%00000000
     42  26b0		       00		      BYTE.b	%00000000
     43  26b1		       00		      BYTE.b	%00000000
     44  26b2		       00		      BYTE.b	%00000000
     45  26b3		       00		      BYTE.b	%00000000
     46  26b4		       00		      BYTE.b	%00000000
     47  26b5
     48  26b5				  -	      if	>. != >[.+(bmp_48x1_3_height)]
     49  26b5				  -	      align	256
     50  26b5					      endif
     51  26b5
     52  26b5				   bmp_48x1_3_01
     53  26b5		       3e		      BYTE.b	%00111110
     54  26b6		       02		      BYTE.b	%00000010
     55  26b7		       3e		      BYTE.b	%00111110
     56  26b8		       30		      BYTE.b	%00110000
     57  26b9		       3e		      BYTE.b	%00111110
     58  26ba		       00		      BYTE.b	%00000000
     59  26bb		       20		      BYTE.b	%00100000
     60  26bc		       20		      BYTE.b	%00100000
     61  26bd		       3e		      BYTE.b	%00111110
     62  26be		       26		      BYTE.b	%00100110
     63  26bf		       3e		      BYTE.b	%00111110
     64  26c0
     65  26c0				  -	      if	>. != >[.+(bmp_48x1_3_height)]
     66  26c0				  -	      align	256
     67  26c0					      endif
     68  26c0
     69  26c0				   bmp_48x1_3_02
     70  26c0		       22		      BYTE.b	%00100010
     71  26c1		       22		      BYTE.b	%00100010
     72  26c2		       23		      BYTE.b	%00100011
     73  26c3		       32		      BYTE.b	%00110010
     74  26c4		       fb		      BYTE.b	%11111011
     75  26c5		       00		      BYTE.b	%00000000
     76  26c6		       9b		      BYTE.b	%10011011
     77  26c7		       a2		      BYTE.b	%10100010
     78  26c8		       fb		      BYTE.b	%11111011
     79  26c9		       9b		      BYTE.b	%10011011
     80  26ca		       fb		      BYTE.b	%11111011
     81  26cb
     82  26cb				  -	      if	>. != >[.+(bmp_48x1_3_height)]
     83  26cb				  -	      align	256
     84  26cb					      endif
     85  26cb
     86  26cb				   bmp_48x1_3_03
     87  26cb		       29		      BYTE.b	%00101001
     88  26cc		       2a		      BYTE.b	%00101010
     89  26cd		       ef		      BYTE.b	%11101111
     90  26ce		       69		      BYTE.b	%01101001
     91  26cf		       ef		      BYTE.b	%11101111
     92  26d0		       00		      BYTE.b	%00000000
     93  26d1		       ef		      BYTE.b	%11101111
     94  26d2		       00		      BYTE.b	%00000000
     95  26d3		       cf		      BYTE.b	%11001111
     96  26d4		       0c		      BYTE.b	%00001100
     97  26d5		       ef		      BYTE.b	%11101111
     98  26d6
     99  26d6				  -	      if	>. != >[.+(bmp_48x1_3_height)]
    100  26d6				  -	      align	256
    101  26d6					      endif
    102  26d6
    103  26d6				   bmp_48x1_3_04
    104  26d6		       88		      BYTE.b	%10001000
    105  26d7		       08		      BYTE.b	%00001000
    106  26d8		       88		      BYTE.b	%10001000
    107  26d9		       8c		      BYTE.b	%10001100
    108  26da		       be		      BYTE.b	%10111110
    109  26db		       00		      BYTE.b	%00000000
    110  26dc		       be		      BYTE.b	%10111110
    111  26dd		       82		      BYTE.b	%10000010
    112  26de		       be		      BYTE.b	%10111110
    113  26df		       30		      BYTE.b	%00110000
    114  26e0		       be		      BYTE.b	%10111110
    115  26e1
    116  26e1				  -	      if	>. != >[.+(bmp_48x1_3_height)]
    117  26e1				  -	      align	256
    118  26e1					      endif
    119  26e1
    120  26e1				   bmp_48x1_3_05
    121  26e1		       00		      BYTE.b	%00000000
    122  26e2		       00		      BYTE.b	%00000000
    123  26e3		       00		      BYTE.b	%00000000
    124  26e4		       00		      BYTE.b	%00000000
    125  26e5		       00		      BYTE.b	%00000000
    126  26e6		       00		      BYTE.b	%00000000
    127  26e7		       00		      BYTE.b	%00000000
    128  26e8		       00		      BYTE.b	%00000000
    129  26e9		       00		      BYTE.b	%00000000
    130  26ea		       00		      BYTE.b	%00000000
    131  26eb		       00		      BYTE.b	%00000000
    132  26ec
------- FILE titlescreen/asm/titlescreen.asm
    227  26ec					      endif
    228  26ec				  -	      ifconst	mk_48x1_4_on
    229  26ec				  -	      include	"titlescreen/48x1_4_image.asm"
    230  26ec					      endif
    231  26ec				  -	      ifconst	mk_48x1_5_on
    232  26ec				  -	      include	"titlescreen/48x1_5_image.asm"
    233  26ec					      endif
    234  26ec				  -	      ifconst	mk_48x1_6_on
    235  26ec				  -	      include	"titlescreen/48x1_6_image.asm"
    236  26ec					      endif
    237  26ec				  -	      ifconst	mk_48x1_7_on
    238  26ec				  -	      include	"titlescreen/48x1_7_image.asm"
    239  26ec					      endif
    240  26ec				  -	      ifconst	mk_48x1_8_on
    241  26ec				  -	      include	"titlescreen/48x1_8_image.asm"
    242  26ec					      endif
    243  26ec
    244  26ec
    245  26ec				  -	      ifconst	mk_48x2_1_on
    246  26ec				  -	      include	"titlescreen/48x2_1_image.asm"
    247  26ec					      endif
    248  26ec				  -	      ifconst	mk_48x2_2_on
    249  26ec				  -	      include	"titlescreen/48x2_2_image.asm"
    250  26ec					      endif
    251  26ec				  -	      ifconst	mk_48x2_3_on
    252  26ec				  -	      include	"titlescreen/48x2_3_image.asm"
    253  26ec					      endif
    254  26ec				  -	      ifconst	mk_48x2_4_on
    255  26ec				  -	      include	"titlescreen/48x2_4_image.asm"
    256  26ec					      endif
    257  26ec				  -	      ifconst	mk_48x2_5_on
    258  26ec				  -	      include	"titlescreen/48x2_5_image.asm"
    259  26ec					      endif
    260  26ec				  -	      ifconst	mk_48x2_6_on
    261  26ec				  -	      include	"titlescreen/48x2_6_image.asm"
    262  26ec					      endif
    263  26ec				  -	      ifconst	mk_48x2_7_on
    264  26ec				  -	      include	"titlescreen/48x2_7_image.asm"
    265  26ec					      endif
    266  26ec
    267  26ec				  -	      ifconst	mk_48x2_8_on
    268  26ec				  -	      include	"titlescreen/48x2_8_image.asm"
    269  26ec					      endif
    270  26ec
    271  26ec
    272  26ec					      ifconst	mk_96x2_1_on
------- FILE titlescreen/96x2_1_image.asm LEVEL 3 PASS 2
      0  26ec					      include	"titlescreen/96x2_1_image.asm"
      1  26ec
      2  26ec							; *** if you want to modify the bitmap color on the fly, just dim a
      3  26ec							; *** variable in bB called "bmp_96x2_1_color", and use it to set the
      4  26ec							; *** color.
      5  26ec
      6  26ec
      7  26ec							;*** this is the height of the displayed data
      8  26ec		       00 0b	   bmp_96x2_1_window =	11
      9  26ec
     10  26ec							;*** this is the height of the bitmap data
     11  26ec		       00 0b	   bmp_96x2_1_height =	11
     12  26ec
     13  26ec				  -	      if	>. != >[.+(bmp_96x2_1_height)]
     14  26ec				  -	      align	256
     15  26ec					      endif
     16  26ec
     17  26ec							;*** this is the color of each line in the bitmap data
     18  26ec				   bmp_96x2_1_colors
     19  26ec		       3f		      BYTE.b	$3f
     20  26ed		       3f		      BYTE.b	$3f
     21  26ee		       3f		      BYTE.b	$3f
     22  26ef		       3f		      BYTE.b	$3f
     23  26f0		       2f		      BYTE.b	$2f
     24  26f1		       2f		      BYTE.b	$2f
     25  26f2		       2f		      BYTE.b	$2f
     26  26f3		       2f		      BYTE.b	$2f
     27  26f4		       2f		      BYTE.b	$2f
     28  26f5		       1f		      BYTE.b	$1f
     29  26f6		       1f		      BYTE.b	$1f
     30  26f7		       1f		      BYTE.b	$1f
     31  26f8		       1f		      BYTE.b	$1f
     32  26f9
     33  26f9					      if	>. != >[.+(bmp_96x2_1_height)]
     34  2700		       00 00 00 00*	      align	256
     35  2700					      endif
     36  2700
     37  2700				   bmp_96x2_1_00
     38  2700		       00		      BYTE.b	%00000000
     39  2701		       00		      BYTE.b	%00000000
     40  2702		       00		      BYTE.b	%00000000
     41  2703		       00		      BYTE.b	%00000000
     42  2704		       00		      BYTE.b	%00000000
     43  2705		       00		      BYTE.b	%00000000
     44  2706		       00		      BYTE.b	%00000000
     45  2707		       00		      BYTE.b	%00000000
     46  2708		       00		      BYTE.b	%00000000
     47  2709		       00		      BYTE.b	%00000000
     48  270a		       00		      BYTE.b	%00000000
     49  270b
     50  270b				  -	      if	>. != >[.+(bmp_96x2_1_height)]
     51  270b				  -	      align	256
     52  270b					      endif
     53  270b
     54  270b				   bmp_96x2_1_01
     55  270b		       00		      BYTE.b	%00000000
     56  270c		       00		      BYTE.b	%00000000
     57  270d		       00		      BYTE.b	%00000000
     58  270e		       00		      BYTE.b	%00000000
     59  270f		       00		      BYTE.b	%00000000
     60  2710		       00		      BYTE.b	%00000000
     61  2711		       00		      BYTE.b	%00000000
     62  2712		       00		      BYTE.b	%00000000
     63  2713		       00		      BYTE.b	%00000000
     64  2714		       00		      BYTE.b	%00000000
     65  2715		       00		      BYTE.b	%00000000
     66  2716
     67  2716				  -	      if	>. != >[.+(bmp_96x2_1_height)]
     68  2716				  -	      align	256
     69  2716					      endif
     70  2716
     71  2716				   bmp_96x2_1_02
     72  2716		       00		      BYTE.b	%00000000
     73  2717		       06		      BYTE.b	%00000110
     74  2718		       06		      BYTE.b	%00000110
     75  2719		       06		      BYTE.b	%00000110
     76  271a		       06		      BYTE.b	%00000110
     77  271b		       06		      BYTE.b	%00000110
     78  271c		       06		      BYTE.b	%00000110
     79  271d		       06		      BYTE.b	%00000110
     80  271e		       3f		      BYTE.b	%00111111
     81  271f		       3f		      BYTE.b	%00111111
     82  2720		       00		      BYTE.b	%00000000
     83  2721
     84  2721				  -	      if	>. != >[.+(bmp_96x2_1_height)]
     85  2721				  -	      align	256
     86  2721					      endif
     87  2721
     88  2721				   bmp_96x2_1_03
     89  2721		       00		      BYTE.b	%00000000
     90  2722		       1f		      BYTE.b	%00011111
     91  2723		       3f		      BYTE.b	%00111111
     92  2724		       30		      BYTE.b	%00110000
     93  2725		       30		      BYTE.b	%00110000
     94  2726		       70		      BYTE.b	%01110000
     95  2727		       30		      BYTE.b	%00110000
     96  2728		       30		      BYTE.b	%00110000
     97  2729		       ff		      BYTE.b	%11111111
     98  272a		       df		      BYTE.b	%11011111
     99  272b		       00		      BYTE.b	%00000000
    100  272c
    101  272c				  -	      if	>. != >[.+(bmp_96x2_1_height)]
    102  272c				  -	      align	256
    103  272c					      endif
    104  272c
    105  272c				   bmp_96x2_1_04
    106  272c		       00		      BYTE.b	%00000000
    107  272d		       98		      BYTE.b	%10011000
    108  272e		       d8		      BYTE.b	%11011000
    109  272f		       d9		      BYTE.b	%11011001
    110  2730		       db		      BYTE.b	%11011011
    111  2731		       fb		      BYTE.b	%11111011
    112  2732		       df		      BYTE.b	%11011111
    113  2733		       de		      BYTE.b	%11011110
    114  2734		       dc		      BYTE.b	%11011100
    115  2735		       9c		      BYTE.b	%10011100
    116  2736		       00		      BYTE.b	%00000000
    117  2737
    118  2737				  -	      if	>. != >[.+(bmp_96x2_1_height)]
    119  2737				  -	      align	256
    120  2737					      endif
    121  2737
    122  2737				   bmp_96x2_1_05
    123  2737		       00		      BYTE.b	%00000000
    124  2738		       e7		      BYTE.b	%11100111
    125  2739		       ef		      BYTE.b	%11101111
    126  273a		       ec		      BYTE.b	%11101100
    127  273b		       e0		      BYTE.b	%11100000
    128  273c		       67		      BYTE.b	%01100111
    129  273d		       6f		      BYTE.b	%01101111
    130  273e		       6c		      BYTE.b	%01101100
    131  273f		       6f		      BYTE.b	%01101111
    132  2740		       6f		      BYTE.b	%01101111
    133  2741		       00		      BYTE.b	%00000000
    134  2742
    135  2742				  -	      if	>. != >[.+(bmp_96x2_1_height)]
    136  2742				  -	      align	256
    137  2742					      endif
    138  2742
    139  2742				   bmp_96x2_1_06
    140  2742		       00		      BYTE.b	%00000000
    141  2743		       c7		      BYTE.b	%11000111
    142  2744		       ef		      BYTE.b	%11101111
    143  2745		       6c		      BYTE.b	%01101100
    144  2746		       ec		      BYTE.b	%11101100
    145  2747		       dc		      BYTE.b	%11011100
    146  2748		       0c		      BYTE.b	%00001100
    147  2749		       6c		      BYTE.b	%01101100
    148  274a		       ef		      BYTE.b	%11101111
    149  274b		       c7		      BYTE.b	%11000111
    150  274c		       00		      BYTE.b	%00000000
    151  274d
    152  274d				  -	      if	>. != >[.+(bmp_96x2_1_height)]
    153  274d				  -	      align	256
    154  274d					      endif
    155  274d
    156  274d				   bmp_96x2_1_07
    157  274d		       00		      BYTE.b	%00000000
    158  274e		       e6		      BYTE.b	%11100110
    159  274f		       f6		      BYTE.b	%11110110
    160  2750		       36		      BYTE.b	%00110110
    161  2751		       36		      BYTE.b	%00110110
    162  2752		       3f		      BYTE.b	%00111111
    163  2753		       37		      BYTE.b	%00110111
    164  2754		       37		      BYTE.b	%00110111
    165  2755		       f7		      BYTE.b	%11110111
    166  2756		       e7		      BYTE.b	%11100111
    167  2757		       00		      BYTE.b	%00000000
    168  2758
    169  2758				  -	      if	>. != >[.+(bmp_96x2_1_height)]
    170  2758				  -	      align	256
    171  2758					      endif
    172  2758
    173  2758				   bmp_96x2_1_08
    174  2758		       00		      BYTE.b	%00000000
    175  2759		       ec		      BYTE.b	%11101100
    176  275a		       ec		      BYTE.b	%11101100
    177  275b		       fd		      BYTE.b	%11111101
    178  275c		       fd		      BYTE.b	%11111101
    179  275d		       bd		      BYTE.b	%10111101
    180  275e		       9d		      BYTE.b	%10011101
    181  275f		       9d		      BYTE.b	%10011101
    182  2760		       1c		      BYTE.b	%00011100
    183  2761		       0c		      BYTE.b	%00001100
    184  2762		       00		      BYTE.b	%00000000
    185  2763
    186  2763				  -	      if	>. != >[.+(bmp_96x2_1_height)]
    187  2763				  -	      align	256
    188  2763					      endif
    189  2763
    190  2763				   bmp_96x2_1_09
    191  2763		       00		      BYTE.b	%00000000
    192  2764		       fc		      BYTE.b	%11111100
    193  2765		       fe		      BYTE.b	%11111110
    194  2766		       c7		      BYTE.b	%11000111
    195  2767		       83		      BYTE.b	%10000011
    196  2768		       83		      BYTE.b	%10000011
    197  2769		       83		      BYTE.b	%10000011
    198  276a		       c7		      BYTE.b	%11000111
    199  276b		       fe		      BYTE.b	%11111110
    200  276c		       fc		      BYTE.b	%11111100
    201  276d		       00		      BYTE.b	%00000000
    202  276e
    203  276e				  -	      if	>. != >[.+(bmp_96x2_1_height)]
    204  276e				  -	      align	256
    205  276e					      endif
    206  276e
    207  276e				   bmp_96x2_1_10
    208  276e		       00		      BYTE.b	%00000000
    209  276f		       00		      BYTE.b	%00000000
    210  2770		       00		      BYTE.b	%00000000
    211  2771		       00		      BYTE.b	%00000000
    212  2772		       00		      BYTE.b	%00000000
    213  2773		       00		      BYTE.b	%00000000
    214  2774		       00		      BYTE.b	%00000000
    215  2775		       00		      BYTE.b	%00000000
    216  2776		       00		      BYTE.b	%00000000
    217  2777		       00		      BYTE.b	%00000000
    218  2778		       00		      BYTE.b	%00000000
    219  2779
    220  2779				  -	      if	>. != >[.+(bmp_96x2_1_height)]
    221  2779				  -	      align	256
    222  2779					      endif
    223  2779
    224  2779				   bmp_96x2_1_11
    225  2779		       00		      BYTE.b	%00000000
    226  277a		       00		      BYTE.b	%00000000
    227  277b		       00		      BYTE.b	%00000000
    228  277c		       00		      BYTE.b	%00000000
    229  277d		       00		      BYTE.b	%00000000
    230  277e		       00		      BYTE.b	%00000000
    231  277f		       00		      BYTE.b	%00000000
    232  2780		       00		      BYTE.b	%00000000
    233  2781		       00		      BYTE.b	%00000000
    234  2782		       00		      BYTE.b	%00000000
    235  2783		       00		      BYTE.b	%00000000
    236  2784
------- FILE titlescreen/asm/titlescreen.asm
    274  2784					      endif
    275  2784				  -	      ifconst	mk_96x2_2_on
    276  2784				  -	      include	"titlescreen/96x2_2_image.asm"
    277  2784					      endif
    278  2784				  -	      ifconst	mk_96x2_3_on
    279  2784				  -	      include	"titlescreen/96x2_3_image.asm"
    280  2784					      endif
    281  2784				  -	      ifconst	mk_96x2_4_on
    282  2784				  -	      include	"titlescreen/96x2_4_image.asm"
    283  2784					      endif
    284  2784				  -	      ifconst	mk_96x2_5_on
    285  2784				  -	      include	"titlescreen/96x2_5_image.asm"
    286  2784					      endif
    287  2784				  -	      ifconst	mk_96x2_6_on
    288  2784				  -	      include	"titlescreen/96x2_6_image.asm"
    289  2784					      endif
    290  2784				  -	      ifconst	mk_96x2_7_on
    291  2784				  -	      include	"titlescreen/96x2_7_image.asm"
    292  2784					      endif
    293  2784				  -	      ifconst	mk_96x2_8_on
    294  2784				  -	      include	"titlescreen/96x2_8_image.asm"
    295  2784					      endif
    296  2784
    297  2784				  -	      ifconst	mk_player_on
    298  2784				  -	      include	"titlescreen/player_image.asm"
    299  2784					      endif
    300  2784
    301  2784				  -	      ifconst	mk_score_on
    302  2784				  -	      include	"titlescreen/score_image.asm"
    303  2784					      endif
    304  2784
    305  2784				  -	      ifconst	mk_gameselect_on
    306  2784				  -	      include	"titlescreen/gameselect_image.asm"
    307  2784					      endif
    308  2784
    309  2784				  -	      ifconst	mk_player_on
    310  2784				  -	      include	"titlescreen/asm/player_kernel.asm"
    311  2784					      endif		;mk_player_on
    312  2784
    313  2784
------- FILE /Users/jblanchard/Documents/Code/Retro/Atari2600/Jurl/Jurl.bas.asm
   3562  2784
   3563  2784				   .
   3564  2784							;
   3565  2784
   3566  2784				   .L0363		;  bank 3
   3567  2784
   3568  2784					      if	ECHO2
      2128 bytes of ROM space left in bank 2
   3569  2784					      echo	"    ",[(start_bank2 - *)]d , "bytes of ROM space left in bank 2")
   3570  2784					      endif
   3571  2784		       00 01	   ECHO2      =	1
   3572  2fd4					      ORG	$2FF4-bscode_length
   3573  2fd4					      RORG	$BFF4-bscode_length
   3574  2fd4		       a2 ff	   start_bank2 ldx	#$ff
   3575  2fd6				  -	      ifconst	FASTFETCH	; using DPC+
   3576  2fd6				  -	      stx	FASTFETCH
   3577  2fd6					      endif
   3578  2fd6		       9a		      txs
   3579  2fd7				  -	      if	bankswitch == 64
   3580  2fd7				  -	      lda	#(((>(start-1)) & $0F) | $F0)
   3581  2fd7					      else
   3582  2fd7		       a9 f2		      lda	#>(start-1)
   3583  2fd9					      endif
   3584  2fd9		       48		      pha
   3585  2fda		       a9 51		      lda	#<(start-1)
   3586  2fdc		       48		      pha
   3587  2fdd		       48		      pha
   3588  2fde		       8a		      txa
   3589  2fdf		       48		      pha
   3590  2fe0		       ba		      tsx
   3591  2fe1					      if	bankswitch != 64
   3592  2fe1		       b5 04		      lda	4,x	; get high byte of return address
   3593  2fe3		       2a		      rol
   3594  2fe4		       2a		      rol
   3595  2fe5		       2a		      rol
   3596  2fe6		       2a		      rol
   3597  2fe7		       29 03		      and	#bs_mask	;1 3 or 7 for F8/F6/F4
   3598  2fe9		       aa		      tax
   3599  2fea		       e8		      inx
   3600  2feb				  -	      else
   3601  2feb				  -	      lda	4,x	; get high byte of return address
   3602  2feb				  -	      tay
   3603  2feb				  -	      ora	#$10	; change our bank nibble into a valid rom mirror
   3604  2feb				  -	      sta	4,x
   3605  2feb				  -	      tya
   3606  2feb				  -	      lsr
   3607  2feb				  -	      lsr
   3608  2feb				  -	      lsr
   3609  2feb				  -	      lsr
   3610  2feb				  -	      tax
   3611  2feb				  -	      inx
   3612  2feb					      endif
   3613  2feb		       bd f5 1f 	      lda	bankswitch_hotspot-1,x
   3614  2fee		       68		      pla
   3615  2fef		       aa		      tax
   3616  2ff0		       68		      pla
   3617  2ff1		       60		      rts
   3618  2ff2				  -	      if	((* & $1FFF) > ((bankswitch_hotspot & $1FFF) - 1))
   3619  2ff2				  -	      echo	"WARNING: size parameter in banksw.asm too small - the program probably will not work."
   3620  2ff2				  -	      echo	"Change to",[(*-begin_bscode+1)&$FF]d,"and try again."
   3621  2ff2					      endif
   3622  2ffc					      ORG	$2FFC
   3623  2ffc					      RORG	$BFFC
   3624  2ffc		       d4 bf		      .word.w	(start_bank2 & $ffff)
   3625  2ffe		       d4 bf		      .word.w	(start_bank2 & $ffff)
   3626  3000					      ORG	$3000
   3627  3000					      RORG	$D000
   3628  3000				   .
   3629  3000							;
   3630  3000
   3631  3000					      if	ECHO3
      4052 bytes of ROM space left in bank 3
   3632  3000					      echo	"    ",[(start_bank3 - *)]d , "bytes of ROM space left in bank 3")
   3633  3000					      endif
   3634  3000		       00 01	   ECHO3      =	1
   3635  3fd4					      ORG	$3FF4-bscode_length
   3636  3fd4					      RORG	$DFF4-bscode_length
   3637  3fd4		       a2 ff	   start_bank3 ldx	#$ff
   3638  3fd6				  -	      ifconst	FASTFETCH	; using DPC+
   3639  3fd6				  -	      stx	FASTFETCH
   3640  3fd6					      endif
   3641  3fd6		       9a		      txs
   3642  3fd7				  -	      if	bankswitch == 64
   3643  3fd7				  -	      lda	#(((>(start-1)) & $0F) | $F0)
   3644  3fd7					      else
   3645  3fd7		       a9 f2		      lda	#>(start-1)
   3646  3fd9					      endif
   3647  3fd9		       48		      pha
   3648  3fda		       a9 51		      lda	#<(start-1)
   3649  3fdc		       48		      pha
   3650  3fdd		       48		      pha
   3651  3fde		       8a		      txa
   3652  3fdf		       48		      pha
   3653  3fe0		       ba		      tsx
   3654  3fe1					      if	bankswitch != 64
   3655  3fe1		       b5 04		      lda	4,x	; get high byte of return address
   3656  3fe3		       2a		      rol
   3657  3fe4		       2a		      rol
   3658  3fe5		       2a		      rol
   3659  3fe6		       2a		      rol
   3660  3fe7		       29 03		      and	#bs_mask	;1 3 or 7 for F8/F6/F4
   3661  3fe9		       aa		      tax
   3662  3fea		       e8		      inx
   3663  3feb				  -	      else
   3664  3feb				  -	      lda	4,x	; get high byte of return address
   3665  3feb				  -	      tay
   3666  3feb				  -	      ora	#$10	; change our bank nibble into a valid rom mirror
   3667  3feb				  -	      sta	4,x
   3668  3feb				  -	      tya
   3669  3feb				  -	      lsr
   3670  3feb				  -	      lsr
   3671  3feb				  -	      lsr
   3672  3feb				  -	      lsr
   3673  3feb				  -	      tax
   3674  3feb				  -	      inx
   3675  3feb					      endif
   3676  3feb		       bd f5 1f 	      lda	bankswitch_hotspot-1,x
   3677  3fee		       68		      pla
   3678  3fef		       aa		      tax
   3679  3ff0		       68		      pla
   3680  3ff1		       60		      rts
   3681  3ff2				  -	      if	((* & $1FFF) > ((bankswitch_hotspot & $1FFF) - 1))
   3682  3ff2				  -	      echo	"WARNING: size parameter in banksw.asm too small - the program probably will not work."
   3683  3ff2				  -	      echo	"Change to",[(*-begin_bscode+1)&$FF]d,"and try again."
   3684  3ff2					      endif
   3685  3ffc					      ORG	$3FFC
   3686  3ffc					      RORG	$DFFC
   3687  3ffc		       d4 df		      .word.w	(start_bank3 & $ffff)
   3688  3ffe		       d4 df		      .word.w	(start_bank3 & $ffff)
   3689  4000					      ORG	$4000
   3690  4000					      RORG	$F000
   3691  4000							; Provided under the CC0 license. See the included LICENSE.txt for details.
   3692  4000
   3693  4000							; This is a 2-line kernel!
   3694  4000					      ifnconst	vertical_reflect
   3695  4000				   kernel
   3696  4000					      endif
   3697  4000		       85 02		      sta	WSYNC
   3698  4002		       a9 ff		      lda	#255
   3699  4004		       8d 96 02 	      sta	TIM64T
   3700  4007
   3701  4007		       a9 01		      lda	#1
   3702  4009		       85 27		      sta	VDELBL
   3703  400b		       85 25		      sta	VDELP0
   3704  400d		       a6 92		      ldx	ballheight
   3705  400f		       e8		      inx
   3706  4010		       e8		      inx
   3707  4011		       86 9f		      stx	temp4
   3708  4013		       a5 86		      lda	player1y
   3709  4015		       85 9e		      sta	temp3
   3710  4017
   3711  4017				  -	      ifconst	shakescreen
   3712  4017				  -	      jsr	doshakescreen
   3713  4017					      else
   3714  4017		       a6 90		      ldx	missile0height
   3715  4019		       e8		      inx
   3716  401a					      endif
   3717  401a
   3718  401a		       e8		      inx
   3719  401b		       86 f6		      stx	stack1
   3720  401d
   3721  401d		       a5 89		      lda	bally
   3722  401f		       85 f7		      sta	stack2
   3723  4021
   3724  4021		       a5 85		      lda	player0y
   3725  4023		       a2 00		      ldx	#0
   3726  4025		       85 02		      sta	WSYNC
   3727  4027		       86 1b		      stx	GRP0
   3728  4029		       86 1c		      stx	GRP1
   3729  402b		       86 0e		      stx	PF1L
   3730  402d		       86 0f		      stx	PF2
   3731  402f		       86 2c		      stx	CXCLR
   3732  4031				  -	      ifconst	readpaddle
   3733  4031				  -	      stx	paddle
   3734  4031					      else
      0  4031					      sleep	3
      1  4031				   .CYCLES    SET	3
      2  4031
      3  4031				  -	      IF	.CYCLES < 2
      4  4031				  -	      ECHO	"MACRO ERROR: 'SLEEP': Duration must be > 1"
      5  4031				  -	      ERR
      6  4031					      ENDIF
      7  4031
      8  4031					      IF	.CYCLES & 1
      9  4031					      IFNCONST	NO_ILLEGAL_OPCODES
     10  4031		       04 00		      nop	0
     11  4033				  -	      ELSE
     12  4033				  -	      bit	VSYNC
     13  4033					      ENDIF
     14  4033				   .CYCLES    SET	.CYCLES - 3
     15  4033					      ENDIF
     16  4033
     17  4033				  -	      REPEAT	.CYCLES / 2
     18  4033				  -	      nop
     19  4033					      REPEND
   3736  4033					      endif
   3737  4033
   3738  4033		       95 9d		      sta	temp2,x
   3739  4035
   3740  4035							;store these so they can be retrieved later
   3741  4035					      ifnconst	pfres
   3742  4035		       a2 54		      ldx	#128-44+(4-pfwidth)*12
   3743  4037				  -	      else
   3744  4037				  -	      ldx	#132-pfres*pfwidth
   3745  4037					      endif
   3746  4037
   3747  4037		       c6 85		      dec	player0y
   3748  4039
   3749  4039		       a5 91		      lda	missile0y
   3750  403b		       85 a0		      sta	temp5
   3751  403d		       a5 88		      lda	missile1y
   3752  403f		       85 a1		      sta	temp6
   3753  4041
   3754  4041		       a5 ef		      lda	playfieldpos
   3755  4043		       85 9c		      sta	temp1
   3756  4045
   3757  4045				  -	      ifconst	pfrowheight
   3758  4045				  -	      lda	#pfrowheight+2
   3759  4045					      else
   3760  4045					      ifnconst	pfres
   3761  4045		       a9 0a		      lda	#10
   3762  4047				  -	      else
   3763  4047				  -	      lda	#(96/pfres)+2	; try to come close to the real size
   3764  4047					      endif
   3765  4047					      endif
   3766  4047		       18		      clc
   3767  4048		       e5 ef		      sbc	playfieldpos
   3768  404a		       85 ef		      sta	playfieldpos
   3769  404c		       4c 74 f0 	      jmp	.startkernel
   3770  404f
   3771  404f				   .skipDrawP0
   3772  404f		       a9 00		      lda	#0
   3773  4051		       a8		      tay
   3774  4052		       4c a2 f0 	      jmp	.continueP0
   3775  4055
   3776  4055				   .skipDrawP1
   3777  4055		       a9 00		      lda	#0
   3778  4057		       a8		      tay
   3779  4058		       4c 7e f0 	      jmp	.continueP1
   3780  405b
   3781  405b				   .kerloop		; enter at cycle 59??
   3782  405b
   3783  405b				   continuekernel
      0  405b					      sleep	2
      1  405b				   .CYCLES    SET	2
      2  405b
      3  405b				  -	      IF	.CYCLES < 2
      4  405b				  -	      ECHO	"MACRO ERROR: 'SLEEP': Duration must be > 1"
      5  405b				  -	      ERR
      6  405b					      ENDIF
      7  405b
      8  405b				  -	      IF	.CYCLES & 1
      9  405b				  -	      IFNCONST	NO_ILLEGAL_OPCODES
     10  405b				  -	      nop	0
     11  405b				  -	      ELSE
     12  405b				  -	      bit	VSYNC
     13  405b				  -	      ENDIF
     14  405b				  -.CYCLES    SET	.CYCLES - 3
     15  405b					      ENDIF
     16  405b
     17  405b					      REPEAT	.CYCLES / 2
     18  405b		       ea		      nop
     19  405c					      REPEND
   3785  405c				   continuekernel2
   3786  405c		       a5 92		      lda	ballheight
   3787  405e
   3788  405e				  -	      ifconst	pfres
   3789  405e				  -	      ldy	playfield+pfres*pfwidth-132,x
   3790  405e				  -	      sty	PF1L	;3
   3791  405e				  -	      ldy	playfield+pfres*pfwidth-131-pfadjust,x
   3792  405e				  -	      sty	PF2L	;3
   3793  405e				  -	      ldy	playfield+pfres*pfwidth-129,x
   3794  405e				  -	      sty	PF1R	; 3 too early?
   3795  405e				  -	      ldy	playfield+pfres*pfwidth-130-pfadjust,x
   3796  405e				  -	      sty	PF2R	;3
   3797  405e					      else
   3798  405e		       b4 50		      ldy	playfield-48+pfwidth*12+44-128,x
   3799  4060		       84 0e		      sty	PF1L	;3
   3800  4062		       b4 51		      ldy	playfield-48+pfwidth*12+45-128-pfadjust,x	;4
   3801  4064		       84 0f		      sty	PF2L	;3
   3802  4066		       b4 53		      ldy	playfield-48+pfwidth*12+47-128,x	;4
   3803  4068		       84 0e		      sty	PF1R	; 3 too early?
   3804  406a		       b4 52		      ldy	playfield-48+pfwidth*12+46-128-pfadjust,x	;4
   3805  406c		       84 0f		      sty	PF2R	;3
   3806  406e					      endif
   3807  406e
   3808  406e							; should be playfield+$38 for width=2
   3809  406e
   3810  406e		       c7 89		      dcp	bally
   3811  4070		       2a		      rol
   3812  4071		       2a		      rol
   3813  4072							; rol
   3814  4072							; rol
   3815  4072				   goback
   3816  4072		       85 1f		      sta	ENABL
   3817  4074				   .startkernel
   3818  4074		       a5 8f		      lda	player1height	;3
   3819  4076		       c7 86		      dcp	player1y	;5
   3820  4078		       90 db		      bcc	.skipDrawP1	;2
   3821  407a		       a4 86		      ldy	player1y	;3
   3822  407c		       b1 8c		      lda	(player1pointer),y	;5; player0pointer must be selected carefully by the compiler
   3823  407e							; so it doesn't cross a page boundary!
   3824  407e
   3825  407e				   .continueP1
   3826  407e		       85 1c		      sta	GRP1	;3
   3827  4080
   3828  4080					      ifnconst	player1colors
   3829  4080		       a5 87		      lda	missile1height	;3
   3830  4082		       c7 88		      dcp	missile1y	;5
   3831  4084		       2a		      rol		;2
   3832  4085		       2a		      rol		;2
   3833  4086		       85 1e		      sta	ENAM1	;3
   3834  4088				  -	      else
   3835  4088				  -	      lda	(player1color),y
   3836  4088				  -	      sta	COLUP1
   3837  4088				  -	      ifnconst	playercolors
   3838  4088				  -	      sleep	7
   3839  4088				  -	      else
   3840  4088				  -	      lda.w	player0colorstore
   3841  4088				  -	      sta	COLUP0
   3842  4088				  -	      endif
   3843  4088					      endif
   3844  4088
   3845  4088				  -	      ifconst	pfres
   3846  4088				  -	      lda	playfield+pfres*pfwidth-132,x
   3847  4088				  -	      sta	PF1L	;3
   3848  4088				  -	      lda	playfield+pfres*pfwidth-131-pfadjust,x
   3849  4088				  -	      sta	PF2L	;3
   3850  4088				  -	      lda	playfield+pfres*pfwidth-129,x
   3851  4088				  -	      sta	PF1R	; 3 too early?
   3852  4088				  -	      lda	playfield+pfres*pfwidth-130-pfadjust,x
   3853  4088				  -	      sta	PF2R	;3
   3854  4088					      else
   3855  4088		       b5 50		      lda	playfield-48+pfwidth*12+44-128,x	;4
   3856  408a		       85 0e		      sta	PF1L	;3
   3857  408c		       b5 51		      lda	playfield-48+pfwidth*12+45-128-pfadjust,x	;4
   3858  408e		       85 0f		      sta	PF2L	;3
   3859  4090		       b5 53		      lda	playfield-48+pfwidth*12+47-128,x	;4
   3860  4092		       85 0e		      sta	PF1R	; 3 too early?
   3861  4094		       b5 52		      lda	playfield-48+pfwidth*12+46-128-pfadjust,x	;4
   3862  4096		       85 0f		      sta	PF2R	;3
   3863  4098					      endif
   3864  4098							; sleep 3
   3865  4098
   3866  4098		       a5 8e		      lda	player0height
   3867  409a		       c7 85		      dcp	player0y
   3868  409c		       90 b1		      bcc	.skipDrawP0
   3869  409e		       a4 85		      ldy	player0y
   3870  40a0		       b1 8a		      lda	(player0pointer),y
   3871  40a2				   .continueP0
   3872  40a2		       85 1b		      sta	GRP0
   3873  40a4
   3874  40a4				  -	      ifnconst	no_blank_lines
   3875  40a4				  -	      ifnconst	playercolors
   3876  40a4				  -	      lda	missile0height	;3
   3877  40a4				  -	      dcp	missile0y	;5
   3878  40a4				  -	      sbc	stack1
   3879  40a4				  -	      sta	ENAM0	;3
   3880  40a4				  -	      else
   3881  40a4				  -	      lda	(player0color),y
   3882  40a4				  -	      sta	player0colorstore
   3883  40a4				  -	      sleep	6
   3884  40a4				  -	      endif
   3885  40a4				  -	      dec	temp1
   3886  40a4				  -	      bne	continuekernel
   3887  40a4					      else
   3888  40a4		       c6 9c		      dec	temp1
   3889  40a6		       f0 0c		      beq	altkernel2
   3890  40a8				  -	      ifconst	readpaddle
   3891  40a8				  -	      ldy	currentpaddle
   3892  40a8				  -	      lda	INPT0,y
   3893  40a8				  -	      bpl	noreadpaddle
   3894  40a8				  -	      inc	paddle
   3895  40a8				  -	      jmp	continuekernel2
   3896  40a8				  -noreadpaddle
   3897  40a8				  -	      sleep	2
   3898  40a8				  -	      jmp	continuekernel
   3899  40a8					      else
   3900  40a8					      ifnconst	playercolors
   3901  40a8					      ifconst	PFcolors
   3902  40a8		       8a		      txa
   3903  40a9		       a8		      tay
   3904  40aa		       b1 f0		      lda	(pfcolortable),y
   3905  40ac					      ifnconst	backgroundchange
   3906  40ac		       85 08		      sta	COLUPF
   3907  40ae				  -	      else
   3908  40ae				  -	      sta	COLUBK
   3909  40ae					      endif
   3910  40ae		       4c 5b f0 	      jmp	continuekernel
   3911  40b1				  -	      else
   3912  40b1				  -	      ifconst	kernelmacrodef
   3913  40b1				  -	      kernelmacro
   3914  40b1				  -	      else
   3915  40b1				  -	      sleep	12
   3916  40b1				  -	      endif
   3917  40b1					      endif
   3918  40b1				  -	      else
   3919  40b1				  -	      lda	(player0color),y
   3920  40b1				  -	      sta	player0colorstore
   3921  40b1				  -	      sleep	4
   3922  40b1					      endif
   3923  40b1		       4c 5b f0 	      jmp	continuekernel
   3924  40b4					      endif
   3925  40b4				   altkernel2
   3926  40b4		       8a		      txa
   3927  40b5					      ifnconst	vertical_reflect
   3928  40b5		       cb fc		      sbx	#256-pfwidth
   3929  40b7				  -	      else
   3930  40b7				  -	      sbx	#256-pfwidth/2
   3931  40b7					      endif
   3932  40b7		       30 24		      bmi	lastkernelline
   3933  40b9				  -	      ifconst	pfrowheight
   3934  40b9				  -	      lda	#pfrowheight
   3935  40b9					      else
   3936  40b9					      ifnconst	pfres
   3937  40b9		       a9 08		      lda	#8
   3938  40bb				  -	      else
   3939  40bb				  -	      lda	#(96/pfres)	; try to come close to the real size
   3940  40bb					      endif
   3941  40bb					      endif
   3942  40bb		       85 9c		      sta	temp1
   3943  40bd		       4c 5b f0 	      jmp	continuekernel
   3944  40c0					      endif
   3945  40c0
   3946  40c0				   altkernel
   3947  40c0
   3948  40c0				  -	      ifconst	PFmaskvalue
   3949  40c0				  -	      lda	#PFmaskvalue
   3950  40c0					      else
   3951  40c0		       a9 00		      lda	#0
   3952  40c2					      endif
   3953  40c2		       85 0e		      sta	PF1L
   3954  40c4		       85 0f		      sta	PF2
   3955  40c6
   3956  40c6
   3957  40c6							;sleep 3
   3958  40c6
   3959  40c6							;28 cycles to fix things
   3960  40c6							;minus 11=17
   3961  40c6
   3962  40c6							; lax temp4
   3963  40c6							; clc
   3964  40c6		       8a		      txa
   3965  40c7					      ifnconst	vertical_reflect
   3966  40c7		       cb fc		      sbx	#256-pfwidth
   3967  40c9				  -	      else
   3968  40c9				  -	      sbx	#256-pfwidth/2
   3969  40c9					      endif
   3970  40c9
   3971  40c9		       30 12		      bmi	lastkernelline
   3972  40cb
   3973  40cb				  -	      ifconst	PFcolorandheight
   3974  40cb				  -	      ifconst	pfres
   3975  40cb				  -	      ldy	playfieldcolorandheight-131+pfres*pfwidth,x
   3976  40cb				  -	      else
   3977  40cb				  -	      ldy	playfieldcolorandheight-87,x
   3978  40cb				  -	      endif
   3979  40cb				  -	      ifnconst	backgroundchange
   3980  40cb				  -	      sty	COLUPF
   3981  40cb				  -	      else
   3982  40cb				  -	      sty	COLUBK
   3983  40cb				  -	      endif
   3984  40cb				  -	      ifconst	pfres
   3985  40cb				  -	      lda	playfieldcolorandheight-132+pfres*pfwidth,x
   3986  40cb				  -	      else
   3987  40cb				  -	      lda	playfieldcolorandheight-88,x
   3988  40cb				  -	      endif
   3989  40cb				  -	      sta.w	temp1
   3990  40cb					      endif
   3991  40cb				  -	      ifconst	PFheights
   3992  40cb				  -	      lsr
   3993  40cb				  -	      lsr
   3994  40cb				  -	      tay
   3995  40cb				  -	      lda	(pfheighttable),y
   3996  40cb				  -	      sta.w	temp1
   3997  40cb					      endif
   3998  40cb					      ifconst	PFcolors
   3999  40cb		       a8		      tay
   4000  40cc		       b1 f0		      lda	(pfcolortable),y
   4001  40ce					      ifnconst	backgroundchange
   4002  40ce		       85 08		      sta	COLUPF
   4003  40d0				  -	      else
   4004  40d0				  -	      sta	COLUBK
   4005  40d0					      endif
   4006  40d0				  -	      ifconst	pfrowheight
   4007  40d0				  -	      lda	#pfrowheight
   4008  40d0					      else
   4009  40d0					      ifnconst	pfres
   4010  40d0		       a9 08		      lda	#8
   4011  40d2				  -	      else
   4012  40d2				  -	      lda	#(96/pfres)	; try to come close to the real size
   4013  40d2					      endif
   4014  40d2					      endif
   4015  40d2		       85 9c		      sta	temp1
   4016  40d4					      endif
   4017  40d4					      ifnconst	PFcolorandheight
   4018  40d4				  -	      ifnconst	PFcolors
   4019  40d4				  -	      ifnconst	PFheights
   4020  40d4				  -	      ifnconst	no_blank_lines
   4021  40d4				  -			; read paddle 0
   4022  40d4				  -			; lo-res paddle read
   4023  40d4				  -			; bit INPT0
   4024  40d4				  -			; bmi paddleskipread
   4025  40d4				  -			; inc paddle0
   4026  40d4				  -			;donepaddleskip
   4027  40d4				  -	      sleep	10
   4028  40d4				  -	      ifconst	pfrowheight
   4029  40d4				  -	      lda	#pfrowheight
   4030  40d4				  -	      else
   4031  40d4				  -	      ifnconst	pfres
   4032  40d4				  -	      lda	#8
   4033  40d4				  -	      else
   4034  40d4				  -	      lda	#(96/pfres)	; try to come close to the real size
   4035  40d4				  -	      endif
   4036  40d4				  -	      endif
   4037  40d4				  -	      sta	temp1
   4038  40d4				  -	      endif
   4039  40d4				  -	      endif
   4040  40d4					      endif
   4041  40d4					      endif
   4042  40d4
   4043  40d4
   4044  40d4		       a5 92		      lda	ballheight
   4045  40d6		       c7 89		      dcp	bally
   4046  40d8		       e5 9f		      sbc	temp4
   4047  40da
   4048  40da
   4049  40da		       4c 72 f0 	      jmp	goback
   4050  40dd
   4051  40dd
   4052  40dd				  -	      ifnconst	no_blank_lines
   4053  40dd				  -lastkernelline
   4054  40dd				  -	      ifnconst	PFcolors
   4055  40dd				  -	      sleep	10
   4056  40dd				  -	      else
   4057  40dd				  -	      ldy	#124
   4058  40dd				  -	      lda	(pfcolortable),y
   4059  40dd				  -	      sta	COLUPF
   4060  40dd				  -	      endif
   4061  40dd				  -
   4062  40dd				  -	      ifconst	PFheights
   4063  40dd				  -	      ldx	#1
   4064  40dd				  -			;sleep 4
   4065  40dd				  -	      sleep	3	; this was over 1 cycle
   4066  40dd				  -	      else
   4067  40dd				  -	      ldx	playfieldpos
   4068  40dd				  -			;sleep 3
   4069  40dd				  -	      sleep	2	; this was over 1 cycle
   4070  40dd				  -	      endif
   4071  40dd				  -
   4072  40dd				  -	      jmp	enterlastkernel
   4073  40dd				  -
   4074  40dd					      else
   4075  40dd				   lastkernelline
   4076  40dd
   4077  40dd				  -	      ifconst	PFheights
   4078  40dd				  -	      ldx	#1
   4079  40dd				  -			;sleep 5
   4080  40dd				  -	      sleep	4	; this was over 1 cycle
   4081  40dd					      else
   4082  40dd		       a6 ef		      ldx	playfieldpos
   4083  40df							;sleep 4
      0  40df					      sleep	3	; this was over 1 cycle
      1  40df				   .CYCLES    SET	3
      2  40df
      3  40df				  -	      IF	.CYCLES < 2
      4  40df				  -	      ECHO	"MACRO ERROR: 'SLEEP': Duration must be > 1"
      5  40df				  -	      ERR
      6  40df					      ENDIF
      7  40df
      8  40df					      IF	.CYCLES & 1
      9  40df					      IFNCONST	NO_ILLEGAL_OPCODES
     10  40df		       04 00		      nop	0
     11  40e1				  -	      ELSE
     12  40e1				  -	      bit	VSYNC
     13  40e1					      ENDIF
     14  40e1				   .CYCLES    SET	.CYCLES - 3
     15  40e1					      ENDIF
     16  40e1
     17  40e1				  -	      REPEAT	.CYCLES / 2
     18  40e1				  -	      nop
     19  40e1					      REPEND
   4085  40e1					      endif
   4086  40e1
   4087  40e1		       e0 00		      cpx	#0
   4088  40e3		       d0 22		      bne	.enterfromNBL
   4089  40e5		       4c 68 f1 	      jmp	no_blank_lines_bailout
   4090  40e8					      endif
   4091  40e8
   4092  40e8					      if	((<*)>$d5)
   4093  4100		       00 00 00 00*	      align	256
   4094  4100					      endif
   4095  4100							; this is a kludge to prevent page wrapping - fix!!!
   4096  4100
   4097  4100				   .skipDrawlastP1
   4098  4100		       a9 00		      lda	#0
   4099  4102		       a8		      tay		; added so we don't cross a page
   4100  4103		       4c 2d f1 	      jmp	.continuelastP1
   4101  4106
   4102  4106				   .endkerloop		; enter at cycle 59??
   4103  4106
   4104  4106		       ea		      nop
   4105  4107
   4106  4107				   .enterfromNBL
   4107  4107				  -	      ifconst	pfres
   4108  4107				  -	      ldy.w	playfield+pfres*pfwidth-4
   4109  4107				  -	      sty	PF1L	;3
   4110  4107				  -	      ldy.w	playfield+pfres*pfwidth-3-pfadjust
   4111  4107				  -	      sty	PF2L	;3
   4112  4107				  -	      ldy.w	playfield+pfres*pfwidth-1
   4113  4107				  -	      sty	PF1R	; possibly too early?
   4114  4107				  -	      ldy.w	playfield+pfres*pfwidth-2-pfadjust
   4115  4107				  -	      sty	PF2R	;3
   4116  4107					      else
   4117  4107		       ac d0 00 	      ldy.w	playfield-48+pfwidth*12+44
   4118  410a		       84 0e		      sty	PF1L	;3
   4119  410c		       ac d1 00 	      ldy.w	playfield-48+pfwidth*12+45-pfadjust
   4120  410f		       84 0f		      sty	PF2L	;3
   4121  4111		       ac d3 00 	      ldy.w	playfield-48+pfwidth*12+47
   4122  4114		       84 0e		      sty	PF1R	; possibly too early?
   4123  4116		       ac d2 00 	      ldy.w	playfield-48+pfwidth*12+46-pfadjust
   4124  4119		       84 0f		      sty	PF2R	;3
   4125  411b					      endif
   4126  411b
   4127  411b				   enterlastkernel
   4128  411b		       a5 92		      lda	ballheight
   4129  411d
   4130  411d							; tya
   4131  411d		       c7 89		      dcp	bally
   4132  411f							; sleep 4
   4133  411f
   4134  411f							; sbc stack3
   4135  411f		       2a		      rol
   4136  4120		       2a		      rol
   4137  4121		       85 1f		      sta	ENABL
   4138  4123
   4139  4123		       a5 8f		      lda	player1height	;3
   4140  4125		       c7 86		      dcp	player1y	;5
   4141  4127		       90 d7		      bcc	.skipDrawlastP1
   4142  4129		       a4 86		      ldy	player1y	;3
   4143  412b		       b1 8c		      lda	(player1pointer),y	;5; player0pointer must be selected carefully by the compiler
   4144  412d							; so it doesn't cross a page boundary!
   4145  412d
   4146  412d				   .continuelastP1
   4147  412d		       85 1c		      sta	GRP1	;3
   4148  412f
   4149  412f					      ifnconst	player1colors
   4150  412f		       a5 87		      lda	missile1height	;3
   4151  4131		       c7 88		      dcp	missile1y	;5
   4152  4133				  -	      else
   4153  4133				  -	      lda	(player1color),y
   4154  4133				  -	      sta	COLUP1
   4155  4133					      endif
   4156  4133
   4157  4133		       ca		      dex
   4158  4134							;dec temp4 ; might try putting this above PF writes
   4159  4134		       f0 34		      beq	endkernel
   4160  4136
   4161  4136
   4162  4136				  -	      ifconst	pfres
   4163  4136				  -	      ldy.w	playfield+pfres*pfwidth-4
   4164  4136				  -	      sty	PF1L	;3
   4165  4136				  -	      ldy.w	playfield+pfres*pfwidth-3-pfadjust
   4166  4136				  -	      sty	PF2L	;3
   4167  4136				  -	      ldy.w	playfield+pfres*pfwidth-1
   4168  4136				  -	      sty	PF1R	; possibly too early?
   4169  4136				  -	      ldy.w	playfield+pfres*pfwidth-2-pfadjust
   4170  4136				  -	      sty	PF2R	;3
   4171  4136					      else
   4172  4136		       ac d0 00 	      ldy.w	playfield-48+pfwidth*12+44
   4173  4139		       84 0e		      sty	PF1L	;3
   4174  413b		       ac d1 00 	      ldy.w	playfield-48+pfwidth*12+45-pfadjust
   4175  413e		       84 0f		      sty	PF2L	;3
   4176  4140		       ac d3 00 	      ldy.w	playfield-48+pfwidth*12+47
   4177  4143		       84 0e		      sty	PF1R	; possibly too early?
   4178  4145		       ac d2 00 	      ldy.w	playfield-48+pfwidth*12+46-pfadjust
   4179  4148		       84 0f		      sty	PF2R	;3
   4180  414a					      endif
   4181  414a
   4182  414a					      ifnconst	player1colors
   4183  414a		       2a		      rol		;2
   4184  414b		       2a		      rol		;2
   4185  414c		       85 1e		      sta	ENAM1	;3
   4186  414e				  -	      else
   4187  414e				  -	      ifnconst	playercolors
   4188  414e				  -	      sleep	7
   4189  414e				  -	      else
   4190  414e				  -	      lda.w	player0colorstore
   4191  414e				  -	      sta	COLUP0
   4192  414e				  -	      endif
   4193  414e					      endif
   4194  414e
   4195  414e		       ad 8e 00 	      lda.w	player0height
   4196  4151		       c7 85		      dcp	player0y
   4197  4153		       90 0d		      bcc	.skipDrawlastP0
   4198  4155		       a4 85		      ldy	player0y
   4199  4157		       b1 8a		      lda	(player0pointer),y
   4200  4159				   .continuelastP0
   4201  4159		       85 1b		      sta	GRP0
   4202  415b
   4203  415b
   4204  415b
   4205  415b				  -	      ifnconst	no_blank_lines
   4206  415b				  -	      lda	missile0height	;3
   4207  415b				  -	      dcp	missile0y	;5
   4208  415b				  -	      sbc	stack1
   4209  415b				  -	      sta	ENAM0	;3
   4210  415b				  -	      jmp	.endkerloop
   4211  415b					      else
   4212  415b				  -	      ifconst	readpaddle
   4213  415b				  -	      ldy	currentpaddle
   4214  415b				  -	      lda	INPT0,y
   4215  415b				  -	      bpl	noreadpaddle2
   4216  415b				  -	      inc	paddle
   4217  415b				  -	      jmp	.endkerloop
   4218  415b				  -noreadpaddle2
   4219  415b				  -	      sleep	4
   4220  415b				  -	      jmp	.endkerloop
   4221  415b					      else		; no_blank_lines and no paddle reading
   4222  415b		       68		      pla
   4223  415c		       48		      pha		; 14 cycles in 4 bytes
   4224  415d		       68		      pla
   4225  415e		       48		      pha
   4226  415f							; sleep 14
   4227  415f		       4c 06 f1 	      jmp	.endkerloop
   4228  4162					      endif
   4229  4162					      endif
   4230  4162
   4231  4162
   4232  4162							; ifconst donepaddleskip
   4233  4162							;paddleskipread
   4234  4162							; this is kind of lame, since it requires 4 cycles from a page boundary crossing
   4235  4162							; plus we get a lo-res paddle read
   4236  4162							; bmi donepaddleskip
   4237  4162							; endif
   4238  4162
   4239  4162				   .skipDrawlastP0
   4240  4162		       a9 00		      lda	#0
   4241  4164		       a8		      tay
   4242  4165		       4c 59 f1 	      jmp	.continuelastP0
   4243  4168
   4244  4168					      ifconst	no_blank_lines
   4245  4168				   no_blank_lines_bailout
   4246  4168		       a2 00		      ldx	#0
   4247  416a					      endif
   4248  416a
   4249  416a				   endkernel
   4250  416a							; 6 digit score routine
   4251  416a		       86 0e		      stx	PF1
   4252  416c		       86 0f		      stx	PF2
   4253  416e		       86 0d		      stx	PF0
   4254  4170		       18		      clc
   4255  4171
   4256  4171				  -	      ifconst	pfrowheight
   4257  4171				  -	      lda	#pfrowheight+2
   4258  4171					      else
   4259  4171					      ifnconst	pfres
   4260  4171		       a9 0a		      lda	#10
   4261  4173				  -	      else
   4262  4173				  -	      lda	#(96/pfres)+2	; try to come close to the real size
   4263  4173					      endif
   4264  4173					      endif
   4265  4173
   4266  4173		       e5 ef		      sbc	playfieldpos
   4267  4175		       85 ef		      sta	playfieldpos
   4268  4177		       8a		      txa
   4269  4178
   4270  4178				  -	      ifconst	shakescreen
   4271  4178				  -	      bit	shakescreen
   4272  4178				  -	      bmi	noshakescreen2
   4273  4178				  -	      ldx	#$3D
   4274  4178				  -noshakescreen2
   4275  4178					      endif
   4276  4178
   4277  4178		       95 02		      sta	WSYNC,x
   4278  417a
   4279  417a							; STA WSYNC ;first one, need one more
   4280  417a		       85 0b		      sta	REFP0
   4281  417c		       85 0c		      sta	REFP1
   4282  417e		       85 1b		      STA	GRP0
   4283  4180		       85 1c		      STA	GRP1
   4284  4182							; STA PF1
   4285  4182							; STA PF2
   4286  4182		       85 2b		      sta	HMCLR
   4287  4184		       85 1d		      sta	ENAM0
   4288  4186		       85 1e		      sta	ENAM1
   4289  4188		       85 1f		      sta	ENABL
   4290  418a
   4291  418a		       a5 9d		      lda	temp2	;restore variables that were obliterated by kernel
   4292  418c		       85 85		      sta	player0y
   4293  418e		       a5 9e		      lda	temp3
   4294  4190		       85 86		      sta	player1y
   4295  4192					      ifnconst	player1colors
   4296  4192		       a5 a1		      lda	temp6
   4297  4194		       85 88		      sta	missile1y
   4298  4196					      endif
   4299  4196					      ifnconst	playercolors
   4300  4196					      ifnconst	readpaddle
   4301  4196		       a5 a0		      lda	temp5
   4302  4198		       85 91		      sta	missile0y
   4303  419a					      endif
   4304  419a					      endif
   4305  419a		       a5 f7		      lda	stack2
   4306  419c		       85 89		      sta	bally
   4307  419e
   4308  419e							; strangely, this isn't required any more. might have
   4309  419e							; resulted from the no_blank_lines score bounce fix
   4310  419e							;ifconst no_blank_lines
   4311  419e							;sta WSYNC
   4312  419e							;endif
   4313  419e
   4314  419e		       ad 84 02 	      lda	INTIM
   4315  41a1		       18		      clc
   4316  41a2				  -	      ifnconst	vblank_time
   4317  41a2				  -	      adc	#43+12+87
   4318  41a2					      else
   4319  41a2		       69 9d		      adc	#vblank_time+12+87
   4320  41a4
   4321  41a4					      endif
   4322  41a4							; sta WSYNC
   4323  41a4		       8d 96 02 	      sta	TIM64T
   4324  41a7
   4325  41a7				  -	      ifconst	minikernel
   4326  41a7				  -	      jsr	minikernel
   4327  41a7					      endif
   4328  41a7
   4329  41a7							; now reassign temp vars for score pointers
   4330  41a7
   4331  41a7							; score pointers contain:
   4332  41a7							; score1-5: lo1,lo2,lo3,lo4,lo5,lo6
   4333  41a7							; swap lo2->temp1
   4334  41a7							; swap lo4->temp3
   4335  41a7							; swap lo6->temp5
   4336  41a7					      ifnconst	noscore
   4337  41a7		       a5 97		      lda	scorepointers+1
   4338  41a9							; ldy temp1
   4339  41a9		       85 9c		      sta	temp1
   4340  41ab							; sty scorepointers+1
   4341  41ab
   4342  41ab		       a5 99		      lda	scorepointers+3
   4343  41ad							; ldy temp3
   4344  41ad		       85 9e		      sta	temp3
   4345  41af							; sty scorepointers+3
   4346  41af
   4347  41af
   4348  41af		       85 2b		      sta	HMCLR
   4349  41b1		       ba		      tsx
   4350  41b2		       86 f6		      stx	stack1
   4351  41b4		       a2 e0		      ldx	#$E0
   4352  41b6		       86 20		      stx	HMP0
   4353  41b8
   4354  41b8		       a5 a3		      LDA	scorecolor
   4355  41ba		       85 06		      STA	COLUP0
   4356  41bc		       85 07		      STA	COLUP1
   4357  41be				  -	      ifconst	scorefade
   4358  41be				  -	      STA	stack2
   4359  41be					      endif
   4360  41be					      ifconst	pfscore
   4361  41be		       a5 f4		      lda	pfscorecolor
   4362  41c0		       85 08		      sta	COLUPF
   4363  41c2					      endif
   4364  41c2		       85 02		      sta	WSYNC
   4365  41c4		       a2 00		      ldx	#0
   4366  41c6		       86 1b		      STx	GRP0
   4367  41c8		       86 1c		      STx	GRP1	; seems to be needed because of vdel
   4368  41ca
   4369  41ca		       a5 9b		      lda	scorepointers+5
   4370  41cc							; ldy temp5
   4371  41cc		       95 a0		      sta	temp5,x
   4372  41ce							; sty scorepointers+5
   4373  41ce		       a9 ff		      lda	#>scoretable
   4374  41d0		       85 97		      sta	scorepointers+1
   4375  41d2		       85 99		      sta	scorepointers+3
   4376  41d4		       85 9b		      sta	scorepointers+5
   4377  41d6		       85 9d		      sta	temp2
   4378  41d8		       85 9f		      sta	temp4
   4379  41da		       85 a1		      sta	temp6
   4380  41dc		       a0 07		      LDY	#7
   4381  41de		       84 25		      STY	VDELP0
   4382  41e0		       85 10		      STA	RESP0
   4383  41e2		       85 11		      STA	RESP1
   4384  41e4
   4385  41e4
   4386  41e4		       a9 03		      LDA	#$03
   4387  41e6		       85 04		      STA	NUSIZ0
   4388  41e8		       85 05		      STA	NUSIZ1
   4389  41ea		       85 26		      STA	VDELP1
   4390  41ec		       a9 f0		      LDA	#$F0
   4391  41ee		       85 21		      STA	HMP1
   4392  41f0		       b1 96		      lda	(scorepointers),y
   4393  41f2		       85 1b		      sta	GRP0
   4394  41f4		       85 2a		      STA	HMOVE	; cycle 73 ?
   4395  41f6		       4c 09 f2 	      jmp	beginscore
   4396  41f9
   4397  41f9
   4398  41f9					      if	((<*)>$d4)
   4399  4200		       00 00 00 00*	      align	256	; kludge that potentially wastes space! should be fixed!
   4400  4200					      endif
   4401  4200
   4402  4200				   loop2
   4403  4200		       b1 96		      lda	(scorepointers),y	;+5 68 204
   4404  4202		       85 1b		      sta	GRP0	;+3 71 213 D1 -- -- --
   4405  4204					      ifconst	pfscore
   4406  4204		       ad f2 00 	      lda.w	pfscore1
   4407  4207		       85 0e		      sta	PF1
   4408  4209				  -	      else
   4409  4209				  -	      ifconst	scorefade
   4410  4209				  -	      sleep	2
   4411  4209				  -	      dec	stack2	; decrement the temporary scorecolor
   4412  4209				  -	      else
   4413  4209				  -	      sleep	7
   4414  4209				  -	      endif
   4415  4209					      endif
   4416  4209							; cycle 0
   4417  4209				   beginscore
   4418  4209		       b1 9e		      lda	(scorepointers+$8),y	;+5 5 15
   4419  420b		       85 1c		      sta	GRP1	;+3 8 24 D1 D1 D2 --
   4420  420d		       b1 9c		      lda	(scorepointers+$6),y	;+5 13 39
   4421  420f		       85 1b		      sta	GRP0	;+3 16 48 D3 D1 D2 D2
   4422  4211		       b3 98		      lax	(scorepointers+$2),y	;+5 29 87
   4423  4213		       9a		      txs
   4424  4214		       b3 9a		      lax	(scorepointers+$4),y	;+5 36 108
   4425  4216				  -	      ifconst	scorefade
   4426  4216				  -	      lda	stack2
   4427  4216					      else
      0  4216					      sleep	3
      1  4216				   .CYCLES    SET	3
      2  4216
      3  4216				  -	      IF	.CYCLES < 2
      4  4216				  -	      ECHO	"MACRO ERROR: 'SLEEP': Duration must be > 1"
      5  4216				  -	      ERR
      6  4216					      ENDIF
      7  4216
      8  4216					      IF	.CYCLES & 1
      9  4216					      IFNCONST	NO_ILLEGAL_OPCODES
     10  4216		       04 00		      nop	0
     11  4218				  -	      ELSE
     12  4218				  -	      bit	VSYNC
     13  4218					      ENDIF
     14  4218				   .CYCLES    SET	.CYCLES - 3
     15  4218					      ENDIF
     16  4218
     17  4218				  -	      REPEAT	.CYCLES / 2
     18  4218				  -	      nop
     19  4218					      REPEND
   4429  4218					      endif
   4430  4218
   4431  4218					      ifconst	pfscore
   4432  4218		       a5 f3		      lda	pfscore2
   4433  421a		       85 0e		      sta	PF1
   4434  421c				  -	      else
   4435  421c				  -	      ifconst	scorefade
   4436  421c				  -	      sta	COLUP0
   4437  421c				  -	      sta	COLUP1
   4438  421c				  -	      else
   4439  421c				  -	      sleep	6
   4440  421c				  -	      endif
   4441  421c					      endif
   4442  421c
   4443  421c		       b1 a0		      lda	(scorepointers+$A),y	;+5 21 63
   4444  421e		       86 1c		      stx	GRP1	;+3 44 132 D3 D3 D4 D2!
   4445  4220		       ba		      tsx
   4446  4221		       86 1b		      stx	GRP0	;+3 47 141 D5 D3! D4 D4
   4447  4223		       85 1c		      sta	GRP1	;+3 50 150 D5 D5 D6 D4!
   4448  4225		       84 1b		      sty	GRP0	;+3 53 159 D4* D5! D6 D6
   4449  4227		       88		      dey
   4450  4228		       10 d6		      bpl	loop2	;+2 60 180
   4451  422a
   4452  422a		       a6 f6		      ldx	stack1
   4453  422c		       9a		      txs
   4454  422d							; lda scorepointers+1
   4455  422d		       a4 9c		      ldy	temp1
   4456  422f							; sta temp1
   4457  422f		       84 97		      sty	scorepointers+1
   4458  4231
   4459  4231		       a9 00		      LDA	#0
   4460  4233		       85 0e		      sta	PF1
   4461  4235		       85 1b		      STA	GRP0
   4462  4237		       85 1c		      STA	GRP1
   4463  4239		       85 25		      STA	VDELP0
   4464  423b		       85 26		      STA	VDELP1	;do we need these
   4465  423d		       85 04		      STA	NUSIZ0
   4466  423f		       85 05		      STA	NUSIZ1
   4467  4241
   4468  4241							; lda scorepointers+3
   4469  4241		       a4 9e		      ldy	temp3
   4470  4243							; sta temp3
   4471  4243		       84 99		      sty	scorepointers+3
   4472  4245
   4473  4245							; lda scorepointers+5
   4474  4245		       a4 a0		      ldy	temp5
   4475  4247							; sta temp5
   4476  4247		       84 9b		      sty	scorepointers+5
   4477  4249					      endif		;noscore
   4478  4249		       a9 c2		      LDA	#%11000010
   4479  424b		       85 02		      sta	WSYNC
   4480  424d		       85 01		      STA	VBLANK
      0  424f					      RETURN
      1  424f				  -	      ifnconst	bankswitch
      2  424f				  -	      rts
      3  424f					      else
      4  424f		       4c dd ff 	      jmp	BS_return
      5  4252					      endif
   4482  4252
   4483  4252				  -	      ifconst	shakescreen
   4484  4252				  -doshakescreen
   4485  4252				  -	      bit	shakescreen
   4486  4252				  -	      bmi	noshakescreen
   4487  4252				  -	      sta	WSYNC
   4488  4252				  -noshakescreen
   4489  4252				  -	      ldx	missile0height
   4490  4252				  -	      inx
   4491  4252				  -	      rts
   4492  4252					      endif
   4493  4252
   4494  4252							; Provided under the CC0 license. See the included LICENSE.txt for details.
   4495  4252
   4496  4252				   start
   4497  4252		       78		      sei
   4498  4253		       d8		      cld
   4499  4254		       a0 00		      ldy	#0
   4500  4256		       a5 d0		      lda	$D0
   4501  4258		       c9 2c		      cmp	#$2C	;check RAM location #1
   4502  425a		       d0 07		      bne	MachineIs2600
   4503  425c		       a5 d1		      lda	$D1
   4504  425e		       c9 a9		      cmp	#$A9	;check RAM location #2
   4505  4260		       d0 01		      bne	MachineIs2600
   4506  4262		       88		      dey
   4507  4263				   MachineIs2600
   4508  4263		       a2 00		      ldx	#0
   4509  4265		       8a		      txa
   4510  4266				   clearmem
   4511  4266		       e8		      inx
   4512  4267		       9a		      txs
   4513  4268		       48		      pha
   4514  4269		       d0 fb		      bne	clearmem
   4515  426b		       84 9c		      sty	temp1
   4516  426d					      ifnconst	multisprite
   4517  426d				  -	      ifconst	pfrowheight
   4518  426d				  -	      lda	#pfrowheight
   4519  426d					      else
   4520  426d				  -	      ifconst	pfres
   4521  426d				  -	      lda	#(96/pfres)
   4522  426d					      else
   4523  426d		       a9 08		      lda	#8
   4524  426f					      endif
   4525  426f					      endif
   4526  426f		       85 ef		      sta	playfieldpos
   4527  4271					      endif
   4528  4271		       a2 05		      ldx	#5
   4529  4273				   initscore
   4530  4273		       a9 74		      lda	#<scoretable
   4531  4275		       95 96		      sta	scorepointers,x
   4532  4277		       ca		      dex
   4533  4278		       10 f9		      bpl	initscore
   4534  427a		       a9 01		      lda	#1
   4535  427c		       85 0a		      sta	CTRLPF
   4536  427e		       0d 84 02 	      ora	INTIM
   4537  4281		       85 a2		      sta	rand
   4538  4283
   4539  4283				  -	      ifconst	multisprite
   4540  4283				  -	      jsr	multisprite_setup
   4541  4283					      endif
   4542  4283
   4543  4283				  -	      ifnconst	bankswitch
   4544  4283				  -	      jmp	game
   4545  4283					      else
   4546  4283		       a9 90		      lda	#>(game-1)
   4547  4285		       48		      pha
   4548  4286		       a9 56		      lda	#<(game-1)
   4549  4288		       48		      pha
   4550  4289		       48		      pha
   4551  428a		       48		      pha
   4552  428b		       a2 01		      ldx	#1
   4553  428d		       4c eb ff 	      jmp	BS_jsr
   4554  4290					      endif
   4555  4290							; Provided under the CC0 license. See the included LICENSE.txt for details.
   4556  4290
   4557  4290							; playfield drawing routines
   4558  4290							; you get a 32x12 bitmapped display in a single color :)
   4559  4290							; 0-31 and 0-11
   4560  4290
   4561  4290				   pfclear		; clears playfield - or fill with pattern
   4562  4290				  -	      ifconst	pfres
   4563  4290				  -	      ldx	#pfres*pfwidth-1
   4564  4290					      else
   4565  4290		       a2 2f		      ldx	#47-(4-pfwidth)*12	; will this work?
   4566  4292					      endif
   4567  4292				   pfclear_loop
   4568  4292					      ifnconst	superchip
   4569  4292		       95 a4		      sta	playfield,x
   4570  4294				  -	      else
   4571  4294				  -	      sta	playfield-128,x
   4572  4294					      endif
   4573  4294		       ca		      dex
   4574  4295		       10 fb		      bpl	pfclear_loop
      0  4297					      RETURN
      1  4297				  -	      ifnconst	bankswitch
      2  4297				  -	      rts
      3  4297					      else
      4  4297		       4c dd ff 	      jmp	BS_return
      5  429a					      endif
   4576  429a
   4577  429a				   setuppointers
   4578  429a		       86 9d		      stx	temp2	; store on.off.flip value
   4579  429c		       aa		      tax		; put x-value in x 
   4580  429d		       4a		      lsr
   4581  429e		       4a		      lsr
   4582  429f		       4a		      lsr		; divide x pos by 8 
   4583  42a0		       85 9c		      sta	temp1
   4584  42a2		       98		      tya
   4585  42a3		       0a		      asl
   4586  42a4					      if	pfwidth=4
   4587  42a4		       0a		      asl		; multiply y pos by 4
   4588  42a5					      endif		; else multiply by 2
   4589  42a5		       18		      clc
   4590  42a6		       65 9c		      adc	temp1	; add them together to get actual memory location offset
   4591  42a8		       a8		      tay		; put the value in y
   4592  42a9		       a5 9d		      lda	temp2	; restore on.off.flip value
   4593  42ab		       60		      rts
   4594  42ac
   4595  42ac				   pfread
   4596  42ac							;x=xvalue, y=yvalue
   4597  42ac		       20 9a f2 	      jsr	setuppointers
   4598  42af		       bd 44 f3 	      lda	setbyte,x
   4599  42b2		       39 a4 00 	      and	playfield,y
   4600  42b5		       5d 44 f3 	      eor	setbyte,x
   4601  42b8							; beq readzero
   4602  42b8							; lda #1
   4603  42b8							; readzero
      0  42b8					      RETURN
      1  42b8				  -	      ifnconst	bankswitch
      2  42b8				  -	      rts
      3  42b8					      else
      4  42b8		       4c dd ff 	      jmp	BS_return
      5  42bb					      endif
   4605  42bb
   4606  42bb				   pfpixel
   4607  42bb							;x=xvalue, y=yvalue, a=0,1,2
   4608  42bb		       20 9a f2 	      jsr	setuppointers
   4609  42be
   4610  42be					      ifconst	bankswitch
   4611  42be		       a5 9d		      lda	temp2	; load on.off.flip value (0,1, or 2)
   4612  42c0		       f0 0f		      beq	pixelon_r	; if "on" go to on
   4613  42c2		       4a		      lsr
   4614  42c3		       b0 18		      bcs	pixeloff_r	; value is 1 if true
   4615  42c5		       b9 a4 00 	      lda	playfield,y	; if here, it's "flip"
   4616  42c8		       5d 44 f3 	      eor	setbyte,x
   4617  42cb				  -	      ifconst	superchip
   4618  42cb				  -	      sta	playfield-128,y
   4619  42cb					      else
   4620  42cb		       99 a4 00 	      sta	playfield,y
   4621  42ce					      endif
      0  42ce					      RETURN
      1  42ce				  -	      ifnconst	bankswitch
      2  42ce				  -	      rts
      3  42ce					      else
      4  42ce		       4c dd ff 	      jmp	BS_return
      5  42d1					      endif
   4623  42d1				   pixelon_r
   4624  42d1		       b9 a4 00 	      lda	playfield,y
   4625  42d4		       1d 44 f3 	      ora	setbyte,x
   4626  42d7				  -	      ifconst	superchip
   4627  42d7				  -	      sta	playfield-128,y
   4628  42d7					      else
   4629  42d7		       99 a4 00 	      sta	playfield,y
   4630  42da					      endif
      0  42da					      RETURN
      1  42da				  -	      ifnconst	bankswitch
      2  42da				  -	      rts
      3  42da					      else
      4  42da		       4c dd ff 	      jmp	BS_return
      5  42dd					      endif
   4632  42dd				   pixeloff_r
   4633  42dd		       bd 44 f3 	      lda	setbyte,x
   4634  42e0		       49 ff		      eor	#$ff
   4635  42e2		       39 a4 00 	      and	playfield,y
   4636  42e5				  -	      ifconst	superchip
   4637  42e5				  -	      sta	playfield-128,y
   4638  42e5					      else
   4639  42e5		       99 a4 00 	      sta	playfield,y
   4640  42e8					      endif
      0  42e8					      RETURN
      1  42e8				  -	      ifnconst	bankswitch
      2  42e8				  -	      rts
      3  42e8					      else
      4  42e8		       4c dd ff 	      jmp	BS_return
      5  42eb					      endif
   4642  42eb
   4643  42eb				  -	      else
   4644  42eb				  -	      jmp	plotpoint
   4645  42eb					      endif
   4646  42eb
   4647  42eb				   pfhline
   4648  42eb							;x=xvalue, y=yvalue, a=0,1,2, temp3=endx
   4649  42eb		       20 9a f2 	      jsr	setuppointers
   4650  42ee		       4c f8 f2 	      jmp	noinc
   4651  42f1				   keepgoing
   4652  42f1		       e8		      inx
   4653  42f2		       8a		      txa
   4654  42f3		       29 07		      and	#7
   4655  42f5		       d0 01		      bne	noinc
   4656  42f7		       c8		      iny
   4657  42f8				   noinc
   4658  42f8		       20 1d f3 	      jsr	plotpoint
   4659  42fb		       e4 9e		      cpx	temp3
   4660  42fd		       30 f2		      bmi	keepgoing
      0  42ff					      RETURN
      1  42ff				  -	      ifnconst	bankswitch
      2  42ff				  -	      rts
      3  42ff					      else
      4  42ff		       4c dd ff 	      jmp	BS_return
      5  4302					      endif
   4662  4302
   4663  4302				   pfvline
   4664  4302							;x=xvalue, y=yvalue, a=0,1,2, temp3=endx
   4665  4302		       20 9a f2 	      jsr	setuppointers
   4666  4305		       84 9c		      sty	temp1	; store memory location offset
   4667  4307		       e6 9e		      inc	temp3	; increase final x by 1 
   4668  4309		       a5 9e		      lda	temp3
   4669  430b		       0a		      asl
   4670  430c					      if	pfwidth=4
   4671  430c		       0a		      asl		; multiply by 4
   4672  430d					      endif		; else multiply by 2
   4673  430d		       85 9e		      sta	temp3	; store it
   4674  430f							; Thanks to Michael Rideout for fixing a bug in this code
   4675  430f							; right now, temp1=y=starting memory location, temp3=final
   4676  430f							; x should equal original x value
   4677  430f				   keepgoingy
   4678  430f		       20 1d f3 	      jsr	plotpoint
   4679  4312		       c8		      iny
   4680  4313		       c8		      iny
   4681  4314					      if	pfwidth=4
   4682  4314		       c8		      iny
   4683  4315		       c8		      iny
   4684  4316					      endif
   4685  4316		       c4 9e		      cpy	temp3
   4686  4318		       30 f5		      bmi	keepgoingy
      0  431a					      RETURN
      1  431a				  -	      ifnconst	bankswitch
      2  431a				  -	      rts
      3  431a					      else
      4  431a		       4c dd ff 	      jmp	BS_return
      5  431d					      endif
   4688  431d
   4689  431d				   plotpoint
   4690  431d		       a5 9d		      lda	temp2	; load on.off.flip value (0,1, or 2)
   4691  431f		       f0 0d		      beq	pixelon	; if "on" go to on
   4692  4321		       4a		      lsr
   4693  4322		       b0 14		      bcs	pixeloff	; value is 1 if true
   4694  4324		       b9 a4 00 	      lda	playfield,y	; if here, it's "flip"
   4695  4327		       5d 44 f3 	      eor	setbyte,x
   4696  432a				  -	      ifconst	superchip
   4697  432a				  -	      sta	playfield-128,y
   4698  432a					      else
   4699  432a		       99 a4 00 	      sta	playfield,y
   4700  432d					      endif
   4701  432d		       60		      rts
   4702  432e				   pixelon
   4703  432e		       b9 a4 00 	      lda	playfield,y
   4704  4331		       1d 44 f3 	      ora	setbyte,x
   4705  4334				  -	      ifconst	superchip
   4706  4334				  -	      sta	playfield-128,y
   4707  4334					      else
   4708  4334		       99 a4 00 	      sta	playfield,y
   4709  4337					      endif
   4710  4337		       60		      rts
   4711  4338				   pixeloff
   4712  4338		       bd 44 f3 	      lda	setbyte,x
   4713  433b		       49 ff		      eor	#$ff
   4714  433d		       39 a4 00 	      and	playfield,y
   4715  4340				  -	      ifconst	superchip
   4716  4340				  -	      sta	playfield-128,y
   4717  4340					      else
   4718  4340		       99 a4 00 	      sta	playfield,y
   4719  4343					      endif
   4720  4343		       60		      rts
   4721  4344
   4722  4344				   setbyte
   4723  4344					      ifnconst	pfcenter
   4724  4344		       80		      .byte.b	$80
   4725  4345		       40		      .byte.b	$40
   4726  4346		       20		      .byte.b	$20
   4727  4347		       10		      .byte.b	$10
   4728  4348		       08		      .byte.b	$08
   4729  4349		       04		      .byte.b	$04
   4730  434a		       02		      .byte.b	$02
   4731  434b		       01		      .byte.b	$01
   4732  434c					      endif
   4733  434c		       01		      .byte.b	$01
   4734  434d		       02		      .byte.b	$02
   4735  434e		       04		      .byte.b	$04
   4736  434f		       08		      .byte.b	$08
   4737  4350		       10		      .byte.b	$10
   4738  4351		       20		      .byte.b	$20
   4739  4352		       40		      .byte.b	$40
   4740  4353		       80		      .byte.b	$80
   4741  4354		       80		      .byte.b	$80
   4742  4355		       40		      .byte.b	$40
   4743  4356		       20		      .byte.b	$20
   4744  4357		       10		      .byte.b	$10
   4745  4358		       08		      .byte.b	$08
   4746  4359		       04		      .byte.b	$04
   4747  435a		       02		      .byte.b	$02
   4748  435b		       01		      .byte.b	$01
   4749  435c		       01		      .byte.b	$01
   4750  435d		       02		      .byte.b	$02
   4751  435e		       04		      .byte.b	$04
   4752  435f		       08		      .byte.b	$08
   4753  4360		       10		      .byte.b	$10
   4754  4361		       20		      .byte.b	$20
   4755  4362		       40		      .byte.b	$40
   4756  4363		       80		      .byte.b	$80
   4757  4364							; Provided under the CC0 license. See the included LICENSE.txt for details.
   4758  4364
   4759  4364				   pfscroll		;(a=0 left, 1 right, 2 up, 4 down, 6=upup, 12=downdown)
   4760  4364		       d0 15		      bne	notleft
   4761  4366							;left
   4762  4366				  -	      ifconst	pfres
   4763  4366				  -	      ldx	#pfres*4
   4764  4366					      else
   4765  4366		       a2 30		      ldx	#48
   4766  4368					      endif
   4767  4368				   leftloop
   4768  4368		       b5 a3		      lda	playfield-1,x
   4769  436a		       4a		      lsr
   4770  436b
   4771  436b				  -	      ifconst	superchip
   4772  436b				  -	      lda	playfield-2,x
   4773  436b				  -	      rol
   4774  436b				  -	      sta	playfield-130,x
   4775  436b				  -	      lda	playfield-3,x
   4776  436b				  -	      ror
   4777  436b				  -	      sta	playfield-131,x
   4778  436b				  -	      lda	playfield-4,x
   4779  436b				  -	      rol
   4780  436b				  -	      sta	playfield-132,x
   4781  436b				  -	      lda	playfield-1,x
   4782  436b				  -	      ror
   4783  436b				  -	      sta	playfield-129,x
   4784  436b					      else
   4785  436b		       36 a2		      rol	playfield-2,x
   4786  436d		       76 a1		      ror	playfield-3,x
   4787  436f		       36 a0		      rol	playfield-4,x
   4788  4371		       76 a3		      ror	playfield-1,x
   4789  4373					      endif
   4790  4373
   4791  4373		       8a		      txa
   4792  4374		       cb 04		      sbx	#4
   4793  4376		       d0 f0		      bne	leftloop
      0  4378					      RETURN
      1  4378				  -	      ifnconst	bankswitch
      2  4378				  -	      rts
      3  4378					      else
      4  4378		       4c dd ff 	      jmp	BS_return
      5  437b					      endif
   4795  437b
   4796  437b				   notleft
   4797  437b		       4a		      lsr
   4798  437c		       90 15		      bcc	notright
   4799  437e							;right
   4800  437e
   4801  437e				  -	      ifconst	pfres
   4802  437e				  -	      ldx	#pfres*4
   4803  437e					      else
   4804  437e		       a2 30		      ldx	#48
   4805  4380					      endif
   4806  4380				   rightloop
   4807  4380		       b5 a0		      lda	playfield-4,x
   4808  4382		       4a		      lsr
   4809  4383				  -	      ifconst	superchip
   4810  4383				  -	      lda	playfield-3,x
   4811  4383				  -	      rol
   4812  4383				  -	      sta	playfield-131,x
   4813  4383				  -	      lda	playfield-2,x
   4814  4383				  -	      ror
   4815  4383				  -	      sta	playfield-130,x
   4816  4383				  -	      lda	playfield-1,x
   4817  4383				  -	      rol
   4818  4383				  -	      sta	playfield-129,x
   4819  4383				  -	      lda	playfield-4,x
   4820  4383				  -	      ror
   4821  4383				  -	      sta	playfield-132,x
   4822  4383					      else
   4823  4383		       36 a1		      rol	playfield-3,x
   4824  4385		       76 a2		      ror	playfield-2,x
   4825  4387		       36 a3		      rol	playfield-1,x
   4826  4389		       76 a0		      ror	playfield-4,x
   4827  438b					      endif
   4828  438b		       8a		      txa
   4829  438c		       cb 04		      sbx	#4
   4830  438e		       d0 f0		      bne	rightloop
      0  4390					      RETURN
      1  4390				  -	      ifnconst	bankswitch
      2  4390				  -	      rts
      3  4390					      else
      4  4390		       4c dd ff 	      jmp	BS_return
      5  4393					      endif
   4832  4393
   4833  4393				   notright
   4834  4393		       4a		      lsr
   4835  4394		       90 4b		      bcc	notup
   4836  4396							;up
   4837  4396		       4a		      lsr
   4838  4397		       90 02		      bcc	onedecup
   4839  4399		       c6 ef		      dec	playfieldpos
   4840  439b				   onedecup
   4841  439b		       c6 ef		      dec	playfieldpos
   4842  439d		       f0 02		      beq	shiftdown
   4843  439f		       10 3d		      bpl	noshiftdown2
   4844  43a1				   shiftdown
   4845  43a1				  -	      ifconst	pfrowheight
   4846  43a1				  -	      lda	#pfrowheight
   4847  43a1					      else
   4848  43a1					      ifnconst	pfres
   4849  43a1		       a9 08		      lda	#8
   4850  43a3				  -	      else
   4851  43a3				  -	      lda	#(96/pfres)	; try to come close to the real size
   4852  43a3					      endif
   4853  43a3					      endif
   4854  43a3
   4855  43a3		       85 ef		      sta	playfieldpos
   4856  43a5		       a5 a7		      lda	playfield+3
   4857  43a7		       85 9f		      sta	temp4
   4858  43a9		       a5 a6		      lda	playfield+2
   4859  43ab		       85 9e		      sta	temp3
   4860  43ad		       a5 a5		      lda	playfield+1
   4861  43af		       85 9d		      sta	temp2
   4862  43b1		       a5 a4		      lda	playfield
   4863  43b3		       85 9c		      sta	temp1
   4864  43b5		       a2 00		      ldx	#0
   4865  43b7				   up2
   4866  43b7		       b5 a8		      lda	playfield+4,x
   4867  43b9				  -	      ifconst	superchip
   4868  43b9				  -	      sta	playfield-128,x
   4869  43b9				  -	      lda	playfield+5,x
   4870  43b9				  -	      sta	playfield-127,x
   4871  43b9				  -	      lda	playfield+6,x
   4872  43b9				  -	      sta	playfield-126,x
   4873  43b9				  -	      lda	playfield+7,x
   4874  43b9				  -	      sta	playfield-125,x
   4875  43b9					      else
   4876  43b9		       95 a4		      sta	playfield,x
   4877  43bb		       b5 a9		      lda	playfield+5,x
   4878  43bd		       95 a5		      sta	playfield+1,x
   4879  43bf		       b5 aa		      lda	playfield+6,x
   4880  43c1		       95 a6		      sta	playfield+2,x
   4881  43c3		       b5 ab		      lda	playfield+7,x
   4882  43c5		       95 a7		      sta	playfield+3,x
   4883  43c7					      endif
   4884  43c7		       8a		      txa
   4885  43c8		       cb fc		      sbx	#252
   4886  43ca				  -	      ifconst	pfres
   4887  43ca				  -	      cpx	#(pfres-1)*4
   4888  43ca					      else
   4889  43ca		       e0 2c		      cpx	#44
   4890  43cc					      endif
   4891  43cc		       d0 e9		      bne	up2
   4892  43ce
   4893  43ce		       a5 9f		      lda	temp4
   4894  43d0
   4895  43d0				  -	      ifconst	superchip
   4896  43d0				  -	      ifconst	pfres
   4897  43d0				  -	      sta	playfield+pfres*4-129
   4898  43d0				  -	      lda	temp3
   4899  43d0				  -	      sta	playfield+pfres*4-130
   4900  43d0				  -	      lda	temp2
   4901  43d0				  -	      sta	playfield+pfres*4-131
   4902  43d0				  -	      lda	temp1
   4903  43d0				  -	      sta	playfield+pfres*4-132
   4904  43d0				  -	      else
   4905  43d0				  -	      sta	playfield+47-128
   4906  43d0				  -	      lda	temp3
   4907  43d0				  -	      sta	playfield+46-128
   4908  43d0				  -	      lda	temp2
   4909  43d0				  -	      sta	playfield+45-128
   4910  43d0				  -	      lda	temp1
   4911  43d0				  -	      sta	playfield+44-128
   4912  43d0				  -	      endif
   4913  43d0					      else
   4914  43d0				  -	      ifconst	pfres
   4915  43d0				  -	      sta	playfield+pfres*4-1
   4916  43d0				  -	      lda	temp3
   4917  43d0				  -	      sta	playfield+pfres*4-2
   4918  43d0				  -	      lda	temp2
   4919  43d0				  -	      sta	playfield+pfres*4-3
   4920  43d0				  -	      lda	temp1
   4921  43d0				  -	      sta	playfield+pfres*4-4
   4922  43d0					      else
   4923  43d0		       85 d3		      sta	playfield+47
   4924  43d2		       a5 9e		      lda	temp3
   4925  43d4		       85 d2		      sta	playfield+46
   4926  43d6		       a5 9d		      lda	temp2
   4927  43d8		       85 d1		      sta	playfield+45
   4928  43da		       a5 9c		      lda	temp1
   4929  43dc		       85 d0		      sta	playfield+44
   4930  43de					      endif
   4931  43de					      endif
   4932  43de				   noshiftdown2
      0  43de					      RETURN
      1  43de				  -	      ifnconst	bankswitch
      2  43de				  -	      rts
      3  43de					      else
      4  43de		       4c dd ff 	      jmp	BS_return
      5  43e1					      endif
   4934  43e1
   4935  43e1
   4936  43e1				   notup
   4937  43e1							;down
   4938  43e1		       4a		      lsr
   4939  43e2		       b0 02		      bcs	oneincup
   4940  43e4		       e6 ef		      inc	playfieldpos
   4941  43e6				   oneincup
   4942  43e6		       e6 ef		      inc	playfieldpos
   4943  43e8		       a5 ef		      lda	playfieldpos
   4944  43ea
   4945  43ea				  -	      ifconst	pfrowheight
   4946  43ea				  -	      cmp	#pfrowheight+1
   4947  43ea					      else
   4948  43ea					      ifnconst	pfres
   4949  43ea		       c9 09		      cmp	#9
   4950  43ec				  -	      else
   4951  43ec				  -	      cmp	#(96/pfres)+1	; try to come close to the real size
   4952  43ec					      endif
   4953  43ec					      endif
   4954  43ec
   4955  43ec		       90 3b		      bcc	noshiftdown
   4956  43ee		       a9 01		      lda	#1
   4957  43f0		       85 ef		      sta	playfieldpos
   4958  43f2
   4959  43f2				  -	      ifconst	pfres
   4960  43f2				  -	      lda	playfield+pfres*4-1
   4961  43f2				  -	      sta	temp4
   4962  43f2				  -	      lda	playfield+pfres*4-2
   4963  43f2				  -	      sta	temp3
   4964  43f2				  -	      lda	playfield+pfres*4-3
   4965  43f2				  -	      sta	temp2
   4966  43f2				  -	      lda	playfield+pfres*4-4
   4967  43f2					      else
   4968  43f2		       a5 d3		      lda	playfield+47
   4969  43f4		       85 9f		      sta	temp4
   4970  43f6		       a5 d2		      lda	playfield+46
   4971  43f8		       85 9e		      sta	temp3
   4972  43fa		       a5 d1		      lda	playfield+45
   4973  43fc		       85 9d		      sta	temp2
   4974  43fe		       a5 d0		      lda	playfield+44
   4975  4400					      endif
   4976  4400
   4977  4400		       85 9c		      sta	temp1
   4978  4402
   4979  4402				  -	      ifconst	pfres
   4980  4402				  -	      ldx	#(pfres-1)*4
   4981  4402					      else
   4982  4402		       a2 2c		      ldx	#44
   4983  4404					      endif
   4984  4404				   down2
   4985  4404		       b5 a3		      lda	playfield-1,x
   4986  4406				  -	      ifconst	superchip
   4987  4406				  -	      sta	playfield-125,x
   4988  4406				  -	      lda	playfield-2,x
   4989  4406				  -	      sta	playfield-126,x
   4990  4406				  -	      lda	playfield-3,x
   4991  4406				  -	      sta	playfield-127,x
   4992  4406				  -	      lda	playfield-4,x
   4993  4406				  -	      sta	playfield-128,x
   4994  4406					      else
   4995  4406		       95 a7		      sta	playfield+3,x
   4996  4408		       b5 a2		      lda	playfield-2,x
   4997  440a		       95 a6		      sta	playfield+2,x
   4998  440c		       b5 a1		      lda	playfield-3,x
   4999  440e		       95 a5		      sta	playfield+1,x
   5000  4410		       b5 a0		      lda	playfield-4,x
   5001  4412		       95 a4		      sta	playfield,x
   5002  4414					      endif
   5003  4414		       8a		      txa
   5004  4415		       cb 04		      sbx	#4
   5005  4417		       d0 eb		      bne	down2
   5006  4419
   5007  4419		       a5 9f		      lda	temp4
   5008  441b				  -	      ifconst	superchip
   5009  441b				  -	      sta	playfield-125
   5010  441b				  -	      lda	temp3
   5011  441b				  -	      sta	playfield-126
   5012  441b				  -	      lda	temp2
   5013  441b				  -	      sta	playfield-127
   5014  441b				  -	      lda	temp1
   5015  441b				  -	      sta	playfield-128
   5016  441b					      else
   5017  441b		       85 a7		      sta	playfield+3
   5018  441d		       a5 9e		      lda	temp3
   5019  441f		       85 a6		      sta	playfield+2
   5020  4421		       a5 9d		      lda	temp2
   5021  4423		       85 a5		      sta	playfield+1
   5022  4425		       a5 9c		      lda	temp1
   5023  4427		       85 a4		      sta	playfield
   5024  4429					      endif
   5025  4429				   noshiftdown
      0  4429					      RETURN
      1  4429				  -	      ifnconst	bankswitch
      2  4429				  -	      rts
      3  4429					      else
      4  4429		       4c dd ff 	      jmp	BS_return
      5  442c					      endif
   5027  442c							; Provided under the CC0 license. See the included LICENSE.txt for details.
   5028  442c
   5029  442c							;standard routines needed for pretty much all games
   5030  442c							; just the random number generator is left - maybe we should remove this asm file altogether?
   5031  442c							; repositioning code and score pointer setup moved to overscan
   5032  442c							; read switches, joysticks now compiler generated (more efficient)
   5033  442c
   5034  442c				   randomize
   5035  442c		       a5 a2		      lda	rand
   5036  442e		       4a		      lsr
   5037  442f					      ifconst	rand16
   5038  442f		       26 ed		      rol	rand16
   5039  4431					      endif
   5040  4431		       90 02		      bcc	noeor
   5041  4433		       49 b4		      eor	#$B4
   5042  4435				   noeor
   5043  4435		       85 a2		      sta	rand
   5044  4437					      ifconst	rand16
   5045  4437		       45 ed		      eor	rand16
   5046  4439					      endif
      0  4439					      RETURN
      1  4439				  -	      ifnconst	bankswitch
      2  4439				  -	      rts
      3  4439					      else
      4  4439		       4c dd ff 	      jmp	BS_return
      5  443c					      endif
   5048  443c							; Provided under the CC0 license. See the included LICENSE.txt for details.
   5049  443c
   5050  443c				   drawscreen
   5051  443c				  -	      ifconst	debugscore
   5052  443c				  -	      ldx	#14
   5053  443c				  -	      lda	INTIM	; display # cycles left in the score
   5054  443c				  -
   5055  443c				  -	      ifconst	mincycles
   5056  443c				  -	      lda	mincycles
   5057  443c				  -	      cmp	INTIM
   5058  443c				  -	      lda	mincycles
   5059  443c				  -	      bcc	nochange
   5060  443c				  -	      lda	INTIM
   5061  443c				  -	      sta	mincycles
   5062  443c				  -nochange
   5063  443c				  -	      endif
   5064  443c				  -
   5065  443c				  -			; cmp #$2B
   5066  443c				  -			; bcs no_cycles_left
   5067  443c				  -	      bmi	cycles_left
   5068  443c				  -	      ldx	#64
   5069  443c				  -	      eor	#$ff	;make negative
   5070  443c				  -cycles_left
   5071  443c				  -	      stx	scorecolor
   5072  443c				  -	      and	#$7f	; clear sign bit
   5073  443c				  -	      tax
   5074  443c				  -	      lda	scorebcd,x
   5075  443c				  -	      sta	score+2
   5076  443c				  -	      lda	scorebcd1,x
   5077  443c				  -	      sta	score+1
   5078  443c				  -	      jmp	done_debugscore
   5079  443c				  -scorebcd
   5080  443c				  -	      .byte	$00, $64, $28, $92, $56, $20, $84, $48, $12, $76, $40
   5081  443c				  -	      .byte	$04, $68, $32, $96, $60, $24, $88, $52, $16, $80, $44
   5082  443c				  -	      .byte	$08, $72, $36, $00, $64, $28, $92, $56, $20, $84, $48
   5083  443c				  -	      .byte	$12, $76, $40, $04, $68, $32, $96, $60, $24, $88
   5084  443c				  -scorebcd1
   5085  443c				  -	      .byte	0, 0, 1, 1, 2, 3, 3, 4, 5, 5, 6
   5086  443c				  -	      .byte	7, 7, 8, 8, 9, $10, $10, $11, $12, $12, $13
   5087  443c				  -	      .byte	$14, $14, $15, $16, $16, $17, $17, $18, $19, $19, $20
   5088  443c				  -	      .byte	$21, $21, $22, $23, $23, $24, $24, $25, $26, $26
   5089  443c				  -done_debugscore
   5090  443c					      endif
   5091  443c
   5092  443c				  -	      ifconst	debugcycles
   5093  443c				  -	      lda	INTIM	; if we go over, it mucks up the background color
   5094  443c				  -			; cmp #$2B
   5095  443c				  -			; BCC overscan
   5096  443c				  -	      bmi	overscan
   5097  443c				  -	      sta	COLUBK
   5098  443c				  -	      bcs	doneoverscan
   5099  443c					      endif
   5100  443c
   5101  443c				   overscan
   5102  443c				  -	      ifconst	interlaced
   5103  443c				  -	      PHP
   5104  443c				  -	      PLA
   5105  443c				  -	      EOR	#4	; flip interrupt bit
   5106  443c				  -	      PHA
   5107  443c				  -	      PLP
   5108  443c				  -	      AND	#4	; isolate the interrupt bit
   5109  443c				  -	      TAX		; save it for later
   5110  443c					      endif
   5111  443c
   5112  443c				   overscanloop
   5113  443c		       ad 84 02 	      lda	INTIM	;wait for sync
   5114  443f		       30 fb		      bmi	overscanloop
   5115  4441				   doneoverscan
   5116  4441
   5117  4441							;do VSYNC
   5118  4441
   5119  4441				  -	      ifconst	interlaced
   5120  4441				  -	      CPX	#4
   5121  4441				  -	      BNE	oddframevsync
   5122  4441					      endif
   5123  4441
   5124  4441		       a9 02		      lda	#2
   5125  4443		       85 02		      sta	WSYNC
   5126  4445		       85 00		      sta	VSYNC
   5127  4447		       85 02		      STA	WSYNC
   5128  4449		       85 02		      STA	WSYNC
   5129  444b		       4a		      lsr
   5130  444c		       85 02		      STA	WSYNC
   5131  444e		       85 00		      STA	VSYNC
   5132  4450		       85 01		      sta	VBLANK
   5133  4452				  -	      ifnconst	overscan_time
   5134  4452				  -	      lda	#37+128
   5135  4452					      else
   5136  4452		       a9 d2		      lda	#overscan_time+128
   5137  4454					      endif
   5138  4454		       8d 96 02 	      sta	TIM64T
   5139  4457
   5140  4457				  -	      ifconst	interlaced
   5141  4457				  -	      jmp	postsync
   5142  4457				  -
   5143  4457				  -oddframevsync
   5144  4457				  -	      sta	WSYNC
   5145  4457				  -
   5146  4457				  -	      LDA	($80,X)	; 11 waste
   5147  4457				  -	      LDA	($80,X)	; 11 waste
   5148  4457				  -	      LDA	($80,X)	; 11 waste
   5149  4457				  -
   5150  4457				  -	      lda	#2
   5151  4457				  -	      sta	VSYNC
   5152  4457				  -	      sta	WSYNC
   5153  4457				  -	      sta	WSYNC
   5154  4457				  -	      sta	WSYNC
   5155  4457				  -
   5156  4457				  -	      LDA	($80,X)	; 11 waste
   5157  4457				  -	      LDA	($80,X)	; 11 waste
   5158  4457				  -	      LDA	($80,X)	; 11 waste
   5159  4457				  -
   5160  4457				  -	      lda	#0
   5161  4457				  -	      sta	VSYNC
   5162  4457				  -	      sta	VBLANK
   5163  4457				  -	      ifnconst	overscan_time
   5164  4457				  -	      lda	#37+128
   5165  4457				  -	      else
   5166  4457				  -	      lda	#overscan_time+128
   5167  4457				  -	      endif
   5168  4457				  -	      sta	TIM64T
   5169  4457				  -
   5170  4457				  -postsync
   5171  4457					      endif
   5172  4457
   5173  4457				  -	      ifconst	legacy
   5174  4457				  -	      if	legacy < 100
   5175  4457				  -	      ldx	#4
   5176  4457				  -adjustloop
   5177  4457				  -	      lda	player0x,x
   5178  4457				  -	      sec
   5179  4457				  -	      sbc	#14	;?
   5180  4457				  -	      sta	player0x,x
   5181  4457				  -	      dex
   5182  4457				  -	      bpl	adjustloop
   5183  4457				  -	      endif
   5184  4457					      endif
   5185  4457				  -	      if	((<*)>$e9)&&((<*)<$fa)
   5186  4457				  -	      repeat	($fa-(<*))
   5187  4457				  -	      nop
   5188  4457				  -	      repend
   5189  4457					      endif
   5190  4457		       85 02		      sta	WSYNC
   5191  4459		       a2 04		      ldx	#4
      0  445b					      SLEEP	3
      1  445b				   .CYCLES    SET	3
      2  445b
      3  445b				  -	      IF	.CYCLES < 2
      4  445b				  -	      ECHO	"MACRO ERROR: 'SLEEP': Duration must be > 1"
      5  445b				  -	      ERR
      6  445b					      ENDIF
      7  445b
      8  445b					      IF	.CYCLES & 1
      9  445b					      IFNCONST	NO_ILLEGAL_OPCODES
     10  445b		       04 00		      nop	0
     11  445d				  -	      ELSE
     12  445d				  -	      bit	VSYNC
     13  445d					      ENDIF
     14  445d				   .CYCLES    SET	.CYCLES - 3
     15  445d					      ENDIF
     16  445d
     17  445d				  -	      REPEAT	.CYCLES / 2
     18  445d				  -	      nop
     19  445d					      REPEND
   5193  445d				   HorPosLoop		; 5
   5194  445d		       b5 80		      lda	player0x,X	;+4 9
   5195  445f		       38		      sec		;+2 11
   5196  4460				   DivideLoop
   5197  4460		       e9 0f		      sbc	#15
   5198  4462		       b0 fc		      bcs	DivideLoop	;+4 15
   5199  4464		       95 9c		      sta	temp1,X	;+4 19
   5200  4466		       95 10		      sta	RESP0,X	;+4 23
   5201  4468		       85 02		      sta	WSYNC
   5202  446a		       ca		      dex
   5203  446b		       10 f0		      bpl	HorPosLoop	;+5 5
   5204  446d							; 4
   5205  446d
   5206  446d		       a2 04		      ldx	#4
   5207  446f		       b4 9c		      ldy	temp1,X
   5208  4471		       b9 cd f3 	      lda	repostable-256,Y
   5209  4474		       95 20		      sta	HMP0,X	;+14 18
   5210  4476
   5211  4476		       ca		      dex
   5212  4477		       b4 9c		      ldy	temp1,X
   5213  4479		       b9 cd f3 	      lda	repostable-256,Y
   5214  447c		       95 20		      sta	HMP0,X	;+14 32
   5215  447e
   5216  447e		       ca		      dex
   5217  447f		       b4 9c		      ldy	temp1,X
   5218  4481		       b9 cd f3 	      lda	repostable-256,Y
   5219  4484		       95 20		      sta	HMP0,X	;+14 46
   5220  4486
   5221  4486		       ca		      dex
   5222  4487		       b4 9c		      ldy	temp1,X
   5223  4489		       b9 cd f3 	      lda	repostable-256,Y
   5224  448c		       95 20		      sta	HMP0,X	;+14 60
   5225  448e
   5226  448e		       ca		      dex
   5227  448f		       b4 9c		      ldy	temp1,X
   5228  4491		       b9 cd f3 	      lda	repostable-256,Y
   5229  4494		       95 20		      sta	HMP0,X	;+14 74
   5230  4496
   5231  4496		       85 02		      sta	WSYNC
   5232  4498
   5233  4498		       85 2a		      sta	HMOVE	;+3 3
   5234  449a
   5235  449a
   5236  449a				  -	      ifconst	legacy
   5237  449a				  -	      if	legacy < 100
   5238  449a				  -	      ldx	#4
   5239  449a				  -adjustloop2
   5240  449a				  -	      lda	player0x,x
   5241  449a				  -	      clc
   5242  449a				  -	      adc	#14	;?
   5243  449a				  -	      sta	player0x,x
   5244  449a				  -	      dex
   5245  449a				  -	      bpl	adjustloop2
   5246  449a				  -	      endif
   5247  449a					      endif
   5248  449a
   5249  449a
   5250  449a
   5251  449a
   5252  449a							;set score pointers
   5253  449a		       a7 95		      lax	score+2
   5254  449c		       20 cd f4 	      jsr	scorepointerset
   5255  449f		       84 9b		      sty	scorepointers+5
   5256  44a1		       86 98		      stx	scorepointers+2
   5257  44a3		       a7 94		      lax	score+1
   5258  44a5		       20 cd f4 	      jsr	scorepointerset
   5259  44a8		       84 9a		      sty	scorepointers+4
   5260  44aa		       86 97		      stx	scorepointers+1
   5261  44ac		       a7 93		      lax	score
   5262  44ae		       20 cd f4 	      jsr	scorepointerset
   5263  44b1		       84 99		      sty	scorepointers+3
   5264  44b3		       86 96		      stx	scorepointers
   5265  44b5
   5266  44b5				   vblk
   5267  44b5							; run possible vblank bB code
   5268  44b5				  -	      ifconst	vblank_bB_code
   5269  44b5				  -	      jsr	vblank_bB_code
   5270  44b5					      endif
   5271  44b5				   vblk2
   5272  44b5		       ad 84 02 	      LDA	INTIM
   5273  44b8		       30 fb		      bmi	vblk2
   5274  44ba		       4c 00 f0 	      jmp	kernel
   5275  44bd
   5276  44bd
   5277  44bd		       80 70 60 50*	      .byte.b	$80,$70,$60,$50,$40,$30,$20,$10,$00
   5278  44c6		       f0 e0 d0 c0*	      .byte.b	$F0,$E0,$D0,$C0,$B0,$A0,$90
   5279  44cd				   repostable
   5280  44cd
   5281  44cd				   scorepointerset
   5282  44cd		       29 0f		      and	#$0F
   5283  44cf		       0a		      asl
   5284  44d0		       0a		      asl
   5285  44d1		       0a		      asl
   5286  44d2		       69 74		      adc	#<scoretable
   5287  44d4		       a8		      tay
   5288  44d5		       8a		      txa
   5289  44d6							; and #$F0
   5290  44d6							; lsr
   5291  44d6		       4b f0		      asr	#$F0
   5292  44d8		       69 74		      adc	#<scoretable
   5293  44da		       aa		      tax
   5294  44db		       60		      rts
   5295  44dc							;bB.asm
   5296  44dc							; bB.asm file is split here
   5297  44dc				  -	      ifconst	pfres
   5298  44dc				  -	      if	(<*) > (254-pfres*pfwidth)
   5299  44dc				  -	      align	256
   5300  44dc				  -	      endif
   5301  44dc				  -	      if	(<*) < (136-pfres*pfwidth)
   5302  44dc				  -	      repeat	((136-pfres*pfwidth)-(<*))
   5303  44dc				  -	      .byte	0
   5304  44dc				  -	      repend
   5305  44dc				  -	      endif
   5306  44dc					      else
   5307  44dc					      if	(<*) > 206
   5308  4500		       00 00 00 00*	      align	256
   5309  4500					      endif
   5310  4500					      if	(<*) < 88
   5311  4500					      repeat	(88-(<*))
   5312  4500		       00		      .byte.b	0
   5311  4500					      repend
   5312  4501		       00		      .byte.b	0
   5311  4501					      repend
   5312  4502		       00		      .byte.b	0
   5311  4502					      repend
   5312  4503		       00		      .byte.b	0
   5311  4503					      repend
   5312  4504		       00		      .byte.b	0
   5311  4504					      repend
   5312  4505		       00		      .byte.b	0
   5311  4505					      repend
   5312  4506		       00		      .byte.b	0
   5311  4506					      repend
   5312  4507		       00		      .byte.b	0
   5311  4507					      repend
   5312  4508		       00		      .byte.b	0
   5311  4508					      repend
   5312  4509		       00		      .byte.b	0
   5311  4509					      repend
   5312  450a		       00		      .byte.b	0
   5311  450a					      repend
   5312  450b		       00		      .byte.b	0
   5311  450b					      repend
   5312  450c		       00		      .byte.b	0
   5311  450c					      repend
   5312  450d		       00		      .byte.b	0
   5311  450d					      repend
   5312  450e		       00		      .byte.b	0
   5311  450e					      repend
   5312  450f		       00		      .byte.b	0
   5311  450f					      repend
   5312  4510		       00		      .byte.b	0
   5311  4510					      repend
   5312  4511		       00		      .byte.b	0
   5311  4511					      repend
   5312  4512		       00		      .byte.b	0
   5311  4512					      repend
   5312  4513		       00		      .byte.b	0
   5311  4513					      repend
   5312  4514		       00		      .byte.b	0
   5311  4514					      repend
   5312  4515		       00		      .byte.b	0
   5311  4515					      repend
   5312  4516		       00		      .byte.b	0
   5311  4516					      repend
   5312  4517		       00		      .byte.b	0
   5311  4517					      repend
   5312  4518		       00		      .byte.b	0
   5311  4518					      repend
   5312  4519		       00		      .byte.b	0
   5311  4519					      repend
   5312  451a		       00		      .byte.b	0
   5311  451a					      repend
   5312  451b		       00		      .byte.b	0
   5311  451b					      repend
   5312  451c		       00		      .byte.b	0
   5311  451c					      repend
   5312  451d		       00		      .byte.b	0
   5311  451d					      repend
   5312  451e		       00		      .byte.b	0
   5311  451e					      repend
   5312  451f		       00		      .byte.b	0
   5311  451f					      repend
   5312  4520		       00		      .byte.b	0
   5311  4520					      repend
   5312  4521		       00		      .byte.b	0
   5311  4521					      repend
   5312  4522		       00		      .byte.b	0
   5311  4522					      repend
   5312  4523		       00		      .byte.b	0
   5311  4523					      repend
   5312  4524		       00		      .byte.b	0
   5311  4524					      repend
   5312  4525		       00		      .byte.b	0
   5311  4525					      repend
   5312  4526		       00		      .byte.b	0
   5311  4526					      repend
   5312  4527		       00		      .byte.b	0
   5311  4527					      repend
   5312  4528		       00		      .byte.b	0
   5311  4528					      repend
   5312  4529		       00		      .byte.b	0
   5311  4529					      repend
   5312  452a		       00		      .byte.b	0
   5311  452a					      repend
   5312  452b		       00		      .byte.b	0
   5311  452b					      repend
   5312  452c		       00		      .byte.b	0
   5311  452c					      repend
   5312  452d		       00		      .byte.b	0
   5311  452d					      repend
   5312  452e		       00		      .byte.b	0
   5311  452e					      repend
   5312  452f		       00		      .byte.b	0
   5311  452f					      repend
   5312  4530		       00		      .byte.b	0
   5311  4530					      repend
   5312  4531		       00		      .byte.b	0
   5311  4531					      repend
   5312  4532		       00		      .byte.b	0
   5311  4532					      repend
   5312  4533		       00		      .byte.b	0
   5311  4533					      repend
   5312  4534		       00		      .byte.b	0
   5311  4534					      repend
   5312  4535		       00		      .byte.b	0
   5311  4535					      repend
   5312  4536		       00		      .byte.b	0
   5311  4536					      repend
   5312  4537		       00		      .byte.b	0
   5311  4537					      repend
   5312  4538		       00		      .byte.b	0
   5311  4538					      repend
   5312  4539		       00		      .byte.b	0
   5311  4539					      repend
   5312  453a		       00		      .byte.b	0
   5311  453a					      repend
   5312  453b		       00		      .byte.b	0
   5311  453b					      repend
   5312  453c		       00		      .byte.b	0
   5311  453c					      repend
   5312  453d		       00		      .byte.b	0
   5311  453d					      repend
   5312  453e		       00		      .byte.b	0
   5311  453e					      repend
   5312  453f		       00		      .byte.b	0
   5311  453f					      repend
   5312  4540		       00		      .byte.b	0
   5311  4540					      repend
   5312  4541		       00		      .byte.b	0
   5311  4541					      repend
   5312  4542		       00		      .byte.b	0
   5311  4542					      repend
   5312  4543		       00		      .byte.b	0
   5311  4543					      repend
   5312  4544		       00		      .byte.b	0
   5311  4544					      repend
   5312  4545		       00		      .byte.b	0
   5311  4545					      repend
   5312  4546		       00		      .byte.b	0
   5311  4546					      repend
   5312  4547		       00		      .byte.b	0
   5311  4547					      repend
   5312  4548		       00		      .byte.b	0
   5311  4548					      repend
   5312  4549		       00		      .byte.b	0
   5311  4549					      repend
   5312  454a		       00		      .byte.b	0
   5311  454a					      repend
   5312  454b		       00		      .byte.b	0
   5311  454b					      repend
   5312  454c		       00		      .byte.b	0
   5311  454c					      repend
   5312  454d		       00		      .byte.b	0
   5311  454d					      repend
   5312  454e		       00		      .byte.b	0
   5311  454e					      repend
   5312  454f		       00		      .byte.b	0
   5311  454f					      repend
   5312  4550		       00		      .byte.b	0
   5311  4550					      repend
   5312  4551		       00		      .byte.b	0
   5311  4551					      repend
   5312  4552		       00		      .byte.b	0
   5311  4552					      repend
   5312  4553		       00		      .byte.b	0
   5311  4553					      repend
   5312  4554		       00		      .byte.b	0
   5311  4554					      repend
   5312  4555		       00		      .byte.b	0
   5311  4555					      repend
   5312  4556		       00		      .byte.b	0
   5311  4556					      repend
   5312  4557		       00		      .byte.b	0
   5313  4558					      repend
   5314  4558					      endif
   5315  4558					      endif
   5316  4558				   pfcolorlabel13
   5317  4558		       00 fc 42 00	      .byte.b	$0, $FC, $42,0
   5318  455c		       00 fc 42 00	      .byte.b	$0, $FC, $42,0
   5319  4560		       42 0e 42 00	      .byte.b	$42, $0E, $42,0
   5320  4564		       42 fc 42 00	      .byte.b	$42, $FC, $42,0
   5321  4568		       42 0e 42 00	      .byte.b	$42, $0E, $42,0
   5322  456c		       42 fc 42 00	      .byte.b	$42, $FC, $42,0
   5323  4570		       42 0e 42 00	      .byte.b	$42, $0E, $42,0
   5324  4574		       42 fc 42 00	      .byte.b	$42, $FC, $42,0
   5325  4578		       00 0e 42 00	      .byte.b	$0, $0E, $42,0
   5326  457c		       00 fc 42 00	      .byte.b	$0, $FC, $42,0
   5327  4580		       00 fc 42 00	      .byte.b	$0, $FC, $42,0
   5328  4584				  -	      if	(<*) > (<(*+4))
   5329  4584				  -	      repeat	($100-<*)
   5330  4584				  -	      .byte	0
   5331  4584				  -	      repend
   5332  4584					      endif
   5333  4584				   player146then_0
   5334  4584		       24		      .byte.b	%00100100
   5335  4585		       5a		      .byte.b	%01011010
   5336  4586		       5a		      .byte.b	%01011010
   5337  4587		       24		      .byte.b	%00100100
   5338  4588		       18		      .byte.b	%00011000
   5339  4589				  -	      if	(<*) > (<(*+4))
   5340  4589				  -	      repeat	($100-<*)
   5341  4589				  -	      .byte	0
   5342  4589				  -	      repend
   5343  4589					      endif
   5344  4589				   player147then_0
   5345  4589		       18		      .byte.b	%00011000
   5346  458a		       34		      .byte.b	%00110100
   5347  458b		       78		      .byte.b	%01111000
   5348  458c		       54		      .byte.b	%01010100
   5349  458d		       2c		      .byte.b	%00101100
   5350  458e				  -	      if	(<*) > (<(*+5))
   5351  458e				  -	      repeat	($100-<*)
   5352  458e				  -	      .byte	0
   5353  458e				  -	      repend
   5354  458e					      endif
   5355  458e				   player148then_0
   5356  458e		       18		      .byte.b	%00011000
   5357  458f		       24		      .byte.b	%00100100
   5358  4590		       1a		      .byte.b	%00011010
   5359  4591		       1a		      .byte.b	%00011010
   5360  4592		       24		      .byte.b	%00100100
   5361  4593		       18		      .byte.b	%00011000
   5362  4594				  -	      if	(<*) > (<(*+4))
   5363  4594				  -	      repeat	($100-<*)
   5364  4594				  -	      .byte	0
   5365  4594				  -	      repend
   5366  4594					      endif
   5367  4594				   player149then_0
   5368  4594		       2c		      .byte.b	%00101100
   5369  4595		       54		      .byte.b	%01010100
   5370  4596		       78		      .byte.b	%01111000
   5371  4597		       34		      .byte.b	%00110100
   5372  4598		       18		      .byte.b	%00011000
   5373  4599				  -	      if	(<*) > (<(*+4))
   5374  4599				  -	      repeat	($100-<*)
   5375  4599				  -	      .byte	0
   5376  4599				  -	      repend
   5377  4599					      endif
   5378  4599				   player150then_0
   5379  4599		       18		      .byte.b	%00011000
   5380  459a		       24		      .byte.b	%00100100
   5381  459b		       5a		      .byte.b	%01011010
   5382  459c		       5a		      .byte.b	%01011010
   5383  459d		       24		      .byte.b	%00100100
   5384  459e				  -	      if	(<*) > (<(*+4))
   5385  459e				  -	      repeat	($100-<*)
   5386  459e				  -	      .byte	0
   5387  459e				  -	      repend
   5388  459e					      endif
   5389  459e				   player151then_0
   5390  459e		       34		      .byte.b	%00110100
   5391  459f		       2a		      .byte.b	%00101010
   5392  45a0		       1e		      .byte.b	%00011110
   5393  45a1		       2c		      .byte.b	%00101100
   5394  45a2		       18		      .byte.b	%00011000
   5395  45a3				  -	      if	(<*) > (<(*+5))
   5396  45a3				  -	      repeat	($100-<*)
   5397  45a3				  -	      .byte	0
   5398  45a3				  -	      repend
   5399  45a3					      endif
   5400  45a3				   player152then_0
   5401  45a3		       30		      .byte.b	%00110000
   5402  45a4		       48		      .byte.b	%01001000
   5403  45a5		       b0		      .byte.b	%10110000
   5404  45a6		       b0		      .byte.b	%10110000
   5405  45a7		       48		      .byte.b	%01001000
   5406  45a8		       30		      .byte.b	%00110000
   5407  45a9				  -	      if	(<*) > (<(*+4))
   5408  45a9				  -	      repeat	($100-<*)
   5409  45a9				  -	      .byte	0
   5410  45a9				  -	      repend
   5411  45a9					      endif
   5412  45a9				   player153then_0
   5413  45a9		       18		      .byte.b	%00011000
   5414  45aa		       2c		      .byte.b	%00101100
   5415  45ab		       1e		      .byte.b	%00011110
   5416  45ac		       2a		      .byte.b	%00101010
   5417  45ad		       34		      .byte.b	%00110100
   5418  45ae				  -	      if	(<*) > (<(*+4))
   5419  45ae				  -	      repeat	($100-<*)
   5420  45ae				  -	      .byte	0
   5421  45ae				  -	      repend
   5422  45ae					      endif
   5423  45ae				   playerL0328_1
   5424  45ae		       18		      .byte.b	%00011000
   5425  45af		       66		      .byte.b	%01100110
   5426  45b0		       91		      .byte.b	%10010001
   5427  45b1		       7e		      .byte.b	%01111110
   5428  45b2		       00		      .byte.b	%00000000
   5429  45b3				  -	      if	(<*) > (<(*+4))
   5430  45b3				  -	      repeat	($100-<*)
   5431  45b3				  -	      .byte	0
   5432  45b3				  -	      repend
   5433  45b3					      endif
   5434  45b3				   playerL0332_1
   5435  45b3		       18		      .byte.b	%00011000
   5436  45b4		       66		      .byte.b	%01100110
   5437  45b5		       91		      .byte.b	%10010001
   5438  45b6		       7e		      .byte.b	%01111110
   5439  45b7		       00		      .byte.b	%00000000
   5440  45b8				  -	      if	(<*) > (<(*+4))
   5441  45b8				  -	      repeat	($100-<*)
   5442  45b8				  -	      .byte	0
   5443  45b8				  -	      repend
   5444  45b8					      endif
   5445  45b8				   playerL0336_1
   5446  45b8		       18		      .byte.b	%00011000
   5447  45b9		       66		      .byte.b	%01100110
   5448  45ba		       3c		      .byte.b	%00111100
   5449  45bb		       66		      .byte.b	%01100110
   5450  45bc		       18		      .byte.b	%00011000
   5451  45bd				  -	      if	(<*) > (<(*+4))
   5452  45bd				  -	      repeat	($100-<*)
   5453  45bd				  -	      .byte	0
   5454  45bd				  -	      repend
   5455  45bd					      endif
   5456  45bd				   playerL0340_1
   5457  45bd		       18		      .byte.b	%00011000
   5458  45be		       66		      .byte.b	%01100110
   5459  45bf		       3c		      .byte.b	%00111100
   5460  45c0		       66		      .byte.b	%01100110
   5461  45c1		       18		      .byte.b	%00011000
   5462  45c2				  -	      if	(<*) > (<(*+4))
   5463  45c2				  -	      repeat	($100-<*)
   5464  45c2				  -	      .byte	0
   5465  45c2				  -	      repend
   5466  45c2					      endif
   5467  45c2				   playerL0344_1
   5468  45c2		       18		      .byte.b	%00011000
   5469  45c3		       24		      .byte.b	%00100100
   5470  45c4		       5a		      .byte.b	%01011010
   5471  45c5		       24		      .byte.b	%00100100
   5472  45c6		       18		      .byte.b	%00011000
   5473  45c7					      if	ECHOFIRST
      2477 bytes of ROM space left in bank 4
   5474  45c7					      echo	"    ",[(scoretable - *)]d , "bytes of ROM space left in bank 4")
   5475  45c7					      endif
   5476  45c7		       00 01	   ECHOFIRST  =	1
   5477  45c7
   5478  45c7
   5479  45c7							; Provided under the CC0 license. See the included LICENSE.txt for details.
   5480  45c7
   5481  45c7							; feel free to modify the score graphics - just keep each digit 8 high
   5482  45c7							; and keep the conditional compilation stuff intact
   5483  45c7				  -	      ifconst	ROM2k
   5484  45c7				  -	      ORG	$F7AC-8
   5485  45c7					      else
   5486  45c7					      ifconst	bankswitch
   5487  45c7				  -	      if	bankswitch == 8
   5488  45c7				  -	      ORG	$2F94-bscode_length
   5489  45c7				  -	      RORG	$FF94-bscode_length
   5490  45c7					      endif
   5491  45c7					      if	bankswitch == 16
   5492  4f74					      ORG	$4F94-bscode_length
   5493  4f74					      RORG	$FF94-bscode_length
   5494  4f74					      endif
   5495  4f74				  -	      if	bankswitch == 32
   5496  4f74				  -	      ORG	$8F94-bscode_length
   5497  4f74				  -	      RORG	$FF94-bscode_length
   5498  4f74					      endif
   5499  4f74				  -	      if	bankswitch == 64
   5500  4f74				  -	      ORG	$10F80-bscode_length
   5501  4f74				  -	      RORG	$1FF80-bscode_length
   5502  4f74					      endif
   5503  4f74				  -	      else
   5504  4f74				  -	      ORG	$FF9C
   5505  4f74					      endif
   5506  4f74					      endif
   5507  4f74
   5508  4f74							; font equates
   5509  4f74		       00 01	   .21stcentury =	1
   5510  4f74		       00 02	   alarmclock =	2
   5511  4f74		       00 03	   handwritten =	3
   5512  4f74		       00 04	   interrupted =	4
   5513  4f74		       00 05	   retroputer =	5
   5514  4f74		       00 06	   whimsey    =	6
   5515  4f74		       00 07	   tiny       =	7
   5516  4f74		       00 08	   hex	      =	8
   5517  4f74
   5518  4f74					      ifconst	font
   5519  4f74				  -	      if	font == hex
   5520  4f74				  -	      ORG	. - 48
   5521  4f74					      endif
   5522  4f74					      endif
   5523  4f74
   5524  4f74				   scoretable
   5525  4f74
   5526  4f74					      ifconst	font
   5527  4f74					      if	font == .21stcentury
------- FILE score_graphics.asm.21stcentury LEVEL 2 PASS 2
      0  4f74					      include	"score_graphics.asm.21stcentury"
      1  4f74							; Provided under the CC0 license. See the included LICENSE.txt for details.
      2  4f74
      3  4f74		       3c		      .byte.b	%00111100
      4  4f75		       42		      .byte.b	%01000010
      5  4f76		       42		      .byte.b	%01000010
      6  4f77		       42		      .byte.b	%01000010
      7  4f78		       42		      .byte.b	%01000010
      8  4f79		       42		      .byte.b	%01000010
      9  4f7a		       42		      .byte.b	%01000010
     10  4f7b		       3c		      .byte.b	%00111100
     11  4f7c
     12  4f7c		       08		      .byte.b	%00001000
     13  4f7d		       08		      .byte.b	%00001000
     14  4f7e		       08		      .byte.b	%00001000
     15  4f7f		       08		      .byte.b	%00001000
     16  4f80		       08		      .byte.b	%00001000
     17  4f81		       08		      .byte.b	%00001000
     18  4f82		       08		      .byte.b	%00001000
     19  4f83		       08		      .byte.b	%00001000
     20  4f84
     21  4f84		       7e		      .byte.b	%01111110
     22  4f85		       40		      .byte.b	%01000000
     23  4f86		       40		      .byte.b	%01000000
     24  4f87		       40		      .byte.b	%01000000
     25  4f88		       3c		      .byte.b	%00111100
     26  4f89		       02		      .byte.b	%00000010
     27  4f8a		       02		      .byte.b	%00000010
     28  4f8b		       1c		      .byte.b	%00011100
     29  4f8c
     30  4f8c		       7c		      .byte.b	%01111100
     31  4f8d		       02		      .byte.b	%00000010
     32  4f8e		       02		      .byte.b	%00000010
     33  4f8f		       02		      .byte.b	%00000010
     34  4f90		       7c		      .byte.b	%01111100
     35  4f91		       02		      .byte.b	%00000010
     36  4f92		       02		      .byte.b	%00000010
     37  4f93		       1c		      .byte.b	%00011100
     38  4f94
     39  4f94		       02		      .byte.b	%00000010
     40  4f95		       02		      .byte.b	%00000010
     41  4f96		       02		      .byte.b	%00000010
     42  4f97		       7e		      .byte.b	%01111110
     43  4f98		       42		      .byte.b	%01000010
     44  4f99		       42		      .byte.b	%01000010
     45  4f9a		       42		      .byte.b	%01000010
     46  4f9b		       42		      .byte.b	%01000010
     47  4f9c
     48  4f9c		       7c		      .byte.b	%01111100
     49  4f9d		       02		      .byte.b	%00000010
     50  4f9e		       02		      .byte.b	%00000010
     51  4f9f		       02		      .byte.b	%00000010
     52  4fa0		       7c		      .byte.b	%01111100
     53  4fa1		       40		      .byte.b	%01000000
     54  4fa2		       40		      .byte.b	%01000000
     55  4fa3		       78		      .byte.b	%01111000
     56  4fa4
     57  4fa4		       3c		      .byte.b	%00111100
     58  4fa5		       42		      .byte.b	%01000010
     59  4fa6		       42		      .byte.b	%01000010
     60  4fa7		       42		      .byte.b	%01000010
     61  4fa8		       7c		      .byte.b	%01111100
     62  4fa9		       40		      .byte.b	%01000000
     63  4faa		       40		      .byte.b	%01000000
     64  4fab		       30		      .byte.b	%00110000
     65  4fac
     66  4fac		       10		      .byte.b	%00010000
     67  4fad		       10		      .byte.b	%00010000
     68  4fae		       08		      .byte.b	%00001000
     69  4faf		       08		      .byte.b	%00001000
     70  4fb0		       04		      .byte.b	%00000100
     71  4fb1		       04		      .byte.b	%00000100
     72  4fb2		       02		      .byte.b	%00000010
     73  4fb3		       7e		      .byte.b	%01111110
     74  4fb4
     75  4fb4		       3c		      .byte.b	%00111100
     76  4fb5		       42		      .byte.b	%01000010
     77  4fb6		       42		      .byte.b	%01000010
     78  4fb7		       42		      .byte.b	%01000010
     79  4fb8		       3c		      .byte.b	%00111100
     80  4fb9		       42		      .byte.b	%01000010
     81  4fba		       42		      .byte.b	%01000010
     82  4fbb		       3c		      .byte.b	%00111100
     83  4fbc
     84  4fbc		       0c		      .byte.b	%00001100
     85  4fbd		       02		      .byte.b	%00000010
     86  4fbe		       02		      .byte.b	%00000010
     87  4fbf		       02		      .byte.b	%00000010
     88  4fc0		       3e		      .byte.b	%00111110
     89  4fc1		       42		      .byte.b	%01000010
     90  4fc2		       42		      .byte.b	%01000010
     91  4fc3		       3c		      .byte.b	%00111100
     92  4fc4
     93  4fc4					      ifnconst	DPC_kernel_options
     94  4fc4
     95  4fc4		       00		      .byte.b	%00000000
     96  4fc5		       00		      .byte.b	%00000000
     97  4fc6		       00		      .byte.b	%00000000
     98  4fc7		       00		      .byte.b	%00000000
     99  4fc8		       00		      .byte.b	%00000000
    100  4fc9		       00		      .byte.b	%00000000
    101  4fca		       00		      .byte.b	%00000000
    102  4fcb		       00		      .byte.b	%00000000
    103  4fcc
    104  4fcc					      endif
------- FILE /Users/jblanchard/Documents/Code/Retro/Atari2600/Jurl/Jurl.bas.asm
   5529  4fcc					      endif
   5530  4fcc				  -	      if	font == alarmclock
   5531  4fcc				  -	      include	"score_graphics.asm.alarmclock"
   5532  4fcc					      endif
   5533  4fcc				  -	      if	font == handwritten
   5534  4fcc				  -	      include	"score_graphics.asm.handwritten"
   5535  4fcc					      endif
   5536  4fcc				  -	      if	font == interrupted
   5537  4fcc				  -	      include	"score_graphics.asm.interrupted"
   5538  4fcc					      endif
   5539  4fcc				  -	      if	font == retroputer
   5540  4fcc				  -	      include	"score_graphics.asm.retroputer"
   5541  4fcc					      endif
   5542  4fcc				  -	      if	font == whimsey
   5543  4fcc				  -	      include	"score_graphics.asm.whimsey"
   5544  4fcc					      endif
   5545  4fcc				  -	      if	font == tiny
   5546  4fcc				  -	      include	"score_graphics.asm.tiny"
   5547  4fcc					      endif
   5548  4fcc				  -	      if	font == hex
   5549  4fcc				  -	      include	"score_graphics.asm.hex"
   5550  4fcc					      endif
   5551  4fcc				  -	      else		; default font
   5552  4fcc				  -
   5553  4fcc				  -	      .byte	%00111100
   5554  4fcc				  -	      .byte	%01100110
   5555  4fcc				  -	      .byte	%01100110
   5556  4fcc				  -	      .byte	%01100110
   5557  4fcc				  -	      .byte	%01100110
   5558  4fcc				  -	      .byte	%01100110
   5559  4fcc				  -	      .byte	%01100110
   5560  4fcc				  -	      .byte	%00111100
   5561  4fcc				  -
   5562  4fcc				  -	      .byte	%01111110
   5563  4fcc				  -	      .byte	%00011000
   5564  4fcc				  -	      .byte	%00011000
   5565  4fcc				  -	      .byte	%00011000
   5566  4fcc				  -	      .byte	%00011000
   5567  4fcc				  -	      .byte	%00111000
   5568  4fcc				  -	      .byte	%00011000
   5569  4fcc				  -	      .byte	%00001000
   5570  4fcc				  -
   5571  4fcc				  -	      .byte	%01111110
   5572  4fcc				  -	      .byte	%01100000
   5573  4fcc				  -	      .byte	%01100000
   5574  4fcc				  -	      .byte	%00111100
   5575  4fcc				  -	      .byte	%00000110
   5576  4fcc				  -	      .byte	%00000110
   5577  4fcc				  -	      .byte	%01000110
   5578  4fcc				  -	      .byte	%00111100
   5579  4fcc				  -
   5580  4fcc				  -	      .byte	%00111100
   5581  4fcc				  -	      .byte	%01000110
   5582  4fcc				  -	      .byte	%00000110
   5583  4fcc				  -	      .byte	%00000110
   5584  4fcc				  -	      .byte	%00011100
   5585  4fcc				  -	      .byte	%00000110
   5586  4fcc				  -	      .byte	%01000110
   5587  4fcc				  -	      .byte	%00111100
   5588  4fcc				  -
   5589  4fcc				  -	      .byte	%00001100
   5590  4fcc				  -	      .byte	%00001100
   5591  4fcc				  -	      .byte	%01111110
   5592  4fcc				  -	      .byte	%01001100
   5593  4fcc				  -	      .byte	%01001100
   5594  4fcc				  -	      .byte	%00101100
   5595  4fcc				  -	      .byte	%00011100
   5596  4fcc				  -	      .byte	%00001100
   5597  4fcc				  -
   5598  4fcc				  -	      .byte	%00111100
   5599  4fcc				  -	      .byte	%01000110
   5600  4fcc				  -	      .byte	%00000110
   5601  4fcc				  -	      .byte	%00000110
   5602  4fcc				  -	      .byte	%00111100
   5603  4fcc				  -	      .byte	%01100000
   5604  4fcc				  -	      .byte	%01100000
   5605  4fcc				  -	      .byte	%01111110
   5606  4fcc				  -
   5607  4fcc				  -	      .byte	%00111100
   5608  4fcc				  -	      .byte	%01100110
   5609  4fcc				  -	      .byte	%01100110
   5610  4fcc				  -	      .byte	%01100110
   5611  4fcc				  -	      .byte	%01111100
   5612  4fcc				  -	      .byte	%01100000
   5613  4fcc				  -	      .byte	%01100010
   5614  4fcc				  -	      .byte	%00111100
   5615  4fcc				  -
   5616  4fcc				  -	      .byte	%00110000
   5617  4fcc				  -	      .byte	%00110000
   5618  4fcc				  -	      .byte	%00110000
   5619  4fcc				  -	      .byte	%00011000
   5620  4fcc				  -	      .byte	%00001100
   5621  4fcc				  -	      .byte	%00000110
   5622  4fcc				  -	      .byte	%01000010
   5623  4fcc				  -	      .byte	%00111110
   5624  4fcc				  -
   5625  4fcc				  -	      .byte	%00111100
   5626  4fcc				  -	      .byte	%01100110
   5627  4fcc				  -	      .byte	%01100110
   5628  4fcc				  -	      .byte	%01100110
   5629  4fcc				  -	      .byte	%00111100
   5630  4fcc				  -	      .byte	%01100110
   5631  4fcc				  -	      .byte	%01100110
   5632  4fcc				  -	      .byte	%00111100
   5633  4fcc				  -
   5634  4fcc				  -	      .byte	%00111100
   5635  4fcc				  -	      .byte	%01000110
   5636  4fcc				  -	      .byte	%00000110
   5637  4fcc				  -	      .byte	%00111110
   5638  4fcc				  -	      .byte	%01100110
   5639  4fcc				  -	      .byte	%01100110
   5640  4fcc				  -	      .byte	%01100110
   5641  4fcc				  -	      .byte	%00111100
   5642  4fcc				  -
   5643  4fcc				  -	      ifnconst	DPC_kernel_options
   5644  4fcc				  -
   5645  4fcc				  -	      .byte	%00000000
   5646  4fcc				  -	      .byte	%00000000
   5647  4fcc				  -	      .byte	%00000000
   5648  4fcc				  -	      .byte	%00000000
   5649  4fcc				  -	      .byte	%00000000
   5650  4fcc				  -	      .byte	%00000000
   5651  4fcc				  -	      .byte	%00000000
   5652  4fcc				  -	      .byte	%00000000
   5653  4fcc				  -
   5654  4fcc				  -	      endif
   5655  4fcc				  -
   5656  4fcc					      endif
   5657  4fcc
   5658  4fcc				  -	      ifconst	ROM2k
   5659  4fcc				  -	      ORG	$F7FC
   5660  4fcc					      else
   5661  4fcc					      ifconst	bankswitch
   5662  4fcc				  -	      if	bankswitch == 8
   5663  4fcc				  -	      ORG	$2FF4-bscode_length
   5664  4fcc				  -	      RORG	$FFF4-bscode_length
   5665  4fcc					      endif
   5666  4fcc					      if	bankswitch == 16
   5667  4fd4					      ORG	$4FF4-bscode_length
   5668  4fd4					      RORG	$FFF4-bscode_length
   5669  4fd4					      endif
   5670  4fd4				  -	      if	bankswitch == 32
   5671  4fd4				  -	      ORG	$8FF4-bscode_length
   5672  4fd4				  -	      RORG	$FFF4-bscode_length
   5673  4fd4					      endif
   5674  4fd4				  -	      if	bankswitch == 64
   5675  4fd4				  -	      ORG	$10FE0-bscode_length
   5676  4fd4				  -	      RORG	$1FFE0-bscode_length
   5677  4fd4					      endif
   5678  4fd4				  -	      else
   5679  4fd4				  -	      ORG	$FFFC
   5680  4fd4					      endif
   5681  4fd4					      endif
   5682  4fd4							; Provided under the CC0 license. See the included LICENSE.txt for details.
   5683  4fd4
   5684  4fd4							; every bank has this stuff at the same place
   5685  4fd4							; this code can switch to/from any bank at any entry point
   5686  4fd4							; and can preserve register values
   5687  4fd4							; note: lines not starting with a space are not placed in all banks
   5688  4fd4							;
   5689  4fd4							; line below tells the compiler how long this is - do not remove
   5690  4fd4							;size=32
   5691  4fd4
   5692  4fd4				   begin_bscode
   5693  4fd4		       a2 ff		      ldx	#$ff
   5694  4fd6				  -	      ifconst	FASTFETCH	; using DPC+
   5695  4fd6				  -	      stx	FASTFETCH
   5696  4fd6					      endif
   5697  4fd6		       9a		      txs
   5698  4fd7				  -	      if	bankswitch == 64
   5699  4fd7				  -	      lda	#(((>(start-1)) & $0F) | $F0)
   5700  4fd7					      else
   5701  4fd7		       a9 f2		      lda	#>(start-1)
   5702  4fd9					      endif
   5703  4fd9		       48		      pha
   5704  4fda		       a9 51		      lda	#<(start-1)
   5705  4fdc		       48		      pha
   5706  4fdd
   5707  4fdd				   BS_return
   5708  4fdd		       48		      pha
   5709  4fde		       8a		      txa
   5710  4fdf		       48		      pha
   5711  4fe0		       ba		      tsx
   5712  4fe1
   5713  4fe1					      if	bankswitch != 64
   5714  4fe1		       b5 04		      lda	4,x	; get high byte of return address
   5715  4fe3
   5716  4fe3		       2a		      rol
   5717  4fe4		       2a		      rol
   5718  4fe5		       2a		      rol
   5719  4fe6		       2a		      rol
   5720  4fe7		       29 03		      and	#bs_mask	;1 3 or 7 for F8/F6/F4
   5721  4fe9		       aa		      tax
   5722  4fea		       e8		      inx
   5723  4feb				  -	      else
   5724  4feb				  -	      lda	4,x	; get high byte of return address
   5725  4feb				  -	      tay
   5726  4feb				  -	      ora	#$10	; change our bank nibble into a valid rom mirror
   5727  4feb				  -	      sta	4,x
   5728  4feb				  -	      tya
   5729  4feb				  -	      lsr
   5730  4feb				  -	      lsr
   5731  4feb				  -	      lsr
   5732  4feb				  -	      lsr
   5733  4feb				  -	      tax
   5734  4feb				  -	      inx
   5735  4feb					      endif
   5736  4feb
   5737  4feb				   BS_jsr
   5738  4feb		       bd f5 1f 	      lda	bankswitch_hotspot-1,x
   5739  4fee		       68		      pla
   5740  4fef		       aa		      tax
   5741  4ff0		       68		      pla
   5742  4ff1		       60		      rts
   5743  4ff2				  -	      if	((* & $1FFF) > ((bankswitch_hotspot & $1FFF) - 1))
   5744  4ff2				  -	      echo	"WARNING: size parameter in banksw.asm too small - the program probably will not work."
   5745  4ff2				  -	      echo	"Change to",[(*-begin_bscode+1)&$FF]d,"and try again."
   5746  4ff2					      endif
   5747  4ff2							; Provided under the CC0 license. See the included LICENSE.txt for details.
   5748  4ff2
   5749  4ff2					      ifconst	bankswitch
   5750  4ff2				  -	      if	bankswitch == 8
   5751  4ff2				  -	      ORG	$2FFC
   5752  4ff2				  -	      RORG	$FFFC
   5753  4ff2					      endif
   5754  4ff2					      if	bankswitch == 16
   5755  4ffc					      ORG	$4FFC
   5756  4ffc					      RORG	$FFFC
   5757  4ffc					      endif
   5758  4ffc				  -	      if	bankswitch == 32
   5759  4ffc				  -	      ORG	$8FFC
   5760  4ffc				  -	      RORG	$FFFC
   5761  4ffc					      endif
   5762  4ffc				  -	      if	bankswitch == 64
   5763  4ffc				  -	      ORG	$10FF0
   5764  4ffc				  -	      RORG	$1FFF0
   5765  4ffc				  -	      lda	$ffe0	; we use wasted space to assist stella with EF format auto-detection
   5766  4ffc				  -	      ORG	$10FF8
   5767  4ffc				  -	      RORG	$1FFF8
   5768  4ffc				  -	      ifconst	superchip
   5769  4ffc				  -	      .byte	"E","F","S","C"
   5770  4ffc				  -	      else
   5771  4ffc				  -	      .byte	"E","F","E","F"
   5772  4ffc				  -	      endif
   5773  4ffc				  -	      ORG	$10FFC
   5774  4ffc				  -	      RORG	$1FFFC
   5775  4ffc					      endif
   5776  4ffc				  -	      else
   5777  4ffc				  -	      ifconst	ROM2k
   5778  4ffc				  -	      ORG	$F7FC
   5779  4ffc				  -	      else
   5780  4ffc				  -	      ORG	$FFFC
   5781  4ffc				  -	      endif
   5782  4ffc					      endif
   5783  4ffc		       52 f2		      .word.w	(start & $ffff)
   5784  4ffe		       52 f2		      .word.w	(start & $ffff)
